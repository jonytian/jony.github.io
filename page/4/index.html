<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 › 子非鱼</title>
  <meta name="author" content="jony">
  
  <meta name="description" content="Test description">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="子非鱼"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="子非鱼" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">子非鱼</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Java并发/Java并发编程基础/">Java并发编程基础</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <p>因为最近的项目遇到大量并发编程的问题，抽出时间把并发编程的基础整理一下，毕竟万丈高楼平地起。更深层次的并发编程会在以后的博客中介绍。<br>#一、为什么要并发编程？</p>
<ul>
<li>并发编程可以使程序的执行速度更快。多处理器的情况并发编程可以更好的发挥多个处理器的能力，从而提高程序的执行速度，但是，并发编程通常是提高运行在单处理器上的程序性能。初看，线程间的上下文切换会增大开销，并不能提高程序的执行性能。但是，<strong>阻塞</strong>使情况变得不同。如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，此时该线程阻塞，并发使得其他的线程可以继续处理其他的任务，而不用一直等待，从而提高了程序整体的执行效率。</li>
<li>实现并发编程最直接的方式是在操作系统级别使用<strong>进程</strong>。进程是运行在他自己的地址空间内的自包容程序。像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。</li>
</ul>
<p>#二、Java并发编程基础知识点</p>
<h2 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h2><ul>
<li>线程可以驱动任务，因此需要一种描述任务的方式，这可以由Runnable接口来提供。任务的run()方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所有要设定跳出循环的条件condition。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TaskDemo impement Runnable&#123;</span><br><span class="line">				public void run()&#123;</span><br><span class="line">					while(condition)&#123;</span><br><span class="line">						&#x2F;&#x2F;doSomething</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Thread-yield-方法"><a href="#Thread-yield-方法" class="headerlink" title="Thread.yield()方法"></a>Thread.yield()方法</h2><ul>
<li>在run()中对静态方法Thread.yield()的调用是对线程调度器的一种建议。它声明：“我已经执行完生命周期中最重要的部分了。此刻正是切换给其他任务执行一段时间的大好时机”。当调用yield()方法时，你也是在建议具有相同优先级的其他线程可以运行。<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2></li>
<li>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t&#x3D;new Thread(new TaskDemo());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>



<h2 id="使用Excecutor"><a href="#使用Excecutor" class="headerlink" title="使用Excecutor"></a>使用Excecutor</h2><ul>
<li>Java SE5的java.util.concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。Executor在客户端和任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor容许你管理异步任务的执行，而无需显示的管理线程的生命周期，也就是说不用显示的调用开启线程的start（）方法。非常常见的情况是，单个的Executor被用来创建和管理系统中的所有任务。</li>
<li>对shutdown()方法的调用可以防止新的任务被提交给这个Executor对象，当前线程将继续运行在shutdown（）被调用之前所提交的的所有任务。这个程序将在Executor中的所有任务完成之后尽快推出。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里写代码片ExecutorService exec&#x3D;Executors.newCachedThreadPool();</span><br><span class="line">for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">	exec.execute(new TaskDemo());</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>在介绍下面几个Executors的方法前，先介绍一下几个类，接口，方法之间的关系</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;interface&gt;&gt;Executor &lt;-- &lt;&lt;interface&gt;&gt;ExecutorService &lt;-- ThreadPoolEcecutor</span><br><span class="line">&lt;-- 返回 Executors(class) 静态方法：1,newCacheThreadPool();2,newFixedThreadPool(number);3,newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></li>
<li><p>有了FixedThreadPool就可以一次性预先执行代价高昂的线程分配，因而也就可以限定线程的数量了。这可以节省时间，因为不用为每个人物都固定的付出创建线程的开销。当然CachedThreadPool在执行程序的过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。</p>
</li>
<li><p>SingleThreadPool就像是线程数量为1的FixedThreadPool。这对于你希望在另一个线程中连续运行的任何事物（长期存活的任务）来说是很有用的，例如监听进入的套接字连接的任务。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并维护它自己（隐藏）的悬挂任务队列。</p>
<h2 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h2></li>
<li><p>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()（而不是run()）中返回的值，并且必须使用ExecutorService.submit()方法调用它。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt;&#123;</span><br><span class="line">	public String call()&#123;</span><br><span class="line">		return &quot;xxx&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Future&lt;String&gt;&gt; results&#x3D;new ArrayList&lt;Fureture&lt;String&gt;&gt;();</span><br><span class="line">for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">	results.add(exec.submit(new TaskWithResult()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone进行检查就直接调用get(),在这种情况下，get()将阻塞，直至结果准备就绪。</p>
</li>
</ul>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><ul>
<li><p>休眠任务行为的一种简单方法是调用sleep()，这将使任务终止执行给定的时间。任务睡眠（即阻塞），这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。但是顺序行为依赖于底层的线程机制，这种机制在不同的操作系统之间是有差异的，因此，你不能依赖于它。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2></li>
<li><p>线程的优先级将该线程的重要性传递给了调度器。尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程先执行。然而，这并不意味着优先权较低的线程将得不到执行。优先权较低的线程仅仅是执行的频率较低。JDK有10个优先级，一般只使用Thread.MAX_PRIORITY，Thread.NORM_PRIORITY,Thread.MIN__PRIORITY。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getPriority(...);&#x2F;&#x2F;读取现有线程的优先级</span><br><span class="line">setPriority();&#x2F;&#x2F;修改现有线程的优先级</span><br><span class="line">Thread.currentThread().setPriority(...);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><ul>
<li>所谓后台（Daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止（例如执行main()的就是一个非后台线程）。</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public SimpleDaemons implement Runnable&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		&#x2F;&#x2F;dosomething();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Thread daemon&#x3D;new Thread(new SimpleDaemons());</span><br><span class="line">		daemon.setDaemon(true);</span><br><span class="line">		daemon.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。</p>
</li>
<li><p>通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台，优先级，名称）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DaemonThreadFactory implement ThreadFactory&#123;</span><br><span class="line">	public Thread newThread(Runnable r)&#123;</span><br><span class="line">		&#x2F;&#x2F;dosomething;&#x2F;&#x2F;设置线程的属性操作</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ExeccutorService exec&#x3D;Executors.newCacheThreadPool(new DaemonThreadFactory());</span><br><span class="line">exec.execute(new DaemonFromFactory);&#x2F;&#x2F;DaemonFromFactory类是一个实现了Runnable接口的类，在DaemonFromFactory类中覆写run方法</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置为后台线程。</li>
</ul>
</li>
</ul>
<h2 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h2><ul>
<li>一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程才能继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A             |          线程B</span><br><span class="line">B.join()          | </span><br><span class="line">A线程挂起，B运行完  |</span><br><span class="line">A才能继续运行      |</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>也可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法是在调用线程（即调用join()方法的线程）上调用interrupt()方法，这时需要用到try-catch语句。</li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><ul>
<li>由于线程的本质特征，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常。Java SE5中，可以用Executor来解决这个问题。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此类中设定对应线程中抛出异常的处理</span><br><span class="line">class MyUnCaughtExceptionHandler implements Thread.UnCaughtExceptionHandler &#123;</span><br><span class="line">	public void uncaughtException(Thread t,Throwable e)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;该线程工厂类中设定线程异常的监听器</span><br><span class="line">class Handler implements ThreadFactory&#123;</span><br><span class="line">	public Thread newThread(Runnable r)&#123;</span><br><span class="line">		Thread t&#x3D;new Thread(r);</span><br><span class="line">		t.setUnCaughtExceptionHandler(new MyUnCaughtExceptionHandler());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用定制化的线程工厂类创建线程池，并开启线程</span><br><span class="line">ExcutorService exec &#x3D;Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">exec.execute(new ExceptionThread());</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h2><ul>
<li>基本上所有的并发模式在解决线程冲突的时候，都采用序列化访问共享资源的方案。这意味着在给定时刻只容许一个任务访问共享资源。通常这是在代码前面加上一条锁机制语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量（mutex）。</li>
<li>共享资源一般是以对象形式存在的内存片段，但也可以是文件、输入/输出接口，或者是打印机。要控制对共享资源的访问，得先把他包装进一个对象。然后把所有要访问这个资源的方法标记为synchronized。</li>
<li>注意，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。</li>
<li>当同步方法访问操作共享资源时，其他的普通方法可以访问共享资源。因此，如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。如果只同步一个方法，那么其他方法将会随意地忽略这个对象锁，并可以在无任何惩罚的情况下被调用。这是很重要的一点：每个访问临界共享资源的方法都必须被同步，否则它们就不会正确的工作。</li>
</ul>
<h2 id="使用显式的Lock对象"><a href="#使用显式的Lock对象" class="headerlink" title="使用显式的Lock对象"></a>使用显式的Lock对象</h2><ul>
<li>Lock对象必须被显式的创建、锁定和释放。因此，它与内建的锁形式相比，代码缺乏优雅性。但是，对于解决某些类型的问题来说，它更加灵活。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Lock使用例子</span><br><span class="line">private Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>当你使用Lock对象时，将这里所示的惯用法内部化是很重要的：紧接着的对lock()的调用，你必须放置在finally子句中带有unlock()的try-finally语句中。return语句必须在try子句中出现，以确保unlock()不会过早的发生，从而将数据暴露给第二个任务。</li>
<li>大体上，当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显示的Lock对象。例如，用synchronized关键字不能尝试获得锁并且最终获取锁失败，或者尝试着获取锁一段时间，然后放弃它。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;尝试获取锁</span><br><span class="line">boolean captured&#x3D;false;</span><br><span class="line">captured&#x3D;lock.tryLock();</span><br><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	lock.unLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试获取锁一段时间</span><br><span class="line">try&#123;</span><br><span class="line">	captured&#x3D;lock.tryLock(2,TimeUnit.SECONDS);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;</span><br><span class="line">	throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	lock.unLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul>
<li><p>介绍volatile关键字前，先简单介绍一下Java内存模型一些性质。</p>
</li>
<li><p>Java内存模型规定：</p>
<ul>
<li>所有的变量都是存在主存中（相当于物理内存），</li>
<li>每个线程都有自己的工作内存（高速缓存），</li>
<li>线程对变量的操作都必须在工作内存中进行，而不能直接对主存进行操作，</li>
<li>每个线程不能访问其他线程的工作内存</li>
<li>例：i=10; 执行线程必须现在自己的工作线程中对变量i所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存中。</li>
</ul>
</li>
<li><p>Java对原子性、可见性，以及有序性提供的保证：</p>
<ul>
<li>原子性：在Java中，对基本数据类型的变量的读取操作是原子性操作，即这些操作是不可中断的，要么执行，要么不执行。</li>
</ul>
</li>
</ul>
<pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只有第一个语句是原子性操作</span><br><span class="line">x&#x3D;10;</span><br><span class="line">y&#x3D;x;</span><br><span class="line">x++;</span><br><span class="line">x&#x3D;x+1;</span><br></pre></td></tr></table></figure>
- 可见性：对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
- 有序性：在Java内存模型中，允许编译器和处理器对指令进行重新排序，但重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。在Java中，可以通过volatile保证一定的有序性。</code></pre>
<ul>
<li>深入剖析volatile关键字<ul>
<li>一旦一个共享变量（类的成员变量，类的静态成员变量）被volatile修饰，则具备两层含义。<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排</li>
</ul>
</li>
<li>volatile关键字无法保证对变量的所有操作都是原子性的。</li>
<li>volatile关键字禁止指令重排的两层意思：<ul>
<li>当程序执行到volatile变量的读取操作或写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面进行，也不能把volatile变量后的语句放到其前面执行。</li>
</ul>
</li>
<li>volatile关键字的原理和实现机制<ul>
<li>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏）。</li>
</ul>
</li>
<li>使用volatile关键字的场景<ul>
<li>synchronized关键字防止多个线程同时执行一段代码，那么就会很影响执行效率，而volatile关键字在某些情况下性能要由于synchronized，但要注意volatile关键字无法替代synchronized关键字，因为volatile关键字无法保证操作的原子性。</li>
</ul>
</li>
<li>使用volatile必须具备的两个条件：<ul>
<li>对变量的操作不依赖于当前值</li>
<li>该变量没有包含在其他变量的不变式中</li>
<li>使用volatile最常见的场景</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;volatile修饰状态标记量</span><br><span class="line">volatile boolean init&#x3D;false;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;线程1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">context&#x3D;loadContext();</span><br><span class="line">inited&#x3D;true;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;线程2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125; </span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><ul>
<li>Java SE5引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类。这些类被调整为可以使用在某些现代处理器上可获得的，并且是在机器级别上的原子性，因此使用它们时，通常不需要担心。对于常规编程来说，它们很少会排上用场，但是在涉及性能调优时，它们就大有用武之地了。</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li>有时，你只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出来的代码段被称为临界区，它也可以使用synchronized关键字建立。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制.这也被称为同步控制块；在进入此代码段前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(syncObject)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this)。</li>
</ul>
<h2 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h2><ul>
<li>防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;T&gt; connThreadLocal &#x3D; new ThreadLocal&lt;T&gt;();</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>ThreadLocal 对象通常当做静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容，其中get()方法将返回与线程相关联的对象的副本，而set()会将参数插入到其线程存储的对象中，并返回存储中原有的对象。 </li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul>
<li><p>新建（new）：当线程被新建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态。</p>
</li>
<li><p>就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。</p>
</li>
<li><p>阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。</p>
</li>
<li><p>死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。</p>
</li>
</ul>
<h2 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h2><ul>
<li>通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li>
<li>你通过wait()使线程挂起。直到线程得到了notify()或notifyAll()消息，线程才会进入就绪状态。</li>
<li>任务在等待某个输入/输出完成</li>
<li>任务试图在某个对象上调用其同步控制方法，但对象锁不可用，因为另一个任务已经获取了这个锁。 </li>
</ul>
<h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><ul>
<li><p>Thread.interrupt()方法不能中断一个正在运行的线程，这一方法实际完成的是，在线程受到阻塞时抛出一个中断信号，这样就可以退出阻塞状态。更确切的说，如果线程被object.wait(),Thread.join(),Thread.sleep()三种方法之一阻塞，那么，它将收到一个中断异常（InterruptedException），从而提早地终结被阻塞的状态。</p>
</li>
<li><p>中断线程最推荐的方式是使用共享变量（shared variable）发出信号，告诉线程必须停止正在运行的任务。</p>
</li>
<li><p>如果是被object.wait(),Thread.join(),Thread.sleep()三种方法之一阻塞，正常终止线程的方式是设置共享变量，并调用interrupt()（注意，变量应先设置）。</p>
</li>
<li><p>中断I/O操作</p>
<pre><code> - 如果正在使用通道channels（Java1.4引入的新的I/O API），那么被阻塞的线程将收到一个ClosedByInterruptException异常。
 - 如果使用的是Java1.0之前就存在的传统I/O，Thread.interrupt()将不起作用，因为线程将不会退出被阻塞状态。
 - Java平台为这种情形提供了一种解决方案，即调用阻塞该线程的套接字close方法。这种情形下，如果线程I/O操作阻塞，该线程将接收到一个SocketException异常，这与使用interrupt()方法引起一个InterruptedException异常被抛出非常相似。
 - 与I/O调用不同，interrupt()可以打断被互斥所阻塞的调用。</code></pre>
</li>
</ul>
<h2 id="关闭线程池的方法"><a href="#关闭线程池的方法" class="headerlink" title="关闭线程池的方法"></a>关闭线程池的方法</h2><ul>
<li><p>前面讲到Excutors类关闭线程池的方法，这里详细的介绍一下。</p>
</li>
<li><p>shutdown()方法：当线程池被调用该方法时线程池的状态立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务已经处理完毕，才能退出。</p>
</li>
<li><p>shutDownNow()方法：执行该方法线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。它会试图终止线程的方法是通过调用Thread.interrupt()方法来实现，但这种方法有限。例如，线程中没有sleep,wait,condition,定时锁等应用，interrupt方法是无法中断当前线程的。</p>
</li>
<li><p>interrupt、interrupted、isInterrupt的区别</p>
<ul>
<li>interrupt 设置线程的状态位为中断状态。</li>
<li>interrupted 作用于当前线程，返回线程的状态位后，要清掉原来的状态位（恢复为原来的样子）。</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static interrupted()&#123;</span><br><span class="line">	return currentThread.isInterrupted(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- isInterrupted 作用于调用该方法的线程对象对应的线程 ，直接返回线程的状态位。


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public native boolean isInterrupted()&#123;</span><br><span class="line">	return currentThread.isInterrupted(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h1 id="三、线程之间的协作"><a href="#三、线程之间的协作" class="headerlink" title="三、线程之间的协作"></a>三、线程之间的协作</h1><ul>
<li>只能在同步控制方法或同步控制块里调用wait()、notify()、notifyAll()（因为不用操作锁，所有sleep()可以在非同步控制块里调用）。如果非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如“当前线程不是拥有者”。<h2 id="使用notify，notifyAll-wait的原则"><a href="#使用notify，notifyAll-wait的原则" class="headerlink" title="使用notify，notifyAll,wait的原则"></a>使用notify，notifyAll,wait的原则</h2><ul>
<li>永远在synchronized的函数或对象里使用notify，notifyAll,wait，不然Java虚拟机会生成notify，notifyAll,wait异常。</li>
<li>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后检查wait条件，并在条件实际未改变的情况下使用wait。这样，循环会在线程睡眠前后检查wait条件，并在条件实际未改变的情况下处理唤醒通知。</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(condition)&#123;</span><br><span class="line">	object.wait();</span><br><span class="line">&#125;</span><br><span class="line">doSomething();</span><br><span class="line">&#x2F;&#x2F;注意wait()方法写在while和if中的区别</span><br><span class="line">if()&#123;</span><br><span class="line">	object.wait();</span><br><span class="line">&#125;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>永远在多线程间共享的对象（在生产者消费者模型里即缓冲）上使用wait。</li>
<li>倾向于使用notifyAll()而不是notify()。当notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒。</li>
<li>使用显式的Lock和Condition对象。Condition：await();signalAll();   每个对Lock()的调用都必须紧跟一个try-finally语句，用来保证在所有情况下都可以释放锁。  </li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">private Condition condition&#x3D;lock.newCondition();</span><br><span class="line">public coid method1() throws InterruptedException&#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> try&#123;</span><br><span class="line">	while(...)</span><br><span class="line">	condition.wait();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">         lock.unLock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;  </span><br><span class="line">public coid method2() throws InterruptedException&#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> try&#123;</span><br><span class="line">	while(...)</span><br><span class="line">	condition.signalAll();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">         lock.unLock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></code></pre>
<p>##生产者-消费者与队列</p>
<ul>
<li>wait()和notifyAll()方法以一种非常低级的方式解决了任务互操作的问题，即每次交互时都握手。在许多情况下，使用更高级别的抽象，使用同步队列解决问题，同步队列在任何时刻都只容许一个任务插入或移除元素。</li>
<li>队列接口Queue</li>
<li>BlockingQueue接口继承了Queue接口。</li>
<li>如果试图向一个已经满了的阻塞队列中添加一个元素或者是从一个空的阻塞队列中移除一个元素，将导致线程阻塞。在多线程合作时，阻塞队列是很有用的工具。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue:  offer()</span><br><span class="line">	peek()</span><br><span class="line">	element()</span><br><span class="line">	poll()</span><br><span class="line">	remove()</span><br><span class="line">BlockingQueue:  put()添加一个元素，如果队列满，则阻塞</span><br><span class="line">		take()移除并返回队列头部的元素，如果队列为空，则阻塞</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>BlockingQueue接口的实现类：</p>
<ul>
<li>ArrayBlockingQueue  (固定尺寸的)。a.基于数组的阻塞队列实现；b.在生产者放入数据和消费者获取数据，都是共用同一个锁对象。这也意味着两者无法真正并行运行。</li>
<li>LinkedBlockingQueue   （无界队列）。a.基于链表的阻塞队列；b.生产者和消费者分别采用了独立的锁来控制数据同步。</li>
</ul>
<p>##任务间使用管道进行输入/输出</p>
</li>
<li><p>通过输入/输出线程间进行通信很有用。提供线程功能的类库以“管道”的形式对线程间的输入输出提供了支持。它们在Java输入/输出类库中的对应物就是PipedWriter类（允许任务向管道写）和PipedWriter类（允许不同任务从同一管道中读取）。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Sender implements Runnable&#123;</span><br><span class="line">	private PipedWriter out&#x3D;new PipedWriter();</span><br><span class="line">	public PipedWriter getPipedWriter()&#123;return out;&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			...</span><br><span class="line">			out.write(数据);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Reveiver implements Runnable&#123;</span><br><span class="line">	private PipedReader in;</span><br><span class="line">	public Receiver(Sender sender)&#123;</span><br><span class="line">		in&#x3D;new PipedReader(sender.getPipedWriter());</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		while(true)&#123;</span><br><span class="line">			...</span><br><span class="line">			in.read();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PipedDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Sender sender&#x3D;new Sender();</span><br><span class="line">		Receiver receiver&#x3D;new Receiver(sender);</span><br><span class="line">		&#x2F;&#x2F;开启两个线程</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##死锁</p>
<ul>
<li>每个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环，没有哪个线程能继续。这被称为死锁。</li>
<li>当一下四个条件同时满足时，就会发生死锁：<ul>
<li>互斥条件。任务使用的资源中至少有一个是不能共享的。</li>
<li>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源</li>
<li>资源不能被任务抢占，任务必须把资源释放当做普通事件</li>
<li>必须有循环等待，这时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Java并发/负载均衡基础知识/">负载均衡</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h2 id="一、什么是负载均衡？"><a href="#一、什么是负载均衡？" class="headerlink" title="一、什么是负载均衡？"></a>一、什么是负载均衡？</h2><p>　互联网早期，业务流量比较小并且业务逻辑比较简单，单台服务器便可以满足基本的需求；但随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台机器的性能问题以及单点问题凸显了出来，因此需要多台机器来进行性能的水平扩展以及避免单点故障。但是要如何将不同的用户的流量分发到不同的服务器上面呢？<br><img src="http://img.blog.csdn.net/20180304163239781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>　早期的方法是使用DNS做负载，通过给客户端解析不同的IP地址，让客户端的流量直接到达各个服务器。但是这种方法有一个很大的缺点就是延时性问题，在做出调度策略改变以后，由于DNS各级节点的缓存并不会及时的在客户端生效，而且DNS负载的调度策略比较简单，无法满足业务需求，因此就出现了负载均衡。<br><img src="http://img.blog.csdn.net/20180304163338410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>　客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。<br><img src="http://img.blog.csdn.net/20180304163347624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>　负载均衡又分为四层负载均衡和七层负载均衡。四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。<br><img src="http://img.blog.csdn.net/20180304163358803?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>　七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。</p>
<h2 id="二、四层和七层负载均衡的区别？"><a href="#二、四层和七层负载均衡的区别？" class="headerlink" title="二、四层和七层负载均衡的区别？"></a>二、四层和七层负载均衡的区别？</h2><ul>
<li>2.1 - 技术原理上的区别。</li>
</ul>
<p>　所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>　以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
<p><img src="http://img.blog.csdn.net/20180304163438670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>　所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>　以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>　<br>　负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。那么，为什么还需要七层负载均衡呢？</p>
<ul>
<li>2.2 - 应用场景的需求。</li>
</ul>
<p>　七层应用负载的好处，是使得整个网络更”智能化”, 参考我们之前的另外一篇专门针对HTTP应用的优化的介绍，就可以基本上了解这种方式的优势所在。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p>
<p>　当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p>
<p>　另外一个常常被提到功能就是安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(DoS)的目的。</p>
<p>　从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。</p>
<p>　现在的7层负载均衡，主要还是着重于应用广泛的HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。</p>
<ul>
<li><p>2.3 - 七层应用需要考虑的问题。</p>
<p>  是否真的必要，七层应用的确可以提高流量智能化，同时必不可免的带来设备配置复杂，负载均衡压力增高以及故障排查上的复杂性等问题。在设计系统时需要考虑四层七层同时应用的混杂情况。</p>
<p>  是否真的可以提高安全性。例如SYN Flood攻击，七层模式的确将这些流量从服务器屏蔽，但负载均衡设备本身要有强大的抗DDoS能力，否则即使服务器正常而作为中枢调度的负载均衡设备故障也会导致整个应用的崩溃。</p>
<p>  是否有足够的灵活度。七层应用的优势是可以让整个应用的流量智能化，但是负载均衡设备需要提供完善的七层功能，满足客户根据不同情况的基于应用的调度。最简单的一个考核就是能否取代后台Nginx或者Apache等服务器上的调度功能。能够提供一个七层应用开发接口的负载均衡设备，可以让客户根据需求任意设定功能，才真正有可能提供强大的灵活性和智能性。</p>
</li>
</ul>
<h2 id="三、负载均衡的算法？"><a href="#三、负载均衡的算法？" class="headerlink" title="三、负载均衡的算法？"></a>三、负载均衡的算法？</h2><ul>
<li><p>1.随机算法</p>
<p>  Random随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</li>
<li><p>2.轮询及加权轮询</p>
<p>  轮询(Round Robbin)当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。 轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。<br>  加权轮询(Weighted Round Robbin)为轮询中的每台服务器附加一定权重的算法。比如服务器1权重1，服务器2权重2，服务器3权重3，则顺序为1-2-2-3-3-3-1-2-2-3-3-3- ……</p>
</li>
<li><p>3.最小连接及加权最小连接</p>
<p>  最少连接(Least Connections)在多个服务器中，与处理连接数(会话数)最少的服务器进行通信的算法。即使在每台服务器处理能力各不相同，每笔业务处理量也不相同的情况下，也能够在一定程度上降低服务器的负载。<br>  加权最少连接(Weighted Least Connection)为最少连接算法中的每台服务器附加权重的算法，该算法事先为每台服务器分配处理连接的数量，并将客户端请求转至连接数最少的服务器上。</p>
</li>
<li><p>4.哈希算法</p>
<p>  普通哈希<br>  一致性哈希一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</li>
<li><p>5.IP地址散列</p>
<p>  通过管理发送方IP和目的地IP地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p>
</li>
<li><p>6.URL散列</p>
<p>  通过管理客户端请求URL信息的散列，将发送至相同URL的请求转发至同一服务器的算法。</p>
</li>
</ul>
<p>##四、负载均衡的实现<br> （DNS &gt; 数据链路层 &gt; IP层 &gt; Http层）？</p>
<ul>
<li>1.DNS域名解析负载均衡（延迟）<br><img src="http://img.blog.csdn.net/20180304163530546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>DNS域名解析负载均衡</li>
</ul>
<p>　利用DNS处理域名解析请求的同时进行负载均衡是另一种常用的方案。在DNS服务器中配置多个A记录，如：<a target="_blank" rel="noopener" href="http://www.mysite.com/">www.mysite.com</a> IN A 114.100.80.1、<a target="_blank" rel="noopener" href="http://www.mysite.com/">www.mysite.com</a> IN A 114.100.80.2、<a target="_blank" rel="noopener" href="http://www.mysite.com/">www.mysite.com</a> IN A 114.100.80.3.<br>　每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。<br>　DNS域名解析负载均衡的优点是将负载均衡工作交给DNS，省略掉了网络管理的麻烦，缺点就是DNS可能缓存A记录，不受网站控制。事实上，大型网站总是部分使用DNS域名解析，作为第一级负载均衡手段，然后再在内部做第二级负载均衡。</p>
<ul>
<li>2.数据链路层负载均衡(LVS)</li>
</ul>
<p>数据链路层负载均衡(LVS)<br><img src="http://img.blog.csdn.net/2018030416354522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>　数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。<br>　这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）.<br>　在上图中，用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。<br>　使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。</p>
<ul>
<li><p>3.IP负载均衡(SNAT)<br><img src="http://img.blog.csdn.net/20180304163552562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>IP负载均衡<br>　IP负载均衡：即在网络层通过修改请求目标地址进行负载均衡。<br>　用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。<br>　这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。<br>　IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。但由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。</p>
</li>
<li><p>4.HTTP重定向负载均衡(少见)<br><img src="http://img.blog.csdn.net/20180304163600491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>HTTP重定向负载均衡<br>　HTTP重定向服务器是一台普通的应用服务器，其唯一的功能就是根据用户的HTTP请求计算一台真实的服务器地址，并将真实的服务器地址写入HTTP重定向响应中（响应状态吗302）返回给浏览器，然后浏览器再自动请求真实的服务器。<br>　这种负载均衡方案的优点是比较简单，缺点是浏览器需要每次请求两次服务器才能拿完成一次访问，性能较差；使用HTTP302响应码重定向，可能是搜索引擎判断为SEO作弊，降低搜索排名。重定向服务器自身的处理能力有可能成为瓶颈。因此这种方案在实际使用中并不见多。</p>
</li>
<li><p>5.反向代理负载均衡(nginx)<br><img src="http://img.blog.csdn.net/20180304163607812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>反向代理负载均衡<br>　传统代理服务器位于浏览器一端，代理浏览器将HTTP请求发送到互联网上。而反向代理服务器则位于网站机房一侧，代理网站web服务器接收http请求。<br>　反向代理的作用是保护网站安全，所有互联网的请求都必须经过代理服务器，相当于在web服务器和可能的网络攻击之间建立了一个屏障。<br>　除此之外，代理服务器也可以配置缓存加速web请求。当用户第一次访问静态内容的时候，静态内存就被缓存在反向代理服务器上，这样当其他用户访问该静态内容时，就可以直接从反向代理服务器返回，加速web请求响应速度，减轻web服务器负载压力。<br>　另外，反向代理服务器也可以实现负载均衡的功能。<br>反向代理服务器<br>　由于反向代理服务器转发请求在HTTP协议层面，因此也叫应用层负载均衡。优点是部署简单，缺点是可能成为系统的瓶颈。<br>参考文章</p>
</li>
</ul>
<p>[1 - MGW——美团点评高性能四层负载均衡]<br>[2 - 四层和七层负载均衡的区别]<br>[3 - 负载均衡算法及手段]</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Linux/Linux学习笔记（Shell）/">Linux学习笔记（Shell）</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h1 id="一、Bash-Shell基础"><a href="#一、Bash-Shell基础" class="headerlink" title="一、Bash Shell基础"></a>一、Bash Shell基础</h1><h3 id="1-Bash-Shell简单介绍"><a href="#1-Bash-Shell简单介绍" class="headerlink" title="1.Bash Shell简单介绍"></a>1.Bash Shell简单介绍</h3><ul>
<li><p>管理整个硬件的其实是核心（kernel），通常用户（user）都是以shell来与核心沟通。</p>
</li>
<li><p>什么是Shell？<br><img src="http://img.blog.csdn.net/20180305213607244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>我们通过shell与核心沟通，shell相当于用户和核心之间的桥梁。        </p>
</li>
<li><p>系统当前有多少Shells？可以检查一下/etc/shells文件。我们一般使用linux支持最广泛的bash。</p>
</li>
<li><p>Bash的主要优点：</p>
<ul>
<li>命令记忆能力：可以记忆使用过的命令。只要在命令行按“上下键”，就可以找到前一个输入的命令。</li>
<li>命令与文件补全功能：</li>
<li>热键[Tab]可以帮助我们少打很多字，并且确定输入的数据是正确的。<ul>
<li>[Tab]接在一串命令的第一个字的后面，则为命令补全；</li>
<li>[Tab]接在一串命令的第二个字以后，则为“文件补齐”。</li>
<li>想知道环境中可执行的命令有几个，直接在bash的提示符后输入两个[Tab][Tab]，就能输出所有可执行的命令了。</li>
<li>如果想要知道系统中所有以c开头的命令，则按下c[tab][tab]即可。</li>
</ul>
</li>
<li>命令别名（alias）设置功能：alias lm=’ls -al’ 自定义lm替换ls -al 命令。</li>
<li>Shell scripts的强大功能</li>
</ul>
</li>
<li><p>Bash Shell的内置命令：type</p>
<ul>
<li>为了方便shell的操作，bash已经“内置”了很多命令，如cd和umask等，都是内置在bash中的。如何知道一个命令是外部命令（其他非bash套件所提供的命令）还是内置在bash命令中的？下面介绍命令type:</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type [-tpa] name</span><br><span class="line">不加任何参数：type会显示出name是外部命令还是bash内置的命令。</span><br><span class="line">-t：加入该参数，type会将name通过下面这些文字显示出它的意义：</span><br><span class="line">	file：表示为外部命令</span><br><span class="line">	alias：表示该命令为命令别名所设置的名称</span><br><span class="line">	builtin：表示该命令为bash内置的命令功能</span><br><span class="line">-p：如果后面接的name为命令，会显示完整的文件名（外部命令）或显示为内置命令</span><br><span class="line">-a：在PATH变量定义的路径中，列出所有含有name的命令，包含alias。</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>执行命令</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command [-options] parameter1 parameter2</span><br><span class="line"> 命令       选项      参数（1）    参数（2）</span><br><span class="line"> command为命令的名称，如改变路径的命令为cd</span><br><span class="line"> -options为加入参数的设置，如-h等</span><br><span class="line"> parameter1 parameter2为跟在option后面的参数，或者是command的参数。</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="2-Shell的变量功能"><a href="#2-Shell的变量功能" class="headerlink" title="2.Shell的变量功能"></a>2.Shell的变量功能</h3><ul>
<li><p>前面我们提到，在任何地方执行ls，系统就是通过PATH变量里的内容所记录的路径顺序来搜索该命令。这是系统默认的变量的作用，如果是个人设置方面的应用，比如路径，使用变量，并将该变量定义写在最前面，后面相关的路径名称都以变量来替换，只需修改一行，就修改了整个脚本，很方便。</p>
</li>
<li><p>变量的获取与设置：echo、变量设置规则、unset<br>  使用echo命令可以获取变量，获取变量时，前面必须加上$。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo $&#123;PATH&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置或修改某个变量的内容<br>  规定：</p>
<ul>
<li><p>1.变量与变量内容以等号“=”来连接</p>
</li>
<li><p>2.等号两边不能直接接空格符</p>
</li>
<li><p>3.变量名称只能是英文字母与数字，但数字不能是开头字符</p>
</li>
<li><p>4.若有空格符，可以使用双引号或单引号将变量内容结合起来。需要注意的是：双引号内的特殊字符可以保持变量特性，但单引号内的特殊字符会变成一般符号。</p>
</li>
<li><p>5.必要时使用转义字符“\”将特殊字符（Enter,$,,空格等）转义为一般字符。</p>
</li>
<li><p>6.在一串命令中，还需要通过其他命令提供的信息，可以使用这样的方式 ‘commond’，注意不是单引号，是数字键1左边的那个按键。</p>
</li>
<li><p>7.若变量为扩展变量内容，需要以双引号及 $变量名称如  “$PATH”:/home继续累加内容。</p>
</li>
<li><p>8.若该变量需要在其他子程序中执行，则需要用export 使用变量变成环境变量，如“export PATH”。</p>
</li>
<li><p>9.通常大写字母为系统默认变量，自行设置变量可以使用小写字母，便于判断。</p>
</li>
<li><p>10.取消变量的方法为：“unset 变量名称”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $myname  这条命令执行完，没有任何数据，因为这个变量还未设置，是空的</span><br><span class="line">myname&#x3D;VBird  这条命令执行完，会将变量myname的内容设置为VBird</span><br><span class="line">echo $myname  这条命令执行完，显示VBird。</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">例一：设置变量name，内容为VBird</span><br><span class="line">name &#x3D; VBird  错误，因为有空白</span><br><span class="line">name&#x3D;VBird  OK</span><br><span class="line"></span><br><span class="line">例二：设置变量的内容为VBird&#39;s name</span><br><span class="line">name&#x3D;&quot;VBird&#39;s name&quot;  OK</span><br><span class="line">name&#x3D;VBird\&#39;s\ name  OK  采用反斜线（\）转义特殊字符，如单引号和空格键</span><br><span class="line"></span><br><span class="line">例三：在PATH变量中“累加”:&#x2F;home&#x2F;dmtsai&#x2F;bin目录</span><br><span class="line">PATH&#x3D;$PATH:&#x2F;home&#x2F;dmtsai&#x2F;bin  OK</span><br><span class="line">PATH&#x3D;&quot;$PATH&quot;:&#x2F;home&#x2F;dmtsai&#x2F;bin  OK</span><br><span class="line"></span><br><span class="line">例四：要将name的内容多出“yes”</span><br><span class="line">name&#x3D;$nameyes  NOT OK name的内容成了$nameyes这个变量</span><br><span class="line">正确的写法：</span><br><span class="line">name&#x3D;&quot;$name&quot;yes</span><br><span class="line">name&#x3D;$&#123;name&#125;yes</span><br><span class="line"></span><br><span class="line">例五：如何让刚刚设置的name&#x3D;VBird可以用在下一个Shell程序中</span><br><span class="line">name&#x3D;VBird</span><br><span class="line">bash         进入到子程序</span><br><span class="line">echo $name   并没有刚设置的内容</span><br><span class="line">exit         离开刚才设置的子程序</span><br><span class="line">export name  </span><br><span class="line">bash         进入到子程序</span><br><span class="line">echo $name   出现设置的值了</span><br><span class="line">exit         离开刚刚的子程序</span><br><span class="line"></span><br><span class="line">“子程序”：就是说在当前这个Shell的情况下，去启用另一个新的Shell，那个新的Shell就是子程序。</span><br><span class="line">一般状态下，父程序的自定义变量是无法在子程序内使用的。但是通过export将变量变成环境变量后，就能够在子程序下应用了。</span><br><span class="line"></span><br><span class="line">例六：取消刚刚设置的name这个变量的内容</span><br><span class="line">unset name</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="3-环境变量的功能"><a href="#3-环境变量的功能" class="headerlink" title="3.环境变量的功能"></a>3.环境变量的功能</h3><ul>
<li><p>环境变量可以帮助我们实现很多功能，包括家目录的修改、提示符显示、执行文件搜索的路径，等等。</p>
</li>
<li><p>一些环境变量的说明</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例一：列出当前Shell环境下所有环境变量及内容</span><br><span class="line">env   </span><br></pre></td></tr></table></figure>
<p>  <img src="http://img.blog.csdn.net/20180309121440996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">        </p>
<ul>
<li><p>环境变量LANG表示主语言环境，如我们要使用utf-8，可以LANG=utf-8</p>
</li>
<li><p>set命令：在bash环境下，其实还有一些很重要的变量，这些变量是在“shell环境下有效”，如果是在“子程序”中，这些变量值就会不同了。用set命令除了会将环境变量列出来之外，其他的自定义变量，以及所有的变量，都会列出来。</p>
</li>
<li><p>一般来说，不论是否为环境变量，只要与当前Shell的操作接口有关的变量，通常都会被设置为大写字母。<br>set<br><img src="http://img.blog.csdn.net/20180309131240482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">    </p>
</li>
<li><p>$(关于本地shell的PID)：这个变量表示“当前这个shell的进程号”。要想知道shell的PID（process ID），使用echo $$即可。</p>
</li>
<li><p>？（上一个执行命令的回传码）：    当我们执行某些命令时，这些命令都会回传一个执行后的代码。一般来说，执行成功，则回传一个0值，如果执行过程错误，则返回错误代码（一个非零值）。<br><img src="http://img.blog.csdn.net/20180309132124516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">    </p>
</li>
</ul>
</li>
<li><p>自定义变量转成环境变量：export<br>自定义变量与环境变量区别：主要在于是否可以被子程序所引用。<br>取得一个bash后，即得到了一个子程序，若再执行一次bash，将进入“子程序”。由于您已经进入该子程序，所有在父程序中自定义的变量将不存在，存在于子程序的，仅有“环境变量”。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export 变量</span><br><span class="line">将自定义的变量转换成环境变量</span><br><span class="line"></span><br><span class="line">export 后面没有跟变量，会把所有环境变量显示出来</span><br></pre></td></tr></table></figure>
<h3 id="4-其他一些变量知识"><a href="#4-其他一些变量知识" class="headerlink" title="4.其他一些变量知识"></a>4.其他一些变量知识</h3></li>
<li><p>语系文件的变量（locale）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br><span class="line">会显示出linux支持的语系</span><br></pre></td></tr></table></figure></li>
<li><p>变量的有效范围</p>
<ul>
<li>启动一个shell时，操作系统分配一块内存给shell使用，这个区域的变量可以让子程序访问；</li>
<li>利用export功能，可以让变量内容写到上述内存中（环境变量）；</li>
<li>当加载另一个shell时（即启动子程序，离开原来的父程序），子shell可以将父shell的环境变量所在的内存导入自己的环境变量区块中。</li>
</ul>
</li>
<li><p>变量键盘读取、数组与声明：read、array、declare</p>
<ul>
<li>read(读取来自键盘输入的变量)</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read [-pt] variable</span><br><span class="line">参数：</span><br><span class="line">-p：后面可以接提示符</span><br><span class="line">-t：后面可以接等待的“秒数”。</span><br></pre></td></tr></table></figure></code></pre>
<p><img src="http://img.blog.csdn.net/20180309135533590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code>![这里写图片描述](http://img.blog.csdn.net/20180309135935646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- declare/typeset（声明变量的属性）
如果declare后面没有任何参数，那么会将所有的变量名与内容都调出来，就像使用set一样。


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">declare [-aixr] variable</span><br><span class="line">参数：</span><br><span class="line">-a：将后面的variable定义为数组（array）</span><br><span class="line">-i：将后面的variable定义为整数数字（integer）</span><br><span class="line">-x：用法与export一样，将后面的variable变成环境变量</span><br><span class="line">-r：将一个variable变量设置成只读（readonly）该变量不可更改内容，也不能取消设置(unset)</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">sum&#x3D;100+300+500</span><br><span class="line">echo $sum  显示结果为100+300+500，因为这是文字类型的变量属性，不会求和</span><br><span class="line">declare -i sum&#x3D;100+300+500</span><br><span class="line">echo $sum  显示结果为900</span><br></pre></td></tr></table></figure>

- 数组属性array的说明


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var[index]&#x3D;content</span><br><span class="line">有一个数组名为var，index为数字角标，这个数组的内容为var[1]&#x3D;小明，var[2]&#x3D;大明，...</span><br><span class="line"></span><br><span class="line">读取数组，以$&#123;数组&#125;的方式来读取。</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>与文件系统及程序的限制关系：ulimit<br>假如有10个人同时登陆了一台Linux主机，这10个人同时打开了100个文件，每个文件的大小约10MB，Linux的内存需要10<em>100</em>10=10000MB，这样显然会造成系统死机。为了预防这种情况的发生，我们可以通过ulimit限制可打开的文件数量、可以使用的CPU情况、可以使用的内存总量。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ulimit [-SHacdflmnpstuv] [配额]</span><br><span class="line">参数：</span><br><span class="line">-H：hard limit，严格设置，必定不能超过设置的值</span><br><span class="line">-S：soft limit，警告设置，可以超过这个设置值，但会有警告，</span><br><span class="line">-a：列出所有的限制额度</span><br><span class="line">-f：此shell可以建立的最大文件容量，单位为KB</span><br><span class="line">其他参数用到时再查</span><br></pre></td></tr></table></figure></li>
<li><p>附加的变量设置功能</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">echo $HOME</span><br><span class="line">echo $&#123;HOME&#125; 这种方法中，我们可以修改变量。只要加上一些字符标志，后面再接着使用比较字符串，就能修改变量的内容了。</span><br><span class="line"></span><br><span class="line">例：以vbird&#x3D;&quot;&#x2F;home&#x2F;vbird&#x2F;testing&#x2F;testing.x.sh&quot;为例</span><br><span class="line">1. 在vbird变量中，从最前面开始比较，若开头为&#x2F;，则删除两个&#x2F;之间所有的数据，即&#x2F;*&#x2F;</span><br><span class="line">echo $&#123;vbird##&#x2F;*&#x2F;&#125; </span><br><span class="line">结果：testing.x.sh</span><br><span class="line">echo $&#123;vbird#&#x2F;*&#x2F;&#125;  </span><br><span class="line">结果：vbird&#x2F;testing&#x2F;testing.x.sh      ##表示去后面字符串最长的那一段；#表示取最小的那一段</span><br><span class="line"></span><br><span class="line">2.从后面开始删除，删除&#x2F;*?</span><br><span class="line">echo $&#123;vbird%%&#x2F;*&#x2F;&#125;</span><br><span class="line">结果：删除失败</span><br><span class="line">echo $&#123;vbird%%&#x2F;*&#125;</span><br><span class="line">结果：&#x2F;home&#x2F;vbird&#x2F;testing</span><br><span class="line">%%&#x2F;*表示删除最长的那一段，%&#x2F;*表示删除最短的一段</span><br><span class="line"></span><br><span class="line">3.将vbird变量中的testing替换为TEST</span><br><span class="line">echo $&#123;vbird&#x2F;testing&#x2F;TEST&#125;</span><br><span class="line">结果：&#x2F;home&#x2F;vbird&#x2F;TEST&#x2F;testing.x.sh</span><br><span class="line">echo $&#123;vbird&#x2F;&#x2F;testing&#x2F;TEST&#125;</span><br><span class="line">结果：&#x2F;home&#x2F;vbird&#x2F;TEST&#x2F;TEST.x.sh</span><br><span class="line">如果后面接&#x2F;，表示后面进行的是替换工作，而且仅替换第一个</span><br><span class="line">如果是&#x2F;&#x2F;，则表示替换全部字符串。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-命名别名与历史命令"><a href="#5-命名别名与历史命令" class="headerlink" title="5.命名别名与历史命令"></a>5.命名别名与历史命令</h3><ul>
<li><p>命令别名设置：alias、unalias</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	如果要查询隐藏文件，并且需要列出很长的信息，要一页一页地翻看，则需要执行“ls -al|more”</span><br><span class="line">命令，可以使用lm简化</span><br><span class="line">	alias lm&#x3D;&#39;ls -l | more&#39;</span><br><span class="line"></span><br><span class="line">	取消别名的设置</span><br><span class="line">	unalias lm</span><br></pre></td></tr></table></figure></li>
<li><p>历史命令：history</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">history [n]</span><br><span class="line">history [-c]</span><br><span class="line">history [-raw] histfiles</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">什么都不接，默认输出当前内存的所有历史记忆</span><br><span class="line">n：数字，表示列出最近的n行命令</span><br><span class="line">-c：将当前shell中所有的history内容全部清除</span><br><span class="line">-a：将当前新增的history命令加入到histfiles中，若没有加入histfiles，则默认写入~&#x2F;.bash_history</span><br><span class="line">-r：将histfiles的内容读取到当前shell的历史记忆</span><br><span class="line">-w：将当前的历史记忆内容写入histfiles中</span><br></pre></td></tr></table></figure>
<h3 id="6-管道命令（pipe）"><a href="#6-管道命令（pipe）" class="headerlink" title="6.管道命令（pipe）"></a>6.管道命令（pipe）</h3></li>
<li><p>bash 命令执行时，会出现数据。如果这组数据必须经过几道手续之后才能得到所想要的格式，如何设置？这可以通过管道命令完成，管道命令使用 | 这个分隔符。</p>
<p>  <img src="http://img.blog.csdn.net/20180309162036125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  管道命令”|”仅能处理通过前面一个命令传来的正确信息，也就是标准输出（STDOUT）的信息，对于标准错误，并没有直接处理的能力。下面介绍一下基本的管道命令。</p>
</li>
<li><p>选取命令：cut、grep</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这个命令可以将一段消息的某段“切”出来。处理的消息是以“行”为单位。</span><br><span class="line">cut -d &#39;分隔符&#39; -f fields</span><br><span class="line">参数：</span><br><span class="line">-d：后面接分隔符。与-f一起使用。</span><br><span class="line">-f：根据-d的分隔符将一段消息分为数段，用 -f 取出第几段的意思。</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">echo $PATH | cut -d &#39;:&#39; -f 5   将PATH变量用“:”切割成几段，取出第5段</span><br><span class="line">echo $PATH | cut -d &#39;:&#39; -f 3,5   将PATH变量用“:”切割成几段，取出第3段和第5段</span><br><span class="line"></span><br><span class="line">cut -c 字符范围</span><br><span class="line">参数：</span><br><span class="line">-c：以字符为单位（characters）为单位取出固定的字符范围</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">export | cut -c 12-  将export输出的消息，取得第12个字符以后的所有字符串</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cut是将一行消息中取出我们想要的部分，grep则分析一行消息，若其中有所需要的信息，就将该行取出。</span><br><span class="line">grep [-acinv] &#39;搜索字符串&#39; filename</span><br><span class="line">参数：</span><br><span class="line">-a：将二进制文件以文本的方式搜索数据</span><br><span class="line">-c：计算找到‘搜索字符串’的次数</span><br><span class="line">-i：忽略大小写的不同，所有大小写视为相同</span><br><span class="line">-n：顺便输出行号</span><br><span class="line">-v：反向选择，即显示出没有 &#39;搜索字符串&#39; 内容的那一行</span><br><span class="line"></span><br><span class="line">last | grep  &#39;root&#39;   将last中出现root的一行取出来</span><br><span class="line">last | grep -v &#39;root&#39;   只要没有root的就取出</span><br><span class="line">last | grep  &#39;root&#39; | cut -d &#39; &#39; -f 1   在last的输出消息中，只要有root就取出，并且仅取出第一栏</span><br></pre></td></tr></table></figure></li>
<li><p>其他命令（命令较多，就不做具体介绍了）</p>
<ul>
<li>排序命令：sort、wc、uniq</li>
<li>双向重导向：tee</li>
<li>字符转换命令：tr,col,join,paste,expand</li>
<li>拆分命令：split</li>
</ul>
</li>
</ul>
<h1 id="二、正则表达式（请参考鸟哥的Linux私房菜）"><a href="#二、正则表达式（请参考鸟哥的Linux私房菜）" class="headerlink" title="二、正则表达式（请参考鸟哥的Linux私房菜）"></a>二、正则表达式（请参考鸟哥的Linux私房菜）</h1><h1 id="三、Shell脚本"><a href="#三、Shell脚本" class="headerlink" title="三、Shell脚本"></a>三、Shell脚本</h1><h3 id="1-shell脚本基本介绍"><a href="#1-shell脚本基本介绍" class="headerlink" title="1.shell脚本基本介绍"></a>1.shell脚本基本介绍</h3><ul>
<li><p>什么是shell脚本？<br>  shell脚本是利用shell功能所编写的“程序（program）”，这个程序使用纯文本文件，将一些shell的语法与命令写在里面，与正则表达式、管道命令与数据流重导向一起实现我们的目的。</p>
</li>
<li><p>为什么学习shell脚本？</p>
<ul>
<li>自动化管理的重要依据</li>
<li>追踪与管理系统的重要工作</li>
<li>简单的入侵检测功能</li>
<li>连续命令单一化</li>
<li>简单的数据处理</li>
<li>跨平台支持与缩短学习历程<h3 id="2-第一个脚本的编写与执行"><a href="#2-第一个脚本的编写与执行" class="headerlink" title="2.第一个脚本的编写与执行"></a>2.第一个脚本的编写与执行</h3></li>
</ul>
</li>
<li><p>shell脚本其实就是纯文本文件（ASCII），我们可以编辑这个文件，然后让这个文件帮我们一次执行多个命令。编写shell脚本时需要注意的事项：</p>
<ul>
<li>命令与参数间的多个空白会被忽略掉。    </li>
<li>如果读到一个ENTER符，就开始执行该命令。</li>
<li>如果一行内容太多，则可以使用[Enter]来扩展至下一行。</li>
<li>此外，#可作为注释。任何加在#后面的内容，将会被视为注释文字而被忽略。</li>
</ul>
</li>
<li><p>假设我们编写好的文件名是shell.sh，如何执行该文件？</p>
<ul>
<li>将shell.sh加上可读与执行（rx）权限，然后就能用./shell.sh来执行了。</li>
<li>或者使用sh shell.sh的方式来直接执行即可。</li>
</ul>
</li>
<li><p>编写第一个脚本</p>
<p>  <img src="http://img.blog.csdn.net/20180310144632459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li><p>1.!#bin/bash在声明这个脚本使用的shell名称：因为使用的是bash，所有必须要用“!#bin/bash”来声明这个文件内的语法使用bash的语法。当执行这个程序时，它就能加载bash的相关环境设置文件，并且执行bash来使下面的命令执行。这一行很重要，因为如果没有的话系统很可能无法判断要使用声明shell来执行。</p>
</li>
<li><p>2.#后面的是注释</p>
</li>
<li><p>3.主要环境变量的声明：建议将重要的环境变量设置好。PATH变量比较重要，设置好PATH，可让程序在进行时，直接执行命令，而不必写绝对路径。</p>
</li>
<li><p>4.主要程序部分：将主要的程序写好。</p>
</li>
<li><p>5.告知执行结果：可以使用exit命令让程序中断，并给系统回传一个数值0。</p>
<p>执行结果：<br><img src="http://img.blog.csdn.net/20180310151947626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-简单的Shell脚本练习"><a href="#3-简单的Shell脚本练习" class="headerlink" title="3.简单的Shell脚本练习"></a>3.简单的Shell脚本练习</h3><ul>
<li>变量内容由用户决定</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编写一个脚本，让用户输入名字，然后在屏幕上打印用户名字</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Program: this is a practice</span><br><span class="line">PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:~&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input your name:&quot; name</span><br><span class="line">echo -e &quot;your name is : $name&quot;</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>利用date建立文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Program: this is a practice</span><br><span class="line">PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:~&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">1.让用户输入文件名，并获取fileuser变量</span><br><span class="line">read -p &quot;Please input the filename what you want:&quot;fileuser</span><br><span class="line"></span><br><span class="line">2.为了避免用户随意按ENTER，使用变量功能分析是否设置了文件名？</span><br><span class="line">filename&#x3D;$&#123;fileuser:-&quot;filename&quot;&#125;</span><br><span class="line"></span><br><span class="line">3.开始使用date命令来获取所需要的文件名</span><br><span class="line">date&#x3D;&#96;date --date&#x3D;&#39;2 days ago&#39; +%Y%m%d&#39;</span><br><span class="line">file&#x3D;&quot;$filename&quot;&quot;$date&quot;</span><br><span class="line"></span><br><span class="line">4.建立文件名</span><br><span class="line">touch $file</span><br></pre></td></tr></table></figure></li>
<li><p>数值运算的方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Program: this is a practice</span><br><span class="line">PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:~&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">read -p &quot;first number:&quot; firstnum</span><br><span class="line">read -p &quot;second number:&quot; secondnum</span><br><span class="line"></span><br><span class="line">total&#x3D;$(($firstnum*$secondnum))</span><br><span class="line">echo -e &quot;the total is: $total&quot;</span><br></pre></td></tr></table></figure>
<p>  数学运算可以使用“declare -i total=$firstNum*$secondNum”，但建议使用上面的方式进行。<br>  var=$((运算内容))，不仅容易记忆，而且更加方便。</p>
</li>
</ul>
<h3 id="4-善用判断条件"><a href="#4-善用判断条件" class="headerlink" title="4.善用判断条件"></a>4.善用判断条件</h3><ul>
<li><p>使用test命令的测试功能</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test -e &#x2F;dmtsai   检查&#x2F;dmtsai是否存在</span><br><span class="line">执行结果不会显示任何消息，但最后可通过$?或&amp;&amp;及||来展现整个结果</span><br><span class="line"></span><br><span class="line">test -e &#x2F;dmtsai &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;  最后结果可以告诉我们是“exist”还是“Not exist”。</span><br></pre></td></tr></table></figure></li>
<li><p>测试标志</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.某个文件名的“类型”检测，如test -e filename</span><br><span class="line">-e：该“文件名” 是否存在</span><br><span class="line">-f：该“文件名” 是否为文件（file）</span><br><span class="line">-d：该“文件名” 是否为目录（directory）</span><br><span class="line"></span><br><span class="line">2.文件的权限检测，如test -r filename</span><br><span class="line">-r：检测该文件名是否具有“可读”属性</span><br><span class="line">-w：检测该文件名是否具有“可写”属性</span><br><span class="line">-x：检测该文件名是否具有“可执行”属性</span><br><span class="line"></span><br><span class="line">3.多重条件判断，如test -r filename -a -x filename</span><br><span class="line">-a：（and）两个条件同时成立</span><br><span class="line">-o：（or）两个条件任何一个成立</span><br><span class="line"></span><br><span class="line">还有比较两个文件、两个整数之间的判断、判断字符串的数据等，用到时再查询 </span><br></pre></td></tr></table></figure></li>
<li><p>使用判断符号[ ]<br>  除了使用test外，还可以使用判断符号[]来进行数据的判断。</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">判断$HOME变量是否为空</span><br><span class="line">[ -z &quot;$HOME&quot; ]    需要注意的是：上述每个组件中间，都要用空格符分隔</span><br><span class="line"></span><br><span class="line">判断两个字符串$HOME和$MAIL是否相同</span><br><span class="line">[ &quot;$HOME&quot; &#x3D;&#x3D; &quot;$MAIL&quot; ]</span><br><span class="line"></span><br><span class="line">中括号内的变量，最好使用双引号来设置</span><br><span class="line">name&#x3D;&quot;VBird Tsai&quot;</span><br><span class="line">[ $name &#x3D;&#x3D; &quot;VBird&quot; ]  </span><br><span class="line">结果会报错，因为$name没有用双引号括起来，那么上面的判断条件会变成：</span><br><span class="line">[ VBird Tsai &#x3D;&#x3D; &quot;VBird&quot; ] 而不是我们要的  [ &quot;VBird Tsai&quot; &#x3D;&#x3D; &quot;VBird&quot; ] </span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>Shell脚本的默认变量($0,$1…)</li>
</ul>
<h3 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5.条件判断"></a>5.条件判断</h3><ul>
<li><p>if  then</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">if [ 条件判断表达式 ]; then</span><br><span class="line">	当条件表达式成立时，可以执行的命令</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">当有多个条件需要判断时，除了将多个条件写入一个中括号，</span><br><span class="line">还可以使用多个中括号来隔开，而括号与括号之间，则以&amp;&amp;或||来隔开，他们的含义是：</span><br><span class="line">&amp;&amp;表示AND</span><br><span class="line">||表示or</span><br><span class="line"></span><br><span class="line">if [ 条件判断表达式 ]; then</span><br><span class="line">	当条件表达式成立时，可以执行的命令</span><br><span class="line">else</span><br><span class="line">	当条件表达式不成立时，可以执行的命令</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ 条件判断表达式一]; then</span><br><span class="line">	当条件表达式成立时，可以执行的命令</span><br><span class="line">elif [ 条件判断表达式二]; then</span><br><span class="line">	当条件表达式二成立时，可以执行的命令</span><br><span class="line">else</span><br><span class="line">	当条件表达式一与二都不成立时，可以执行的命令</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p>netstat<br>  该命令可以查询当前主机是否有打开的网络服务端口（service ports）<br>  部分网络服务<br>  <img src="http://img.blog.csdn.net/20180310210533602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  常见的端口与相关网络服务的关系是：</p>
<ul>
<li>80：WWW</li>
<li>22：ssh</li>
<li>21：ftp</li>
<li>25：mail</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Program: Using netstat and grep to detect WWW,SSH,FTP and Mail services</span><br><span class="line">PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:~&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">testing&#x3D;&#96;netstat -tuln | grep &quot;:80 &quot;&#96;</span><br><span class="line">if [ &quot;$testing&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">	echo &quot;WWW is running in your system.&quot;</span><br><span class="line">fi</span><br><span class="line">testing&#x3D;&#96;netstat -tuln | grep &quot;:22 &quot;&#96;</span><br><span class="line">if [ &quot;$testing&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">	echo &quot;SSH is running in your system.&quot;</span><br><span class="line">fi</span><br><span class="line">testing&#x3D;&#96;netstat -tuln | grep &quot;:21 &quot;&#96;</span><br><span class="line">if [ &quot;$testing&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">	echo &quot;FTP is running in your system.&quot;</span><br><span class="line">fi</span><br><span class="line">testing&#x3D;&#96;netstat -tuln | grep &quot;:25 &quot;&#96;</span><br><span class="line">if [ &quot;$testing&quot; !&#x3D; &quot;&quot; ]; then</span><br><span class="line">	echo &quot;Mail is running in your system.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>使用case  esac判断</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名称 in </span><br><span class="line">	&quot;第一个变量内容&quot;)</span><br><span class="line">	程序段</span><br><span class="line">	;;</span><br><span class="line">	&quot;第二个变量内容&quot;)</span><br><span class="line">	程序段</span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">		不包含第一个变量内容与第二个变量内容的其他程序执行段</span><br><span class="line">		exit 1</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Program: Show &quot;Hello&quot; from $1 ... by using case ...esac</span><br><span class="line">PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:~&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">	&quot;hello&quot;)</span><br><span class="line">		echo &quot;Hello,how are you?&quot;</span><br><span class="line">		;;</span><br><span class="line">	&quot;&quot;)</span><br><span class="line">		echo &quot;You MUST input parameters,ex&gt;$0 some word&quot;</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Usage $0 &#123;hello&#125;</span><br><span class="line">		;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">假设上面的脚本文件名字为sh08.sh</span><br><span class="line">如果输入sh sh08.sh test执行，那么屏幕上就会出现“Usage sh08.sh&#123;hello&#125;”</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="6-循环"><a href="#6-循环" class="headerlink" title="6.循环"></a>6.循环</h3><ul>
<li><p>while do done、until do done</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while [ condition ] </span><br><span class="line">do</span><br><span class="line">	程序段落</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">until [ condition ] </span><br><span class="line">do</span><br><span class="line">	程序段落</span><br><span class="line">done</span><br><span class="line">这种方式与while相反，它说的是当condition条件成立时，就终止循环，否则就持续执行循环的程序段。</span><br></pre></td></tr></table></figure></li>
<li><p>for…do…done<br>相对于while、until的循环方式是必须要符合某个条件的状态，for这种语法是已经知道要进行几次循环的状态。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(( 初始值; 限制值; 执行步长))</span><br><span class="line">do</span><br><span class="line">	程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Linux/Linux学习笔记（基础）/">Linux学习笔记（基础）</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h2 id="说明：本文主要参考《鸟哥的Linux私房菜》，主要目的是为了编写自动化部署、管理的Shell脚本，有些章节没有写，想进一步了解Linux知识的请参考《鸟哥的Linux私房菜》"><a href="#说明：本文主要参考《鸟哥的Linux私房菜》，主要目的是为了编写自动化部署、管理的Shell脚本，有些章节没有写，想进一步了解Linux知识的请参考《鸟哥的Linux私房菜》" class="headerlink" title="说明：本文主要参考《鸟哥的Linux私房菜》，主要目的是为了编写自动化部署、管理的Shell脚本，有些章节没有写，想进一步了解Linux知识的请参考《鸟哥的Linux私房菜》"></a>说明：本文主要参考《鸟哥的Linux私房菜》，主要目的是为了编写自动化部署、管理的Shell脚本，有些章节没有写，想进一步了解Linux知识的请参考《鸟哥的Linux私房菜》</h2><h1 id="一、启动、关机等基础操作"><a href="#一、启动、关机等基础操作" class="headerlink" title="一、启动、关机等基础操作"></a>一、启动、关机等基础操作</h1><ul>
<li>date  显示日期命令<ul>
<li>date +%Y/%m/%d</li>
<li>date +%H %M</li>
</ul>
</li>
<li>cal(calender)  显示日历<ul>
<li>显示当前月份的日历 cal</li>
<li>显示2008年的日历  cal 2008<h3 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h3></li>
</ul>
</li>
<li>观察系统的使用状态（用来判断是否可以关机）<ul>
<li>如果要查看当前有谁在线，可以发出who命令</li>
<li>如果要查看网络联机状态，可以使用netstat -a命令</li>
</ul>
</li>
<li>通知在线用户关机时间：关机前，总要给在线用户一些时间来结束其工作，可以使用shutdown命令实现此功能。<ul>
<li>使用正确的关机命令：shutdown和reboot<h3 id="数据同步写入磁盘"><a href="#数据同步写入磁盘" class="headerlink" title="数据同步写入磁盘"></a>数据同步写入磁盘</h3></li>
</ul>
</li>
<li>linux系统中，为了加快数据的读取速度，某些数据不会直接写入硬盘，而是暂存在内存中。万一关机，不正常断点等情况下，数据尚未写入磁盘，就会丢失，此时需要命令sync（只有root可以执行该命令）。</li>
<li>当然在shutdown/reboot命令均已在关机前进行了sync工具的调用。</li>
<li>重新启动reboot<br>reboot命令与shutdown -r now几乎相同。</li>
</ul>
<h2 id="二、-linux的文件属性与目录配置"><a href="#二、-linux的文件属性与目录配置" class="headerlink" title="二、 linux的文件属性与目录配置"></a>二、 linux的文件属性与目录配置</h2><h3 id="1-用户与用户组"><a href="#1-用户与用户组" class="headerlink" title="1.用户与用户组"></a>1.用户与用户组</h3><ul>
<li><p>（linux中任何一个文件都具有“用户、用户组和其他人”3个权限）</p>
</li>
<li><p>文件拥有者：linux是多用户、多任务的系统，不同的人可以同时使用主机，考虑到每一个用户的隐私和喜好的工作环境，文件拥有者就可以派上用处了。</p>
</li>
<li><p>用户组：用户组主要基于团队开发。可以进行简单的文件权限设置，就能限制其他用户组成员不能查看该文件。还可以让自己用户组的成员修改自己创建的文件，同时，如果有自己的私有文件，可以设置通用户组其他成员不能看到。用户组的概念使这些实现起来很方便。</p>
</li>
<li><p>其他人：不属于自己用户组的成员</p>
<h3 id="2-文件属性"><a href="#2-文件属性" class="headerlink" title="2.文件属性"></a>2.文件属性</h3></li>
<li><p>登录linux后，输入ls -al(ls即list，-al表示列出所有的文件，包括隐藏文件，就是文件名前第一个字符为 . 的文件)<br>  <img src="http://img.blog.csdn.net/20180227195311755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
</li>
<li><p>从1到7依次为文件属性、连接数、文件拥有着、文件所属用户组、文件大小、文件最新修改时间、文件名。</p>
</li>
<li><p>文件属性<br>  <img src="http://img.blog.csdn.net/20180228195057594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li><p>文件类型包括</p>
<ul>
<li>[d] ：目录</li>
<li>[ - ] ：文件</li>
<li>[ l ] ：连接文件</li>
<li>[b]：设备文件中可供存储的接口设备</li>
<li>[c] ： 设备文件中的串行端口设备，例如键盘、鼠标。</li>
</ul>
</li>
<li><p>需要注意的是x属性与目录关系很重要，如果某个目录下不能执行任何命令的话，则无法进入该目录。例：<br>若文件名为一个目录</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dwxr------  3  root  root  4096  Jun 08:35  .ssh</span><br><span class="line">root用户可以进入该目录，其他用户无法进入</span><br><span class="line">dwxr--r---  3  root  root  4096  Jun 08:35  .ssh</span><br><span class="line">虽然用户组有r权限，但因为没有x权限，无法进入该目录</span><br></pre></td></tr></table></figure>
- linux中，文件能否执行，是通过是否具有x属性来决定的，所有与文件名及扩展名没有绝对关系。</code></pre>
<h3 id="3-更改文件权限"><a href="#3-更改文件权限" class="headerlink" title="3.更改文件权限"></a>3.更改文件权限</h3><ul>
<li><p>更改所属用户组（change group）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 群组名称 文件目录</span><br><span class="line">-R表示进行递归(recursive)的持续更改，即连同子目录下的所有文件、目录都更改为这个用户组</span><br></pre></td></tr></table></figure></li>
<li><p>更改文件拥有者(change owner)</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 账号名称:文件或目录</span><br><span class="line">chown bin install.log</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>更改文件拥有者的常见例子是，将一个文件的内容复制到另一个文件，并把另一个文件给别人。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目的文件</span><br><span class="line">例，将.aa文件复制给.bb,并给xiaoming这个人（用户），可以这样做</span><br><span class="line">cp .aa .bb</span><br><span class="line">chown xiaoming .bb</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>更改9个属性chmod<ul>
<li>第一种方法</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">各属性和数字的对照表</span><br><span class="line">r:4</span><br><span class="line">w:2</span><br><span class="line">x:1</span><br><span class="line">chmod [-R] xyz 文件或目录</span><br><span class="line">xyz为rwx属性数值的和</span><br><span class="line">例：chmod 777 .aa</span><br><span class="line">第一个7&#x3D;4+2+1，对应的属性未rwx</span><br><span class="line">第二个7和第三个同理</span><br></pre></td></tr></table></figure>
- 第二种方法


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用u,g,o表示user,group,others三组属性;a表示all,即全部三组</span><br><span class="line">语法： </span><br></pre></td></tr></table></figure>
![这里写图片描述](http://img.blog.csdn.net/2018030119205763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例：chmod u&#x3D;rwx,go&#x3D;rx .aa</span><br><span class="line">其中go表示g和o</span><br><span class="line">要是想增加某一属性，而不改变其他属性，可以如下操作</span><br><span class="line">chmod a+w .aa</span><br><span class="line">要是想除去某一属性，而不改变其他属性，可以如下操作</span><br><span class="line">chmod a-x .aa</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="4-目录属性的意义"><a href="#4-目录属性的意义" class="headerlink" title="4.目录属性的意义"></a>4.目录属性的意义</h3><ul>
<li>以上介绍的都是针对一般文件的属性，对于目录r,w,x是什么含义呢？<ul>
<li>r：表示具有读取目录结构清单的权限</li>
<li>w：它标识拥有更改该目录结构清单的权限<ul>
<li>建立新的文件与目录</li>
<li>删除已存在的文件与目录</li>
<li>将已存在的文件或目录重命名</li>
<li>移动该目录内文件、目录的位置</li>
<li>x：x与能否进入该目录有关<h3 id="5-linux文件类型与扩展名"><a href="#5-linux文件类型与扩展名" class="headerlink" title="5.linux文件类型与扩展名"></a>5.linux文件类型与扩展名</h3></li>
</ul>
</li>
</ul>
</li>
<li>文件种类<ul>
<li>[ - ] 普通文件。普通文件根据文件的内容又可以分为</li>
<li>纯文本文件（ASCII）：其中的内容我们可以直接读取到的数据，如数字，字母等。<ul>
<li>二进制文件(binary)：Linux中可执行文件（脚本、文本方式的批处理文件不算）就是这种格式。</li>
<li>数据格式的文件(data)：有些程序在运行过程中，会读取某些特定格式的文件，那些特定格式的文件可以称为数据文件。</li>
</ul>
</li>
<li>[d] 目录(directory)</li>
<li>[ l ] 连接文件(link)：类似于Windows下面的快捷方式。</li>
<li>设备与设备文件：与系统外设及存储等相关的一些文件，通常都集中在/dev目录下。该文件可分为两种：<ul>
<li>[b]块(block)设备文件：就是存储数据以供系统访问的接口设备。简单而言就是硬盘。 </li>
<li>[c]字符(character)设备文件：即串行端口的接口设备，例如键盘、鼠标等。</li>
</ul>
</li>
<li>[s] 套接字(sockets)：这类文件通常用在网络数据连接。</li>
<li>[p] 管道(FIFO,pipe)：FIFO也是一种特殊的文件类型，其主要目的是，解决多个程序同时访问一个文件所造成的错误。</li>
</ul>
</li>
<li>linux文件扩展名<ul>
<li>Linux文件能否执行，与它的属性相关，与文件名一点关系都没有。只要有属性x，即表示这个文件可以执行。需要说明的是可以执行与执行成功是不一样的。x表示这个文件具有可执行能力，但不能不能执行成功，当然就要看该文件的内容了。例如，root目录下的install.log是一个纯文本文件，即使权限修改为-rwxrwxrwx，这个文件依然不能执行，因为它的内容根本就没有可执行的数据。</li>
<li>通常我们还是希望通过扩展名来表示该文件的类型，所以会以适当的扩展名来表示该文件的类型。下面是常用的几种扩展名：<ul>
<li>*.sh：批处理文件，因为批处理文件使用shell写成，所以扩展名为.sh。</li>
<li><em>.tar、</em>.tar.gz、*.zip：经过打包的压缩文件。压缩软件分别为gunzip、tar等，根据不同的压缩软件而取其相关的扩展名。</li>
<li><em>.html、</em>.php：网页相关的文件<h3 id="6-linux目录配置"><a href="#6-linux目录配置" class="headerlink" title="6. linux目录配置"></a>6. linux目录配置</h3></li>
</ul>
</li>
</ul>
</li>
<li>Linux中所有的文件与目录都是由根目录(/)开始。它是所有目录与文件的源头。</li>
<li>进入目录的写法：</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;log（绝对路径）</span><br><span class="line">cd ..&#x2F;var&#x2F;log（相对路径）</span><br><span class="line"></span><br><span class="line">. : 表示当前目录，也可以使用.&#x2F;来表示</span><br><span class="line">..: 表示上一层目录，也可以用..&#x2F;来表示</span><br><span class="line">&#x2F; : 指的是根目录root</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>linux目录内容<br>  <img src="http://img.blog.csdn.net/20180303133051254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><h3 id="7-linux支持的文件系统"><a href="#7-linux支持的文件系统" class="headerlink" title="7. linux支持的文件系统"></a>7. linux支持的文件系统</h3></li>
<li>当前的大多数操作系统都是从硬盘中读取数据的，每个操作系统用的硬盘在x86架构上都一样，都是同样的硬盘。但是每种操作系统都有其独特的读取文件的方法，也就是说，每种操作系统对硬盘读取的方法不同，这就产生了不同的文件系统。</li>
<li>Linux正统的文件系统为ext2（Linux second extended file system，Linux第二代扩展文件系统），不过ext2缺乏日志管理系统。ext3文件系统多做了一个日志式数据的记录。要将数据写入硬盘时，ext2直接将数据写入，但ext3则会将“要开始写入”的信息写入日志纪录区，然后才开始写入数据，在写入数据后，又将“完成写入动作”的信息写入日志记录区。这样做的好处就是数据的完整性与恢复性得到保证。比如，早期的ext2文件系统遇到断电，就要检查文件的一致性，这种检查要将整个分区内的文件进行完整的比较，很慢。如果是ext3，只要通过检查“日志纪录区”就可以知道，断电时有哪些文件正在写入，只需要检查这些地方即可。</li>
</ul>
<h1 id="三、Linux文件和目录管理"><a href="#三、Linux文件和目录管理" class="headerlink" title="三、Linux文件和目录管理"></a>三、Linux文件和目录管理</h1><h3 id="1-目录与路径"><a href="#1-目录与路径" class="headerlink" title="1.目录与路径"></a>1.目录与路径</h3><ul>
<li>相对路径与绝对路径<ul>
<li>绝对路径：路径的写法“一定由根目录/写起”，如/usr/share/doc</li>
<li>相对路径：路径的写法“不是由/写起”，例如../man</li>
</ul>
</li>
<li>目录操作相关<ul>
<li>cd 切换目录<ul>
<li>pwd(Print Working Directory) 显示当前所在的目录<br>pwd [-p] 参数-p表示显示出实际路径，而非使用连接路径。</li>
<li>mkdir 建立新目录<br>mkdir[-mp] 参数-m设置文件的权限，直接设置，不要管默认权限；-p:帮你直接建立所需目录的递归</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir test 建立一个名为test的目录</span><br><span class="line">mkdir test1&#x2F;test2&#x2F;test3 建立失败，默认情况下，目录要一层一层的建立。</span><br><span class="line">加入-p参数可以按照顺序依次建立目录</span><br><span class="line">mkdir -p test1&#x2F;test2&#x2F;test3 建立成功</span><br><span class="line">mkdir -m 711 test4 通过-m 711给新目录赋予drwx--x--x属性。</span><br></pre></td></tr></table></figure>

- rmdir删除“空”目录


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名  参数-p：与上层“空”目录也一起删除</span><br><span class="line">rmdir test  需要注意的是如果test目录不是空目录，则会删除失败。</span><br><span class="line">rmdir test1&#x2F;test2&#x2F;test3 只能删除test3</span><br><span class="line">rmdir -p test1&#x2F;test2&#x2F;test3 就能将这一串“空”目录删除</span><br><span class="line">被删的目录中，不能有其他目录或文件。这也是空目录的含义</span><br><span class="line">上面采用-p参数删除test1&#x2F;test2&#x2F;test3时，会一层一层的删除，先删除test3后，如果test2成为了空目录，则也删除，依次类推。</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li>执行文件路径的变量$PATH <ul>
<li>介绍了绝对路径、相对路径与命令的执行方式之后，你可能会注意到为什么可以在任何地方执行/bin/ls命令呢？这是因为有环境变量PATH的帮助。在执行命令时，系统会按照PATH的设置，去到每个PATH定义的路径下搜索执行文件，先搜索到的命令先执行。</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH    echo命令表示“显示”的意思,PATH前面的$，表示后面接的是变量。	</span><br></pre></td></tr></table></figure>

- 如果要执行的命令的目录不在环境变量PATH中，该如何解决呢？</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、直接将命令所在的的路径加入到PATH中</span><br><span class="line">PATH&#x3D;&quot;$PATH&quot;:&#x2F;root  首先$PATH拿到环境变量原有的目录，如&#x2F;usr&#x2F;lib64&#x2F;qt-3.3&#x2F;bin:&#x2F;root&#x2F;perl5&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin</span><br><span class="line">然后&quot;&quot;将其括起来表示这些目录的字符串，后面再接:&#x2F;root表示将该目录添加到环境变量中，这样系统就会去&#x2F;root目录下搜索相关的执行命令。</span><br><span class="line">二、使用完整的文件名来发出命令，即直接使用相对或绝对路径来执行</span><br><span class="line">假设我们把ls命令从&#x2F;bin目录移到了&#x2F;root目录</span><br><span class="line">&#x2F;root&#x2F;ls  </span><br><span class="line">.&#x2F;ls</span><br></pre></td></tr></table></figure>

<h3 id="2-管理文件与目录"><a href="#2-管理文件与目录" class="headerlink" title="2.管理文件与目录"></a>2.管理文件与目录</h3><ul>
<li>查看文件和目录：ls</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ls [-aAdfFhilRs] 目录名</span><br><span class="line">ls [--color&#x3D;&#123;none,auto,always&#125;]  目录名</span><br><span class="line">ls [--full-time] 目录名</span><br><span class="line">介绍几个参数：</span><br><span class="line">-d：列出目录本身，而不是列出目录内的文件数据</span><br><span class="line">-R：与子目录内容一起列起来</span><br><span class="line">-S：按文件大小排序</span><br><span class="line">-t：按时间排序</span><br><span class="line">--color&#x3D;never：不要按照文件属性的不同用不同的颜色显示</span><br><span class="line">--color&#x3D;always：显示颜色</span><br><span class="line">--color&#x3D;auto：让系统自行按照设置来判断是否使用颜色</span><br><span class="line">--full-time：以完整的时间模式输出</span><br><span class="line">--time&#x3D;&#123;atime,ctime&#125;：输出访问时间（atime）或改变权限属性的时间(ctime)，而非内容更改时间(modification time)</span><br></pre></td></tr></table></figure>
<ul>
<li>复制、移动和删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] 源文件 目标文件</span><br><span class="line">介绍几个常用的参数：</span><br><span class="line">-d：若源文件为连接文件的属性(link file)，则复制连接文件属性而非文件本身</span><br><span class="line">-p：与文件的属性一起复制，而非使用默认属性</span><br><span class="line">-r：递归持续复制，用于目录的复制操作</span><br><span class="line"></span><br><span class="line">rm [-fir] 文件或目录</span><br><span class="line">参数：</span><br><span class="line">-f：强制删除</span><br><span class="line">-i：交互模式，在删除前会询问用户是否操作</span><br><span class="line">-r：递归删除。常用在目录的删除。</span><br></pre></td></tr></table></figure>
<ul>
<li>mv(移动文件与目录，或重命名)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [-fiv] source destination</span><br></pre></td></tr></table></figure>
<ul>
<li>获取路径的文件名与目录名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取文件名</span><br><span class="line">basename &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br><span class="line">结果：network</span><br><span class="line">获取目录名</span><br><span class="line">dirname &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br><span class="line">结果：&#x2F;etc&#x2F;sysconfig</span><br></pre></td></tr></table></figure>
<h3 id="3-查看文件内容"><a href="#3-查看文件内容" class="headerlink" title="3.查看文件内容"></a>3.查看文件内容</h3><ul>
<li><p>1.直接查看文件内容</p>
<ul>
<li><p>cat：由第一行开始显示文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat(concatenate,连续)</span><br><span class="line">cat [-AEntv]</span><br><span class="line">参数：-n 显示行号</span><br><span class="line">很少使用该命令，因为当文件内容行数超过40行以上时，根本来不及看。</span><br></pre></td></tr></table></figure>
</li>
<li><p>tac：从最后一行开始显示，可以看出tac与cat字母顺序相反</p>
<pre><code>  将最后一行到第一行反向显示在屏幕上</code></pre>
</li>
<li><p>nl：显示的时候，输出行号</p>
</li>
</ul>
</li>
<li><p>2.翻页查看</p>
<ul>
<li><p>more：一页一页地显示文件</p>
<pre><code>  一页一页查看文件内容
  more程序运行过程中，有几个按键可以使用：
  空格键：表示向下
  回车键：表示向下翻一行
  /：表示在这个显示的内容中，向下搜索&quot;字符串&quot;</code></pre>
</li>
<li><p>less：与more相似，但它可以向前翻页</p>
<pre><code>  less比more更灵活。使用more的时候，没有办法向前翻页，只能往后面看，
  但使用了less，就可以使用上下按键往前往后翻看文件，更容易查看文件内容</code></pre>
</li>
</ul>
</li>
<li><p>3.数据选取    </p>
<ul>
<li>head：只看前几行</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] 文件</span><br><span class="line">参数 -n 后面接数字表示显示几行的意思</span><br><span class="line">默认情况下显示10行</span><br></pre></td></tr></table></figure>

- tail：只看最后几行


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] 文件</span><br><span class="line">默认情况下显示10行</span><br><span class="line"></span><br><span class="line">显示~&#x2F;.bashrc的第10行到第20行</span><br><span class="line">head -n 20 ~&#x2F;.bashrc|tail -n 10</span><br></pre></td></tr></table></figure>
- od：以二进制方式读取文件内容

    前面的内容都是在查看纯文本文件（ASCII格式文件），想查看非文字文件可以用od读取。


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">od [-t TYPE] 文件</span><br><span class="line">-t 后面可以接各种类型TYPE的输出，如：</span><br><span class="line">a:使用默认的字符来输出</span><br><span class="line">c:使用ASCII字符输出</span><br><span class="line">d[size]:使用十进制（decimal）来输出数据，每个整数占用size字节</span><br><span class="line">f[size]:使用浮点数（floating）值来输出数据，每个整数占用size字节</span><br><span class="line">o[size]:使用八进制（octal）输出数据，每个整数占用size字节</span><br><span class="line">x[size]:使用十六进制（hexadecimal）输出数据，每个整数占用size字节</span><br></pre></td></tr></table></figure>
- 修改文件时间与创建新文件：touch
    - modification time(mtime,修改时间):当文件的内容数据更改时，就会更新这个时间。
    - status time(ctime,状态时间)：当该文件的状态更改时，就会更新这个时间。如更改了权限与属性。
    - access time(atime,访问时间):当读取文件内容时就会更新这个读取时间，如用cat命令查看一个文件时，就会更新atime。


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">文件时间很重要，因为如果误判文件时间，可能会造成某些程序无法运行。</span><br><span class="line">touch [-acdmt] 文件</span><br><span class="line">-a:仅修改atime</span><br><span class="line">-c:仅修改时间，而不是建立文件</span><br><span class="line">-d:后面可以接日期，也可以使用 --date&#x3D;&quot;日期或时间&quot;</span><br><span class="line">-m:仅修改mtime</span><br><span class="line">-t:后面可以接时间，格式为 [YYMMDDhhmm]</span><br><span class="line"></span><br><span class="line">默认状态下：如果touch后面接文件，</span><br><span class="line">若该文件不存在，则会主动建立一个新的空文件。</span><br><span class="line"></span><br><span class="line">将bashrc文件的日期调整为两天前</span><br><span class="line">touch -d &quot;2 days ago&quot; bashrc</span><br><span class="line"></span><br><span class="line">将bashrc文件的日期日期改为2005&#x2F;07&#x2F;15 2:02</span><br><span class="line">touch  -t 0507150202 barshrc</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="4-文件与目录的默认权限与隐藏权限"><a href="#4-文件与目录的默认权限与隐藏权限" class="headerlink" title="4.文件与目录的默认权限与隐藏权限"></a>4.文件与目录的默认权限与隐藏权限</h3><ul>
<li><p>文件默认权限：umask</p>
<ul>
<li><p>现在我们知道如何建立或者修改一个目录或文件的属性了，但是，当建立一个新的文件或目录时，它默认的属性是什么样的呢？通常，umask就是指定“当前用户在建立文件或目录时的属性默认值”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umask</span><br><span class="line">结果比如显示 0022 第一组是给特殊权限用的</span><br><span class="line">umask -S</span><br><span class="line">结果显示比如 u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</span><br></pre></td></tr></table></figure></li>
<li><p>在默认权限的属性上，目录与文件时不一样的。由于我们不希望文件具有可执行的权限，默认情况下，文件是没有可执行（x）权限的。因此：</p>
<ul>
<li>若用户建立的文件默认没有可执行（x）权限，即只有rw这两个权限，也就是最大为666分，默认属性为 -rw-rw-rw-。</li>
<li>若用户建立目录，则由于x与是否可以进入此目录有关，因此默认为所有权限均开放，即为777分，默认属性为 rwxrwxrwx 。</li>
</ul>
</li>
<li><p>umask指定的是“该默认值需要减掉的权限”。因为r、w、x分别是4、2、1,也就是说，当要去掉写权限时，就输入2，要去掉读权限时，就输入4，要去掉读与写权限时，就输入6，而要去掉执行与写的权限时，就输入3。上面umask为022，所以user没有被去掉属性，不过group与others的属性被去掉了2，所以用户：</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立文件时：(-rw-rw-rw-) - (-----w--w-) &#x3D;&#x3D;&gt; -rw-r--r--</span><br><span class="line">建立目录时：(drwxrwxrwx) - (d----w--w-) &#x3D;&#x3D;&gt; drwxr-xr-x</span><br></pre></td></tr></table></figure>
- 如何设置umask？直接在umask后面输入相关值，如002。需要注意的是，计算默认权限值时不要直接相减，而是要用AND与NOT计算。</code></pre>
<h1 id="四、vi和vim文字处理器"><a href="#四、vi和vim文字处理器" class="headerlink" title="四、vi和vim文字处理器"></a>四、vi和vim文字处理器</h1><h3 id="1-vi的使用"><a href="#1-vi的使用" class="headerlink" title="1.vi的使用"></a>1.vi的使用</h3><ul>
<li>vi是几乎任何一个类Unix机器都存在的文字处理器，它功能很齐全，但还有些可以改进的地方。vim可以看做是vi的高级软件，它对程序开发人员很好用，vim官网也说vim是一个“程序开发工具”而不是文字处理软件。vim中增加了很多附加功能，比如支持规范表示法的搜索框架、多文件编辑、块复制等。</li>
<li>vi共分为3中模式，分别是“一般模式”、“编辑模式”、“命令行命令模式”。<br><img src="http://img.blog.csdn.net/20180305190506572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
<li>简单执行范例<ul>
<li>使vi进入一般模式</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.text</span><br></pre></td></tr></table></figure>
如下图
    ![这里写图片描述](http://img.blog.csdn.net/20180305191150543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
如果test.txt不存在的话，会新建该文件。
- 按下i进入编辑模式，开始编辑文字

![这里写图片描述](http://img.blog.csdn.net/20180305191350764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
这时候可以输入任意字符。
- 按下[ESC]回到一般模式
- 在一般模式下按下  :wq  存储后离开vi（实际上按下 : 后，进入了命令行模式，再按wq存储文件并离开vi）。
- 如果文件权限不对，很可能无法写入。可以使用&quot;:wq!&quot; 强制写入，不过需要强调的是，这是在“你的权限可以改变”的情况下可行的。</code></pre>
<ul>
<li>介绍几种常见的命令行命令<ul>
<li>一般模式：移动光标的方法</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">右方向键（-&gt;）：光标向右移动一个字符</span><br><span class="line">多次移动，如向下移动30行：可以使用输入30+向下方向键的组合键形式完成</span><br><span class="line">[Page Down]：向下移动一页</span><br><span class="line">[Page Up]：向上移动一页</span><br><span class="line"></span><br><span class="line">0：数字0表示移动到这一行的最前面字符处</span><br><span class="line">$：移动到这一行的最后面的字符处</span><br><span class="line">G：移动到这个文件的最后一行</span><br></pre></td></tr></table></figure>
- 一般模式：搜索和替换


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;word：从光标位置开始，向下寻找一个名为word的字符串。</span><br><span class="line">?word：从光标位置开始，向上寻找一个名为word的字符串。</span><br><span class="line">n：表示重复前一个搜索动作。比如前一个动作是&#x2F;a，则按下n后，继续向下搜索a。</span><br><span class="line">N：与n反向</span><br></pre></td></tr></table></figure>
- 一般模式：删除、复制与粘贴


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p,P：p为将已复制的数据粘贴到光标的下一行，P则为贴在光标上的上一行。</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="2-vim的附加功能"><a href="#2-vim的附加功能" class="headerlink" title="2.vim的附加功能"></a>2.vim的附加功能</h3><ul>
<li>当前大部分版本都采用vim代替vi的功能了。vim具有颜色显示功能，并且还支持很多程序语法，当使用vim编辑程序时（不论是C语言，还是shell脚本），vim可以帮你直接进行程序调试。vim的一般用法与vi一模一样，没有不同。</li>
<li>块选择</li>
<li>多文件编辑（略）</li>
<li>多窗口功能（略）</li>
</ul>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/网络通信/网络编程基础/">网络编程基础</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <p>##网络编程基础</p>
<ul>
<li><p>一、网络硬件</p>
<ul>
<li><p>关于计算机网络，没有一种被普遍接受的分类方法，但有两个因素非常重要：传输技术和距离尺度</p>
</li>
<li><p>目前普遍使用的传输技术有两种：</p>
<ul>
<li><p>（1）广播式连接</p>
</li>
<li><p>（2）点到点连接</p>
</li>
<li><p>广播式网络(broadcast networks)只有一个通信信道，网络上所有的机器都共享该信道。机器间传递的是短消息（分组或包），任何一台机器发送的短消息可以被其他所有机器接收到。分组中有一个地址域，指明了该分组的目标接收者。一台机器接收到一个分组后，它检查地址域。如果该分组是发送给他的，那么它就处理，否则，忽略。此外，可以通过地址域实现让所有机器都就收处理，或者让一组机器接受处理。</p>
</li>
<li><p>点到点网络是由许多连接构成，每一个连接对应一对机器。将一个分组传递到目的地可能要经过多台机器，所以最优路径对点到点网络很重要。</p>
</li>
<li><p>一般原则：越小的，地理位置局部化的网络倾向于广播传播模式，而大的网络倾向于点到点传播模式。</p>
</li>
<li><p>分类网络的另一个准则是网络的距离尺度。相应的可以划分为</p>
<ul>
<li>个人区域网（personal area network):例如一个无线网络将一台计算机与它的鼠标，键盘，打印机连接起来，这就是一个个人区域网。</li>
<li>局域网络</li>
<li>城域网络</li>
<li>广域网络</li>
</ul>
</li>
</ul>
</li>
<li><p>局域网(local area network,LAN)</p>
<ul>
<li>范围：一个建筑内到几千米的范围。</li>
<li>通常将公司办公室或工厂中的个人计算机和工作站连接器来，以便共享资源和交换信息。</li>
<li>不同于其他类型网络的特征：范围，传输技术，拓扑结构。</li>
<li>可能的传输技术：所有机器连接到同一根电缆上，传输速度一般可达10Gbps。 Mbps(每秒百兆位，1Mbps=1000 000位/每秒)，Gbps(1000 000 000位/每秒)。</li>
<li>广播式LAN也可能有不同的拓扑结构。<ul>
<li>总线型网络中，任何一个时刻，至多有一台机器是主机器，并且只有它才可以传送数据。其他的机器都被禁止发送数据。如何解决冲突：需要一种仲裁机制解决冲突。例如，以太网（Ethernet,IEEE 802.3)中发生冲突时，每台计算机只是等待一段随机时间，然后再次尝试发送数据。</li>
<li>环形网络。在环中，每一位都沿着自己的路径独立向前传播，而不需要等待它所属分组的其他位。例如IEEE802.5(IBM令牌环)</li>
</ul>
</li>
</ul>
</li>
<li><p>城域网（metropolitan area network,MAN）</p>
<ul>
<li>范围：覆盖一个城市</li>
<li>例如，有线电视网</li>
</ul>
</li>
<li><p>广域网（wide area network,WAN）</p>
<ul>
<li>范围：通常是一个国家或一个洲。</li>
<li>广域网包括主机（用户所有。例如，个人计算机）及通信子网（简称子网，由电话公司或Internet服务提供商所有）</li>
<li>子网由两个独立的部分组成：传输线和交换单元</li>
<li>传输线用于在机器之间传送数据位，可以由铜线，光纤，无线电链路构成。</li>
<li>交换单元：一种特殊的计算机，它们连接了三条或者更多条传输线。当数据在一条进线上到达的时候，交换单元必须选择一条出线，以便将数据转发出去。这些交换计算机过去被称为“路由器”</li>
<li>每一台主机往往连接到一个LAN上，在LAN上会有一个路由器，某些情况下，主机也可以直接连到一个路由器上。通信线和路由器（不包括主机）的集合构成了子网。</li>
<li>分组交换WAN的原则：“存储-转发”或“分组交换”。</li>
</ul>
</li>
<li><p>无线网络</p>
<ul>
<li>分为（1）系统互连（例如，蓝牙）；（2）无线LAN（3）无线WAN</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>二、网络软件</p>
<ul>
<li><p>为了降低网络设计的复杂性，绝大多数网络都组织成一队相互叠加的层，每一层都建立在其下一层的基础之上。</p>
</li>
<li><p>数据不是从一台机器的第n层直接传递到另一台机器的第n层。相反，每一层都将数据和控制信息传递给它的下一层，这样一直传递到最低下的层。第一层最下面是物理介质。</p>
</li>
<li><p>层和协议的集合称为网络体系结构。一个特定的系统所使用的的一组协议（每层一个协议）称为协议栈。</p>
</li>
<li><p>各层的实际问题</p>
<ul>
<li>每一层，都需要一种机制来标识出发送方和接收方。一般网络上有好多计算机，计算机上又有许多进程，所以需要一种编址机制来指定一个特定的目标。</li>
<li>协议需要确定每个连接对应多少逻辑信道，且确定他们的优先级别。许多网络至少提供两个逻辑信道，一个用于普通数据，一个用于紧急数据。</li>
<li>错误控制。</li>
<li>发送方发送速度很快时，如何避免接收方被数据淹没。有些是利用一种反馈机制，有些方案则限制发送方以商定的速率发送（流量控制）。</li>
<li>为每一对通信进程建立一个单独的连接，很不方便，且代价高昂。因此，可以是多对进程使用同一连接。多路复用，多路解复用。</li>
<li>路由选择。当源端和目标端之间存在多条路径的时候，必须进行路由选择。</li>
</ul>
</li>
<li><p>面向连接与无连接的服务</p>
<ul>
<li>面向连接的服务是基于电话系统模型的。</li>
<li>无连接的服务是基于邮政系统模型的。</li>
</ul>
</li>
<li><p>服务原语：一个服务通常是由一组原语（primitive）操作来描述的，用户进程通过这些原语操作可以访问服务。</p>
<ul>
<li>例子：为了实现一个可靠的字节流，可以考虑原语如下<ul>
<li>LISTEN：阻塞操作，等待一个进入的连接</li>
<li>CONNECT:与一个正在等待的对等体建立连接</li>
<li>RECEIVE：阻塞操作，等待一个进入的报文</li>
<li>SEND：给对等体发送一个报文</li>
<li>DISCONNECT:终止一个连接</li>
</ul>
</li>
<li>服务和协议的区别：服务好像是面向对象语言中的抽象数据类型或对象，它定义了在对象上可以执行的操作，但并没有具体实现。协议涉及到服务的具体实现。</li>
</ul>
</li>
<li><p>OSI参考模型</p>
<ul>
<li><p>OSI（Open System Interconnection）</p>
</li>
<li><p>物理层（physical layer）：涉及到在通信信道上传输的原始数据位。</p>
</li>
<li><p>数据链路层（data link layer）：主要将一个原始的传输设施转变成一条逻辑的传输线路，在这条传输线路上，所有检测出来的传输错误也会反应到网络层。数据链路层的做法是：让发送方将输入的数据拆分，分装到数据帧（data fram,通常几百或几千个字节），然后顺序的传送这些数据帧。如果是可靠的服务，接收方接收到后，给发送方送回一个确认帧（acknowledgement frame）。问题：快速发送方“淹没”掉慢速的接收方。解决：流量调节机制。</p>
</li>
<li><p>网络层（network layer）:控制子网的运行过程。网络层应当确定如何将分组从源端路由到目标端。问题：两个网络的编址方案不同，连接的问题。分组太大，另一个网络无法接受。</p>
</li>
<li><p>传输层（transport layer）：基本功能是接收来自上一层的数据，并且在必要的时候把这些数据分割成很小的单元，然后把数据单元传递给网络层，并确保这些数据片段都能够的到达另一端。</p>
</li>
<li><p>会话层（session layer）：允许不同机器上的用户之间建立回话。</p>
<ul>
<li>所谓会话，通常指各种服务，包括：<ul>
<li>对话控制（dialog control）：记录下该谁来传递数据了</li>
<li>令牌管理（token management）：禁止双方同时执行同一个关键操作</li>
<li>同步功能（synchronization）：在一个长的传输过程中设置一些检查点，以便在系统奔溃之后还能够在奔溃前的点上继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>表示层（presentation layer）：表示层下面各层中，关注的是如何传递数据位，而表示层关注的是所传递的信息的语法和语义。不同计算机可能会使用不同的数据表示法，为了让这些计算机能够进行通信，它们所交换的数据结构必须以一种抽象的方式来定义，同时，表示层还应该定义一种标准的编码方式，用来表达网络线路上所传递的数据。</p>
</li>
<li><p>应用层（application layer）：包含了各种各同样的协议，这些协议往往直接针对用户的需要，一个广泛使用的应用协议是HTTP（HyperText Transfer Protocol），它也是WWW（万维网）的基础。</p>
</li>
</ul>
</li>
<li><p>TCP/IP参考模型</p>
<ul>
<li><p>包括四层：应用层，传输层，互联网层，主机至网络。</p>
</li>
<li><p>互联网层（Internet layer）：互联网层定义了正式的分组格式和协议，该协议称为IP（Internet Protocol)。互联网层的任务是将IP分组投递到它们该去的地方。分组路由和避免拥塞是最主要的问题。</p>
</li>
<li><p>传输层：它的设计目标是容许源和目标主机上的对等体之间可以进行对话。包括TCP（Transport Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）。</p>
</li>
<li><p>应用层：包括</p>
<ul>
<li>虚拟终端协议（TELNET）：允许一台机器上的用户登录到远程的机器上，并且在远程的机器上进行工作。</li>
<li>文件传输协议（FTP）：提供了一种在两台机器之间高效地移动数据的途径。</li>
<li>电子邮件协议（SMPT）</li>
<li>DNS（Domain Name System，域名系统）：将主机名字映射到它们的网络地址。</li>
<li>HTTP用于获取www上的页面；等等。</li>
</ul>
</li>
<li><p>主机至网络层：TCP/IP参考模型并没有明确规定这里应该有哪些内容，它只是指出，主机必须通过某个协议连接到网络上，以便可以将分组发送到网络上。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三、物理层（简单介绍）</p>
<ul>
<li><p>数据通信理论的基础：傅立叶分析</p>
<ul>
<li>任何一个正常的周期为T的函数，都可以展开成多个（可能无线个）正弦和余弦函数的和。</li>
<li>正弦函数和余弦函数正交归一的关系</li>
<li>有限带宽的信号。带宽：传输过程中振幅不会明显减弱的这一段频率范围称为带宽（bandwidth）</li>
<li>信道的最大数据传输率。尼奎斯特采样定理和香农定理</li>
</ul>
</li>
<li><p>有导向的传输介质</p>
<ul>
<li>磁介质</li>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
</ul>
</li>
<li><p>无线传输</p>
<ul>
<li><p>电波传输</p>
</li>
<li><p>红外线和毫米波</p>
</li>
<li><p>光波传输</p>
</li>
<li><p>各类通信卫星</p>
</li>
</ul>
</li>
<li><p>移动通信系统及有线电视</p>
</li>
</ul>
</li>
<li><p>四、数据链路层</p>
<ul>
<li><p>数据链路层的设计要点</p>
<ul>
<li><p>数据链路层要完成的特点的功能</p>
<ul>
<li>1.向网络层提供一个定义良好的服务接口；</li>
<li>2.处理传输错误</li>
<li>3.调节数据流，确保慢速的接收方不会被快速的发送方淹没</li>
</ul>
</li>
<li><p>为了实现这些目标，数据链路层从网络层获取到分组，然后将这些分组封装到帧中以便传输。每一帧包括一个帧头、一个有效载荷域（用于存放分组），以及一个帧尾。帧管理构成了数据链路层的工作核心。</p>
</li>
</ul>
</li>
<li><p>数据链路层的功能是为网络层提供服务。最主要的服务是将数据从源机器的网络层传输到目标机器的网络层。</p>
</li>
<li><p>一般情况下，提供三种服务：</p>
<ul>
<li>无确认的无连接服务：源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认。</li>
<li>有确认的无连接服务：虽然没有使用逻辑连接，但所发的每一帧都需要单独的确认。超时后，会重发该帧。</li>
<li>有确认的面向连接服务：源机器和目标机器首先建立一个连接。该连接上发送的每一帧都被编号，数据链路层保证每一帧都会真正的被接收到。可以保证每一帧只被接收一次，且按照正确的顺序被接收。</li>
</ul>
</li>
<li><p>成帧：物理层的任务是接收一个原始的位流，并试图将它递交给目标机器，这个位流容易产生错误（位的数量改变，值发生变化等），检测错误和纠正错误的工作是由数据链路层来完成。</p>
</li>
<li><p>由于依靠时间来标识每一帧的起始和结束位置风险太大，所以要设计其他方法。</p>
<ul>
<li>1.字符计数法：每利用头部中的一个域来指定该帧中的字符数。问题，计数值有可能因为传输错误而被弄乱。</li>
<li>2.含字节填充的分界符法：它的做法是让每一帧都用一些特殊的字节做为开始和结束。缺点：它紧紧依赖8位字符的模式。</li>
<li>3.含位填充的分界标志法：</li>
<li>4.物理层编码违例法：</li>
</ul>
</li>
<li><p>错误控制：接收方送回一些特殊的控制帧用以确认信息。帧丢失的情况，可以采用定时器来解决（例如，超过定时器限制时间，则重发帧）。</p>
</li>
<li><p>流控制：如果发送方发送的帧的速度超过了接收方能够接受的这些帧的速度，则发送方该如何处理呢？解决办法：</p>
<ul>
<li>1.基于反馈的流量控制（feedback-based flow control）,接收方给发送方送回信息，允许它发送更多的数据，或者至少告诉发送它的情况怎么样。</li>
<li>2.基于速率的流量控制（rate-based flow control），使用这种方法的协议有一种内置机制，它限制了发送方传输数据的速率，而无需利用接收方的反馈信息（数据链路层不使用）。</li>
</ul>
</li>
<li><p>错误检测和纠正</p>
<ul>
<li>纠错码（error-correcting code）:在每一个被发送的数据块中包含足够的冗余信息，以便接收方可以推断出被发送的数据中肯定有哪些内容。<ul>
<li>包含m个数据位（报文）和r个冗余位（校验位）。我们把包含数据和校验位的n(n=m+r)位单元通常也称为n位码字（codeword）。</li>
<li>两个码字中不相同的位的个数称为海明距离（Hamming distance）。意义：如果两个码字的海明距离为d，则需要d个1位错误才能将一个码字变成另一个码字。例子，奇偶校验。</li>
</ul>
</li>
<li>检错码（error-detecting code）:也包含一些冗余信息，但这些信息只能让接收者推断出发生了错误，但推断不出发生了哪个错误，然后接受方可以请求重传。</li>
</ul>
</li>
<li><p>基本的数据链路协议</p>
<ul>
<li><p>基本假设：1.多数情况下，物理层和数据链路层进程会在一个特殊的网络I/O电路中的一个处理器上运行；而网络层代码则在主CPU上运行（其他情况也是可能的）。2.机器A希望用一个可靠地、面向连接的服务，向机器B发送一个长的数据流。</p>
</li>
<li><p>一个无限制的单工协议：该协议中，数据只能单向传输，传输方和接收方的网络层总是处于准备就绪的状态。处理的时间可以被忽略。假设缓存空间无限大。数据链路层之间的通信信道永远不会损坏或者丢失帧。</p>
</li>
<li><p>一个单工的停-等协议：需要处理的问题是如何避免发送方用超过接收能力的大量数据来淹没接收方。一般解决方案为，让接收方提供反馈信息给发送方。发送方送出一帧，然后先等待一个确认，再继续发送，这样的协议称为停-等协议（stop-and-wait）。</p>
</li>
<li><p>有噪声信道的单工协议：可能的情况就是有噪声的情况会导致帧信息损坏。确认帧完全丢失就会导致数据源机器不断地向目标机器发送相同的帧数据。解决办法：可以通过在每一帧的头部放上一个序列号用于判断是新帧还是重复帧。</p>
</li>
<li><p>滑动窗口协议（sliding window protocol）：</p>
<ul>
<li><p>上面的协议中，数据帧只在一个方向上传输。而大多数情况数据传输是双向的。解决办法：全双工数据传输（例如，使用两条独立的通信信道）。但这样会导致逆向信道带宽的浪费。</p>
</li>
<li><p>更好的办法：使用一条线路来传输两个方向上的数据。该模型中，从机器A到机器B的数据帧可以与从机器A到机器B的确认帧混合在一起。接收方只要检查证的头部的kind域，就可以区别该帧是数据还是确认。</p>
</li>
<li><p>更好的改进：当一个数据帧到达的时候，接收方并不是立即发送一个单独的控制帧，而是等待一会，直到网络层传递给它下一个分组，将确认信息（控制帧）和外发数据帧一起发送。这种将确认暂时延迟以便钩到下一个外发数据帧的技术称为捎带确认（piggybacking）。问题：数据链路层应该等待下一个分组多长时间？</p>
</li>
<li><p>滑动窗口协议的本质是：在任何时刻，发送方总是维持着一组序列号，分别对应于允许它发送的帧。我们称这些帧落在发送窗口（sending window）之内。类似的，接收方也维持着一个接收窗口（receiving window），对应于一组允许它接收的帧。发送方的窗口和接收方的窗口不必有同样的上下界，甚至比必有同样的大小。有些协议中，窗口有固定的大小，另一些协议中窗口的大小变化。</p>
<ul>
<li><p>发送方必须在内存中保存好所有这些帧，以便可能进行重传。如果最大窗口尺寸为n，则发送方需要n个缓冲区来存放未被确认的帧。</p>
</li>
<li><p>接收方数据链路层窗口对应于它可以接受的帧。任何落在窗口外面的帧都被丢弃，无需任何提示。</p>
</li>
<li><p>1位滑动窗口协议：一个最大窗口尺寸为1的滑动窗口协议。由于发送方在送出一帧以后，在发送下一帧之前要等待前一帧的确认。因此这样的1位滑动窗口协议使用了停-等的办法。</p>
</li>
<li><p>使用回退n帧技术的协议：目前为止，我们默认的假设是，一帧到达接收方所需要的传输时间加上确认帧回来的传输时间可以忽略不计。有时候这种假设是不正确的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>协议的验证(了解)</p>
<ul>
<li>有限状态机模型（finite state machine）</li>
<li>Petri网模型</li>
</ul>
</li>
<li><p>数据链路层协议示例</p>
<ul>
<li><p>SDLC（Synchronous Data Link Control,同步数据链路控制）协议（IBM提出））</p>
<ul>
<li>ADCCP（Advanced Data Communication Control Procedure,高级数据通信控制规程）（ANSI在SDLC基础上修改得到）</li>
<li>HDLP（High-level Data Link Control,高级数据链路控制）。（ISO在SDLC基础上修改）</li>
<li>这些协议基于相同的原理。所有协议是面向位的，并且为了确保数据的透明性，它们都使用了位填充</li>
<li>面向位填充协议帧的基本结构。<ul>
<li>帧的分界，标志序列（01111110）。</li>
<li>地址（address）域：对多个终端的线路显得很重要，因为在这样的环境中，该域被用于标识一个终端。</li>
<li>控制（Control）域：被用作序列号、确认，以及其他用途。</li>
<li>数据（Data）域：可以包含任何信息。它可以任意长，不过随着帧长度的增加，校验和的效率会降低，因为突发性错误的概率会加大。</li>
<li>校验和域（Checksum）：该域是一个循环冗余码。</li>
</ul>
</li>
</ul>
</li>
<li><p>Internet中的数据链路层</p>
<ul>
<li>在单个建筑物内，通常使用LAN来实现互连，但绝大多数的广域设施则通过点到点的租用线路构建起来的。</li>
<li>Internet中使用的数据链路协议称为PPP。PPP（Point-to-Point Protocol,点到点协议），它有多种用途，其中包括传送从路由器到路由器之间的流量，以及家庭用户到ISP之间的流量。PPP提供了三类功能：<br>  -（1）一种成帧方法。它可以毫无歧义地分隔出一帧的结束和下一帧的开始。并且帧的格式支持错误检测。<ul>
<li>（2）一个链路控制协议，可用于启动线路、测试线路、协商参数，以及当线路不在需要的时候可以温和的关闭线路。该协议称为LCP（Link Control Protocol，链路控制协议）。</li>
<li>（3）一种协商网络层选项的方法，并且协商方法与所使用的网络层协议独立。所选择的方法对于每一种支持的网络层都有一个不同的NCP（Network Control Protocol，网络控制协议）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：数据链路层的任务是将物理层提供的原始位流转换成可供网络层使用的帧流。用到的成帧方法包括：字符计数法、字节填充法和位填充法。为了避免快速发送方淹没一个慢速的接收方，数据链路协议需要提供流量控制功能。滑动窗口机制，两个窗口大小都为1，滑动窗口机制变成了停-等协议，当发送窗口大于1，接收方可以除了下一个顺序帧外丢弃其他帧，或将所有乱序的帧缓存起来，一直到需要这些帧的时候。 </p>
</li>
</ul>
</li>
<li><p>五、网络层</p>
</li>
<li><p>六、传输层</p>
</li>
<li><p>七、应用层</p>
</li>
<li><p>八、网络安全</p>
</li>
</ul>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Java/2018-06-28-Dubbo Cloud Native 实践与思考/">Dubbo Cloud Native 实践与思考</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h1 id="Dubbo-Cloud-Native-实践与思考"><a href="#Dubbo-Cloud-Native-实践与思考" class="headerlink" title="Dubbo Cloud Native 实践与思考"></a>Dubbo Cloud Native 实践与思考</h1><!-- TOC -->

<ul>
<li><a href="#dubbo-cloud-native-%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83">Dubbo Cloud Native 实践与思考</a><ul>
<li><a href="#%E5%88%86%E4%BA%AB%E7%AE%80%E4%BB%8B">分享简介</a></li>
<li><a href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D">自我介绍</a></li>
<li><a href="#%E4%B8%BB%E8%A6%81%E8%AE%AE%E7%A8%8B">主要议程</a><ul>
<li><a href="#cloud-native-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD">Cloud Native 基础设施</a><ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0service-discovery">服务发现（Service Discovery ）</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">如何选择</a><ul>
<li><a href="#eureka">Eureka</a></li>
<li><a href="#consul">Consul</a></li>
<li><a href="#zookeeper">Zookeeper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3">服务网关</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE">分布式配置</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD">服务熔断</a></li>
<li><a href="#%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA">链路跟踪</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7">服务监控</a></li>
</ul>
</li>
<li><a href="#cloud-native-%E6%9E%B6%E6%9E%84%E9%80%89%E5%9E%8B">Cloud Native 架构选型</a><ul>
<li><a href="#cncf-%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB">CNCF 架构体系</a></li>
<li><a href="#spring-cloud-%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB">Spring Cloud 架构体系</a></li>
<li><a href="#dubbo-%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB">Dubbo 架构体系</a></li>
</ul>
</li>
<li><a href="#dubbo-cloud-native-%E5%87%86%E5%A4%87">Dubbo Cloud Native 准备</a><ul>
<li><a href="#dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8annotation-driven">Dubbo 注解驱动（Annotation-Driven）</a><ul>
<li><a href="#dubbocomponentscan-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A4%BA%E4%BE%8B"><code>@DubboComponentScan</code> 服务端示例</a></li>
<li><a href="#dubbocomponentscan-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B"><code>@DubboComponentScan</code> 客户端示例</a></li>
</ul>
</li>
<li><a href="#dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AEexternalized-configuration">Dubbo 外部化配置（Externalized Configuration）</a></li>
</ul>
</li>
<li><a href="#%E7%8E%B0%E5%9C%BA%E6%BC%94%E7%A4%BA%E7%8E%AF%E8%8A%82">现场演示环节</a><ul>
<li><a href="#dubbo-%E6%95%B4%E5%90%88-hystrix-%E7%A4%BA%E4%BE%8B">Dubbo 整合 Hystrix 示例</a><ul>
<li><a href="#dubbo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0">Dubbo 客户端实现</a><ul>
<li><a href="#dubbo-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0">Dubbo 服务端实现</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AF-rest-%E6%9C%8D%E5%8A%A1">测试客户端 REST 服务</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="分享简介"><a href="#分享简介" class="headerlink" title="分享简介"></a>分享简介</h2><p>Cloud Native 应用架构随着云技术的发展受到业界特别重视和关注，尤其是 CNCF（Cloud Native Computing Foundation）项目蓬勃发展之际。Dubbo 作为服务治理的标志性项目，自然紧跟业界的潮流，拥抱技术的变化。本次分享的议题包括介绍 Apache 孵化项目Dubbo Spring Boot Project 以及汇报 Dubbo 与 Cloud Native 整合过程中的一些实践与思考，如适配  Spring Cloud 、服务发现、服务网关、服务跟踪以及监控等。</p>
<blockquote>
<p>注：为了读者的阅读方便和习惯，本文字稿将在演讲内容的基础上做出适当的调整。</p>
</blockquote>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>马昕曦（小马哥），阿里巴巴中间件技术专家，十余年 Java EE 从业经验，Dubbo 维护者、架构师以及微服务布道师。目前主要负责阿里巴巴集团微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p>
<h2 id="主要议程"><a href="#主要议程" class="headerlink" title="主要议程"></a>主要议程</h2><p>今天我非常荣幸地与大家一起讨论关于 Dubbo Cloud Native 相关议题，本次议题紧扣“实践与思考“两个关键字，主要的议程包括：</p>
<ul>
<li><strong>Cloud Native 基础设施</strong></li>
<li><strong>Cloud Native 架构选型</strong> </li>
<li><strong>Dubbo Cloud Native 准备</strong></li>
</ul>
<h3 id="Cloud-Native-基础设施"><a href="#Cloud-Native-基础设施" class="headerlink" title="Cloud Native 基础设施"></a>Cloud Native 基础设施</h3><p>关于 Cloud Native 的定义，不同的云平台可能给出的内容存在差异。此处，我向大家介绍目前最热门的 CNCF 的定义：</p>
<blockquote>
<p> ”<a target="_blank" rel="noopener" href="https://github.com/cncf/toc/blob/master/DEFINITION.md">CNCF Cloud Native Definition v1.0</a>“ 中的描述：</p>
<blockquote>
<p>Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.</p>
</blockquote>
</blockquote>
<p>相对于其他学术流派，CNCF 的 Cloud Native 定义更为具体，偏向于软件技术。这一点我们从文中的一些关键字能够明显地体会到，如关键字 “Containers（容器）”、”service meshes”、”microservices（微服务）“等。通常，开发人员较为关注的 Cloud Native 基础设施为：“服务发现”、“负载均衡”、“服务网关”、“分布式配置”、“服务熔断”以及“跟踪监控”，如图所示：</p>
<p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8705.jpg" alt="幻灯片05"></p>
<p>由于 PPT 格式的限制，此处我将“链路跟踪”与“服务监控” 并陈为“跟踪监控”。接下来，我们进入“服务发现”的讨论。</p>
<h4 id="服务发现（Service-Discovery-）"><a href="#服务发现（Service-Discovery-）" class="headerlink" title="服务发现（Service Discovery ）"></a>服务发现（Service Discovery ）</h4><p>随着微服务架构（MSA）受到不同规模企业的青睐，服务治理的实施逐渐被提上基础设施改造的议程。尽管这些概念在 SOA 时代已经提出，然而引起业界广泛关注应归功于微服务。服务发现（Service Discovery ）作为服务治理的核心特性，通常也将服务注册（Service Registration）一并讨论。无论是服务发现，还是服务注册，在具体落地实施时，它们必须面对技术选型的问题。在座的各位，包括我，大多数是 Java 程序员，自然关心 Java 的技术方案。目前，Java 社区最为津津乐道的方案莫过于 Spring Cloud，搭配 Netflix OSS 组件 Eureka，帮助 Spring Boot 应用快速搭建服务发现体系。其中，Eureka Server 作为注册中心服务器，Spring Boot 应用整合 Eureka Client 向 Eureka Server 注册。实际上，Spring Cloud 除了整合 Netflix Eureka 作为服务发现之外，还提供了 Apache Zookeeper 和 HachiCorp Consul 的实现，所以这三种方案出现在当前页面：</p>
<p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8706.jpg" alt="幻灯片06"></p>
<p>其中还包括 Redis 和 Apache Curator，前者是 Dubbo 的服务发现实现方案之一，然而小马哥并不建议使用 Redis 作为注册中心，还是保持它缓存中间件的单纯性较好。而 Curator 作为 Zookeeper Java 客户端类库，它不但可用在 Dubbo，而且其扩展项目 Curator Service Discovery 也是 Spring Cloud 整合 Zookeeper 作为服务发现的关键基础设施。或许大家思考以上方案应该如何选型的问题。</p>
<h5 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h5><h6 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h6><p>当服务发现选型时，Netflix Eureka 或许是在开发人员脑海中复现的首选方案。然而 Eureka 在阿里大规模实践时，它的表现并不理想，当 Eureka 客户端服务实例数量达到一定时，Eureka Server 时常会出现服务不可用的情况，主要的问题集中在更新（Update）机制、复制（Replication）机制以及内存型存储。由于时间的关系，此处我不加详细说明，部分答案在 Eureka Wiki <a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-2.0-Motivations">Eureka 2.0 Motivations</a> 中也有描述：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-2.0-Motivations#why-eureka-20">Why Eureka 2.0?</a></p>
<ul>
<li>Only support homogenous client views</li>
<li>Only supports scheduled updates</li>
<li>Replication algorithm limits scalability</li>
</ul>
<blockquote>
<p>注：以上具体内容在分享现场并没有具体提及，此处特意为读者补充。</p>
</blockquote>
</blockquote>
<p>以上问题 Netflix 早在 2015 年已意识到，然而 Eureka 2.0 的发布遥遥无期。后来，我托朋友联系上了 Netflix 的工程师，咨询他们关于 Eureka 1 在自身生产环境的使用情况。他们的回复是部分场景在使用。这样的答复值得玩味，再细问其覆盖比重，对方三缄其口。这不得不让我对 Eureka 的成熟度产生了质疑，所以我不建议大家在数以千计的应用实例场景中使用。</p>
<h6 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h6><p>Consul 同样作为 Spring Cloud 服务中心，基于 GO 语言开发，其数据一致性采用 Raft 算法，低内存，集群支持。曾一度成为我理想的替换 Eureka 的方案，不过本人并不具备 Consul 的大规模运用，为此还特意请教永辉云创的架构师翟永超（《Spring Cloud 微服务实战》的作者）。他告知 Consul 表现不错，并在跨 DC（数据中心）方面也比较稳定：<img src="/img/assets/image-20180627210416358.png" alt="image-20180627210416358"></p>
<p>他的答复让我增强了 Consul 的信心，稍显遗憾的是其 Consul 应用节点略少。后来，我听说 B 站的哥们自研服务发现中间件 **<a target="_blank" rel="noopener" href="https://github.com/Bilibili/discovery/">discovery</a>**，他们应该也对 Consul 做过调研和评估，他们的看法是：</p>
<p><img src="/img/assets/image-20180627210529749.png" alt="image-20180627210529749"></p>
<blockquote>
<p>Github 开源地址：<a target="_blank" rel="noopener" href="https://github.com/Bilibili/discovery/">https://github.com/Bilibili/discovery/</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/Bilibili/discovery/">discovery</a></strong> 在 B 站 K8S 上的使用情况：</p>
<p><img src="/img/assets/image-20180627210509857.png" alt="image-20180627210509857"></p>
</blockquote>
<p>综合两家公司的评估，尽管没有经过本人实际操作，并且两者没有提供具体的数据指标，然而在一定程度上说明 Consul 作为注册中心的实例节点规模大概在 2k 以内。换言之，它比较适合中小型企业。</p>
<h6 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h6><p>Zookeeper 即可是 Spring Cloud 注册中心，又能作为 Dubbo 注册中心，与 Eureka 不同，它属于 CP 分布式策略，而后者属于 AP。两者的共同点在于均属于内存型注册中心，在大规模集群场景，也会遇到 Eureka 类似的问题。不过从运维的角度，相较于 Eureka 而言，熟悉 Zookeeper 运维朋友更多。在生态性方面，Zookeeper 周边的生态更丰富，如 Zookeeper C API，尽管 Eureka 提供了语言无关性的 REST 接口。同时，Zookeeper 还从当配置服务器的角色，降低了学习的成本。综上结论，我推荐使用 Zookeeper 作为服务发现基础设施，无论您选择 Dubbo 方案，还是使用 Spring Cloud。尽管它在大规模集群时也出现 Zookeeper 间歇性卡顿等问题。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8707.jpg" alt="幻灯片07"></p>
<p>负载均衡是第二个重要 Cloud Native 基础设施，熟悉 Spring Cloud 的朋友一定对右侧的蝴蝶结有印象，它就是 Netflix OSS 负载均衡组件 Ribbon，框架层面提供了多种负载均衡规则，如：</p>
<ul>
<li><strong>随机</strong> - <code>RandomRule</code></li>
<li><strong>轮循</strong> - <code>RoundRobinRule</code></li>
<li><strong>权重响应时间</strong> - <code>WeightedResponseTimeRule</code></li>
</ul>
<p><code>WeightedResponseTimeRule</code> 之外，其他的 Ribbon 负载均衡实现均没有提供权重因子，而权重因子对于蓝绿发布、服务预热等方面的帮助是至关重要的。因此，权重因子在 Dubbo “<strong>随机</strong>“、”<strong>轮询</strong>“ 以及 ”<strong>最少活跃调用数</strong>“ 负载均衡算法中均体现。</p>
<p>以上讨论的两种框架均属于 Java 实现，而中间的 Kong 则是更为通用的实现，通常它作为 API 服务网关，后面我们将继续讨论。可简单地认为它是 Nginx + Lua 的扩展，负载均衡自然成为不可或缺的特性。其默认的负载均衡算法为具备权重的轮询（weighted-round-robin），同时一致性 Hash 算法作为可选方案。</p>
<h4 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8708.jpg" alt="幻灯片08"></p>
<p>谈及服务网关，Java 工程师最容易想到的是 Spring Cloud Zuul。Zuul 是 Netflix 基于 Servlet API 开发的 Web 服务代理组件，在 Spring Cloud 使用场景中，它与 Eureka  和 Ribbon 整合，打造具备服务动态更新和负载均衡能力的服务网关。</p>
<p>最近，随着 Spring Cloud Finchley 的发布，Spring Cloud Zuul 的替代方案 Spring Cloud Gateway 孕育而生，不过官方的描述还是比较谦虚谨慎，并没有一刀切地引导开发人员从 Zuul 迁移到 Gateway 上来：</p>
<blockquote>
<p>API Gateway built on top of the Spring Ecosystem, including: Spring 5, Spring Boot 2 and Project Reactor. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p>
</blockquote>
<p>两者不同点在于，Zuul 运行在 Servlet 容器中，而 Gateway 并不像 Spring WebFlux 能够兼容 Servlet 3.1 运行时，而是必须依赖 Netty 的运行时，以及整合 Reactive 框架 Reactor，实现异步非阻塞网关。由于近期对于 Spring 5  WebFlux 能够大幅提升应用性能的观点甚嚣尘上，实际上，没有任何直接性能基准测试证明 WebFlux 能够加快程序执行速度，或许大家认为我的观点与主流格格不入，可是我要告诉大家的是，这个问题我在同事间验证过很多次，大多数情况，Reactive 并不没有提升性能。就连 Spring 官方也承认这个观点：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance">1.1.7. Performance vs scale</a></p>
<p>Performance has many characteristics and meanings. <strong>Reactive and non-blocking generally do not make applications run faster</strong>. They can, in some cases, for example if using the <code>WebClient</code> to execute remote calls in parallel. <strong>On the whole it requires more work to do things the non-blocking way and that can increase slightly the required processing time</strong>.</p>
<blockquote>
<p>资源地址：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance">https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance</a></p>
</blockquote>
</blockquote>
<p>同时，这里提供一篇 <a target="_blank" rel="noopener" href="https://blog.ippon.tech/spring-5-webflux-performance-tests/">Spring 5 WebFlux: Performance tests</a> 的文章，在结尾部分给出了结论，作者坦言在速度上没有明显的提升，甚至从结果来看，速度稍微更糟糕：</p>
<ul>
<li><em>No improvement in speed was observed with our reactive apps (the Gatling results are even slightly worse).</em></li>
</ul>
<blockquote>
<p>以上测试工程和结论是由开源项目 JHipster 的工程师给出，具备一定的客观性和可信度。</p>
<blockquote>
<p>资源地址：<a target="_blank" rel="noopener" href="https://blog.ippon.tech/spring-5-webflux-performance-tests/">https://blog.ippon.tech/spring-5-webflux-performance-tests/</a></p>
</blockquote>
</blockquote>
<p>换言之，基于 Reactor 开发的 Gateway 在性能可能并没有明显的提升。因此，Zuul 和 Gateway 的性能对比则演变为 Servlet 容器和 Netty Web 容器的比较，感兴趣的朋友可以去网上寻找一些比较数据，两者的性能在伯仲间。</p>
<p>当然，我和在座的各位一样，对 Java 的实现方案自然是情有独钟。然而我想说的是，身为 Java 工程师，<strong>眼中难免有 Java，但是眼中不要只有 Java</strong>。Nginx 作为当年著名 “C10K” 问题的解决方案，无论从连接数量，还是资源消耗方面均优于 Java 实现。作为技术人，应该具有更为宽广的胸怀，接纳非我族类的气魄，该放手的时候就放手。Nginx 作为服务网关不失为一种好的方案，然而它的动态性略为不足，需要结合 Lua 脚本辅助完成，因此，OpenResty 和 Kong 这类方案脱颖而出。如果就 HTTP API 网关而言，个人认为 Kong 的方案更佳，因为它提供完整的解决方案，包括前面讨论的负载均衡（权重）、服务熔断以及服务发现等特性。类似的特性在 CNCF 项目 Envoy 也有体现，它是另一种高性能代理的方案，提供服务发现、健康和负载均衡。在协议上，天然支持 HTTP 和 HTTP/2，而通讯协议支持 gRPC，建议大家予以高度关注。</p>
<p>值得一提的是，HTTP API 网关通常需要支持 sidecar，换言之，支撑网关服务的基础设施必须提供服务发现的能力，就功能性而言，Zuul 和 Gateway 自身并不具备这样的特性，需要搭配 Eureka 这样组件，它们更像服务路由器的角色。</p>
<h4 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8709.jpg" alt="幻灯片09"></p>
<p>左边和中间的四种技术均为 Spring Cloud 分布式配置的底层存储，其中 Git 为版本式配置，而 JDBC 是从 Spring Cloud Edgware 版本开始支持，提供更为通用和动态的配置源。这里我们又见到 Zookeeper 的声影，从简化运维的角度，可以利用 Zookeeper 即承担服务发现，也作为分布式配置的基础设施。而最右边的 etcd 是最近非常火的 Kubernetes 分布式配置的 key-value 存储，提供快速、简单、安全和可高的解决方案。</p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt="幻灯片10"></p>
<p>服务熔断也非常让开发人员联想到 Spring Cloud Hystrix 技术，不过 Hystrix 并非与 Spring Cloud 强耦合，当然 Dubbo 也能结合 Netflix Hystrix 框架提供服务熔断的能力，后面部分将介绍 Dubbo 与 Hystrix 整合，提升 Dubbo 服务熔断的能力。确切地说，Dubbo 所提供的能力是集群容错，包括 Failover 等模式。 Kong 也天然地支持服务熔断的能力，所以它作为 API 网关的特性是全面的。</p>
<h4 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt="幻灯片11"></p>
<p>以上链路跟踪的基础设施从左至右，分别为 Zipkin、OpenTracing 以及 Jaeger，三者的灵感均来自于 <a target="_blank" rel="noopener" href="https://ai.google/research/pubs/pub36356">Google 论文 Dapper</a>。相对而言，Java 程序员可能更为熟悉 Zipkin，因为它是 Spring Cloud Sleuth 首选方案，提供客户端上报以及服务端聚合和 Dashboard 等功能。而 OpenTracing 和 Jaeger 是 CNCF 孵化项目，前者属于开放的标准，提供多语言的适配实现，后者则由 Uber（优步）公司开发并开源的链路跟踪项目，功能上与 Zipkin 类似，不过它基于 GO 语言开发，同时也提供 Java 客户端。</p>
<blockquote>
<p>OpenTracing 官网：<a target="_blank" rel="noopener" href="http://opentracing.io/">http://opentracing.io/</a><br>jaeger 官网：<a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></p>
</blockquote>
<h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt="幻灯片12"></p>
<p>服务监控与链路跟踪有所区别，主要用于监控应用系统或业务的指标数据，可能是健康阈值，如 CPU 或 内存使用率，也可以是业务指标，如最近一小时的用户登录量。通常采用 Metrics 方式暴露，可使用客户端推送或服务端拉取的方式传输 Metrics 信息到数据中心。通常 Metrics 数据与时间是存在对应关系，因此，基本上采用时序型数据库来存储，如图中的 OpenTSDB。通常，Java 微服务应用会选择 Spring Boot 框架作为基础设施，如我之前设计的监控架构就采用了 Spring Boot + OpenTSDB ，后端存储基于 HBase。当时 Spring Boot Actuator Metrics 仅为简单的 Key Value 形式，自然 OpenTSDB 是理想的选择。随着 Spring Boot 2.0 开始支持 <a target="_blank" rel="noopener" href="https://micrometer.io/">Micrometer</a> 之后，使得 Spring Boot 的应用能够整合更多的 Micrometer 适配方案，其中名气较大的就是图中间的 <a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a>，它同样也是 CNCF 的孵化项目。</p>
<p>当然服务监控不只是 Metrics 方式，我所知道国内不少的公司采用了日志收集的方案，并搭配 ELK（Elasticsearch, Logstash, Kibana） 架构，减少运维成本。假设您没有使用该方案，或者仅使用了 Elasticsearch 的话，无论哪种方案，图形化界面的监控是必不可少的，因此我推荐 Grafana，该项目能够支持多种数据源，包括前文提到的 OpenTSDB、Prometheus 以及 ElasticSearch 等。由此，从数据采集、上报、聚合以及展示的特性上，这些基础设施帮助 Cloud Native 应用构建服务监控的闭环。</p>
<p>本议程介绍了一些 Cloud Native 技术设施，接下里我们继续讨论 Cloud Native 架构选型。</p>
<h3 id="Cloud-Native-架构选型"><a href="#Cloud-Native-架构选型" class="headerlink" title="Cloud Native 架构选型"></a>Cloud Native 架构选型</h3><h4 id="CNCF-架构体系"><a href="#CNCF-架构体系" class="headerlink" title="CNCF 架构体系"></a>CNCF 架构体系</h4><p><img src="/img/assets/CNCF.png" alt="CNCF"></p>
<p>CNCF 体系作为目前最热门的架构选型之一，基本上围绕着 Kubernetes 为中心而构建。个人认为，Java 业界和 CNCF 体系并没有达成共识，如服务网关，CNCF 主打 Envoy，而 Java 主要的方案为 Zuul 和 Spring Cloud Gateway。因此，个人建议是密切的关注 CNCF 的发展，不过个别孵化项目可以先行，如 Prometheus 和 Jaeger 等。 至于 CNCF 与 Java 生态的整合和落地，还得有待时日。</p>
<h4 id="Spring-Cloud-架构体系"><a href="#Spring-Cloud-架构体系" class="headerlink" title="Spring Cloud 架构体系"></a>Spring Cloud 架构体系</h4><p><img src="/img/assets/Spring-Cloud.png" alt="Spring Cloud"></p>
<p>实际上，这个图片并非 Spring Cloud 组件架构，而是将其整合在 Pivotal Cloud Foundry (PCF) 架构中。基本上，Spring Cloud 功能组件均有所体现，包括 Eureka、Hystrix、Ribbon 等。不过值得注意的是，Spring Cloud Stream 是一套较为完整和抽象的流式编程框架，屏蔽了底层传输介质（不仅是消息服务），如 Kafka、RabbitMQ 等。除此之外，其他的组件可圈可点，如 Eureka 在大规模运用中的卡顿问题、Ribbon 缺少权重、Zuul 连接数限制和资源消耗、服务调用受限于 Feign REST 协议限制等。如果在小规模场景使用，以上限制或问题不明显，可以说 Spring Cloud 完全能够适任。</p>
<p>不过，差不多两年前，我曾在不同的公开场合讲过：”Spring Boot 易学难精，Spring Cloud 能用但不成熟“。当时很多人觉得我“离经叛道”，然而这句话并非空穴来风，是我这几年来 Java 微服务架构实施的心得。这两年来，深受 Spring Cloud “折磨”的小伙伴逐渐觉醒，慢慢地开始回到 Dubbo 等技术方案。如 Martin Fowler 在为“微服务”下定义时，提到通讯协议要用轻量级的 REST。假设微服务要做到服务无关的话，那么 Web Services 协议也是可以，尽管它看起来比较重，不过 Web Services 的结构化和强类型，可以省去不少的运行时校验逻辑。在我看来，微服务更大程度应该体现在服务粒度上，诚如 Netflix 前架构师 Adrian Cockcroft 说言：“Fine grain SOA”（微服务就是细粒度的 SOA），就这一点而言，比较容易地和业界达成共识。当我们把 Martin 的话视如圭臬时，我们是否要思考它是否经得起工程检验。这里，我没有兴趣贬低他人，来抬高自己（Dubbo），从而引导让大家放弃 Spring Cloud，而是我们需要给 Spring Cloud 时间，包括未来 Dubbo 也会向 Spring Cloud 靠拢并整合。在阿里的内部，基于 Nacos（马上开源的项目）和 Apache RocketMQ，实现了 Spring Cloud Service Discovery、Config 以及 Stream 等整合和适配，一旦时机成熟，可能会开源与大家共建。</p>
<p>既然谈到了 Dubbo，下面我们再来讨论 Dubbo 的架构体系。</p>
<h4 id="Dubbo-架构体系"><a href="#Dubbo-架构体系" class="headerlink" title="Dubbo 架构体系"></a>Dubbo 架构体系</h4><p><img src="/img/assets/Dubbo.png" alt="Dubbo.png"></p>
<p>编程模型方面，不但支持传统的 Spring XML 配合方式，已经实现注解驱动以及外部化配置，并且全面支持最新的 Spring Boot 2.0，在不久的未来，大家会看到 Dubbo 与 Spring Cloud 的整合，使开发人员无缝地衔接已有的 Spring Cloud 应用。</p>
<blockquote>
<p>Dubbo Spring Boot 项目地址：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></p>
</blockquote>
<p>注册中心方面，Dubbo 将整合 Eureka、etcd 以及 Consul 基础设施，深度与业界热门方案整合。</p>
<p>熔断机制方面，Dubbo 会在近期发布 Hystrix 整合实现，将编程友好性做得最大化。</p>
<p>通讯协议方面，Dubbo 将会支持 gRPC、Thrift 等热门通讯协议。</p>
<p>至于序列化协议，自然首先考虑的是 Protobuf，因其高层 gRPC 搭配 HTTP/2 快成或已经成为下一代通讯协议的事实标准，使得任何人无法忽视它们的存在。当然其他协议也会陆续支持。</p>
<p>其他方面，我这里就不一一介绍，总之，现在 Dubbo 已不再只是一个单一的 PRC 框架，而是要拥抱业界，形成完整的生态体系，与业界形成最大公约数。</p>
<h3 id="Dubbo-Cloud-Native-准备"><a href="#Dubbo-Cloud-Native-准备" class="headerlink" title="Dubbo Cloud Native 准备"></a>Dubbo Cloud Native 准备</h3><p><img src="/img/assets/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt="幻灯片16"></p>
<p>在 Dubbo 架构体系时，我们曾提到编程模型的变化。从 Dubbo <code>2.5.8</code> 开始，注解驱动和外部化配置均已得到支持。同时，Dubbo 已经合并 Dubbox 代码，Java JAX-RS 标准得到了支持，目前业界事实的 REST 标准 Spring Web MVC 正在同步开发。Reactive 的支持也在同步进行，小马哥还得友好地提醒一下各位，对于 Reactive 的期望不应该过分的关注性能的提升。</p>
<h4 id="Dubbo-注解驱动（Annotation-Driven）"><a href="#Dubbo-注解驱动（Annotation-Driven）" class="headerlink" title="Dubbo 注解驱动（Annotation-Driven）"></a>Dubbo 注解驱动（Annotation-Driven）</h4><p>在 Dubbo  <code>2.5.7</code> 之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于Dubbo 服务提供和 Dubbo 服务引用。</p>
<p>其中，<code>@Service</code> 作为 XML 元素 <code>&lt;dubbo:service&gt;</code> 的替代注解，与 Spring Framework <code>@org.springframework.stereotype.Service</code> 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的 <code>@Reference</code>，则是替代<code>&lt;dubbo:reference&gt;</code> 元素，类似于 Spring 中的 <code>@Autowired</code>。</p>
<p> <code>2.5.7</code> 之前的Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;annotation-provider&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;127.0.0.1:4548&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;com.alibaba.dubbo.config.spring.annotation.provider&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不仅如此，当时的版本存在“ <code>@Service</code> Bean 不支持 Spring AOP” 以及 “<code>@Reference</code> 不支持字段继承性” 等问题。</p>
<p>从 <code>2.5.7</code> 开始，Dubbo 开始引入组件扫描 Annotation <code>@DubboComponentScan</code>，借鉴了 Spring Boot 1.3 引入的 <code>@ServletComponentScan</code>。</p>
<p>在职责上，<code>@DubboComponentScan</code> 相对于 Spring Boot <code>@ServletComponentScan</code> 更为繁重，原因在于处理 Dubbo  <code>@Service</code> 类暴露 Dubbo 服务外，还有帮助 Spring  Bean <code>@Reference</code>字段或者方法注入 Dubbo 服务代理。 </p>
<p>在场景上，Spring Framework <code>@ComponentScan</code> 组件扫描逻辑更为复杂。而在 <code>@DubboComponentScan</code>  只需关注 <code>@Service</code> 和 <code>@Reference</code> 处理。</p>
<blockquote>
<p>注：更多 Dubbo 注解驱动的详情，请参考<a target="_blank" rel="noopener" href="https://github.com/mercyblitz/blogs/blob/master/java/dubbo/Dubbo-Annotation-Driven.md">《Dubbo 注解驱动（Annotation-Driven）》</a></p>
</blockquote>
<h5 id="DubboComponentScan-服务端示例"><a href="#DubboComponentScan-服务端示例" class="headerlink" title="@DubboComponentScan 服务端示例"></a><code>@DubboComponentScan</code> 服务端示例</h5><p>假设，服务提供方和服务消费分均依赖服务接口<code>DemoService</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务提供方实现<code>DemoService</code>  - <code>AnnotationDemoService</code> </li>
</ul>
<p>同时标注 Dubbo <code>@Service</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation &#123;<span class="doctag">@link</span> DemoService&#125; 实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello , &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端 <code>@Configuration</code> Class</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan(&quot;com.alibaba.dubbo.demo.provider&quot;)</span> <span class="comment">// 扫描 Dubbo 组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dubbo-annotation-provider&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">&quot;dubbo-annotation-provider&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;my-registry&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dubbo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务提供方引导类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供方引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        context.register(ProviderConfiguration.class);</span><br><span class="line">        <span class="comment">// 启动上下文</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 获取 DemoService Bean</span></span><br><span class="line">        DemoService demoService = context.getBean(DemoService.class);</span><br><span class="line">        <span class="comment">// 执行 sayHello 方法</span></span><br><span class="line">        String message = demoService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台输出信息</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="DubboComponentScan-客户端示例"><a href="#DubboComponentScan-客户端示例" class="headerlink" title="@DubboComponentScan 客户端示例"></a><code>@DubboComponentScan</code> 客户端示例</h5><ul>
<li>消费服务 <code>DemoService</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation 驱动 &#123;<span class="doctag">@link</span> DemoService&#125; 消费方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoServiceConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference(url = &quot;dubbo://127.0.0.1:12345&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHell</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消费端 <code>@Configuration</code> Class</li>
</ul>
<p>与服务提供方配置类似，服务消费方也许 Dubbo 相关配置 Bean - <code>ConsumerConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费方配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前应用配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">&quot;dubbo-annotation-consumer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 AnnotationDemoServiceConsumer，<span class="doctag">@DubboComponentScan</span> 将处理其中 <span class="doctag">@Reference</span> 字段。</span></span><br><span class="line"><span class="comment">     * 如果 AnnotationDemoServiceConsumer 非 Spring Bean 的话，</span></span><br><span class="line"><span class="comment">     * 即使 <span class="doctag">@DubboComponentScan</span> 指定 package 也不会进行处理，与 Spring <span class="doctag">@Autowired</span> 同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationDemoServiceConsumer <span class="title">annotationDemoServiceConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationDemoServiceConsumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务消费方引导类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.bootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ConsumerConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.config.ProviderConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.consumer.AnnotationDemoServiceConsumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费端引导类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:mercyblitz@gmail.com&quot;&gt;Mercy&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        startProviderContext();</span><br><span class="line">        <span class="comment">// 启动并且返回服务消费方上下文</span></span><br><span class="line">        ApplicationContext consumerContext = startConsumerContext();</span><br><span class="line">        <span class="comment">// 获取 AnnotationDemoServiceConsumer Bean</span></span><br><span class="line">        AnnotationDemoServiceConsumer consumer = consumerContext.getBean(AnnotationDemoServiceConsumer.class);</span><br><span class="line">        <span class="comment">// 执行 doSayHello 方法</span></span><br><span class="line">        String message = consumer.doSayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出执行结果</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动并且返回服务消费方上下文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AnnotationConfigApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext <span class="title">startConsumerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务消费方 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext consumerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册服务消费方配置 Bean</span></span><br><span class="line">        consumerContext.register(ConsumerConfiguration.class);</span><br><span class="line">        <span class="comment">// 启动服务消费方上下文</span></span><br><span class="line">        consumerContext.refresh();</span><br><span class="line">        <span class="comment">// 返回服务消费方 Annotation 配置上下文</span></span><br><span class="line">        <span class="keyword">return</span> consumerContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务提供方上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProviderContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Annotation 配置上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext providerContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置 Bean</span></span><br><span class="line">        providerContext.register(ProviderConfiguration.class);</span><br><span class="line">        <span class="comment">// 启动服务提供方上下文</span></span><br><span class="line">        providerContext.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Dubbo-外部化配置（Externalized-Configuration）"><a href="#Dubbo-外部化配置（Externalized-Configuration）" class="headerlink" title="Dubbo 外部化配置（Externalized Configuration）"></a>Dubbo 外部化配置（Externalized Configuration）</h4><p>在Dubbo 注解驱动例子中，无论是服务提供方，还是服务消费方，均需要转配相关配置Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">    applicationConfig.setName(<span class="string">&quot;dubbo-annotation-consumer&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> applicationConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然实现类似于<code>ProviderConfiguration</code> 和 <code>ConsumerConfiguration</code> 这样的 Spring  <code>@Configuration</code> Bean 成本并不高，不过通过 Java Code 的方式定义配置 Bean，或多或少是一种 Hard Code（硬编码）的行为，缺少弹性。</p>
<p>尽管在 Spring 应用中，可以通过 <code>@Value</code> 或者 <code>Environment</code> 的方式获取外部配置，其代码简洁性以及类型转换灵活性存在明显的不足。因此，Spring Boot  提出了外部化配置（External Configuration）的感念，即通过程序以外的配置源，动态地绑定指定类型。</p>
<p>随着 Spring Boot / Spring Cloud 应用的流行，开发人员逐渐地接受并且使用 Spring Boot 外部化配置（External Configuration），即通过 <code>application.properties</code> 或者 <code>bootstrap.properties</code> 装配配置 Bean。</p>
<p>下列表格记录了 Dubbo 内置配置类：</p>
<table>
<thead>
<tr>
<th>配置类</th>
<th>标签</th>
<th>用途</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ProtocolConfig</code></td>
<td><code>&lt;dubbo:protocol/&gt;</code></td>
<td>协议配置</td>
<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td><code>ApplicationConfig</code></td>
<td><code>&lt;dubbo:application/&gt;</code></td>
<td>应用配置</td>
<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td><code>ModuleConfig</code></td>
<td><code>&lt;dubbo:module/&gt;</code></td>
<td>模块配置</td>
<td>用于配置当前模块信息，可选</td>
</tr>
<tr>
<td><code>RegistryConfig</code></td>
<td><code>&lt;dubbo:registry/&gt;</code></td>
<td>注册中心配置</td>
<td>用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td><code>MonitorConfig</code></td>
<td><code>&lt;dubbo:monitor/&gt;</code></td>
<td>监控中心配置</td>
<td>用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td><code>ProviderConfig</code></td>
<td><code>&lt;dubbo:provider/&gt;</code></td>
<td>提供方配置</td>
<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><code>ConsumerConfig</code></td>
<td><code>&lt;dubbo:consumer/&gt;</code></td>
<td>消费方配置</td>
<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><code>MethodConfig</code></td>
<td><code>&lt;dubbo:method/&gt;</code></td>
<td>方法配置</td>
<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>
</tr>
<tr>
<td><code>ArgumentConfig</code></td>
<td><code>&lt;dubbo:argument/&gt;</code></td>
<td>参数配置</td>
<td>用于指定方法参数配置</td>
</tr>
</tbody></table>
<p>通过申明对应的 Spring 扩展标签，在 Spring 应用上下文中将自动生成相应的配置 Bean。</p>
<p>在 Dubbo 官方用户手册的<a target="_blank" rel="noopener" href="http://dubbo.io/books/dubbo-user-book/configuration/properties.html">“属性配置”</a>章节中，<code>dubbo.properties</code> 配置属性能够映射到  <code>ApplicationConfig</code> 、<code>ProtocolConfig</code> 以及 <code>RegistryConfig</code> 的字段。从某种意义上来说，<code>dubbo.properties</code>  也是 Dubbo 的外部化配置。</p>
<blockquote>
<p>注：更多外部化配置的详情，请参考<a target="_blank" rel="noopener" href="https://github.com/mercyblitz/blogs/blob/master/java/dubbo/Dubbo-Externalized-Configuration.md">《Dubbo 外部化配置（Externalized Configuration）》</a></p>
</blockquote>
<h3 id="现场演示环节"><a href="#现场演示环节" class="headerlink" title="现场演示环节"></a>现场演示环节</h3><blockquote>
<p>本环境为分享后部分，现在编码 + 演示环境，当前文字仅提供代码实现。</p>
</blockquote>
<h4 id="Dubbo-整合-Hystrix-示例"><a href="#Dubbo-整合-Hystrix-示例" class="headerlink" title="Dubbo 整合 Hystrix 示例"></a>Dubbo 整合 Hystrix 示例</h4><blockquote>
<p>本示例出现在分享议程的代码演示，将其放置此处，方便阅读理解</p>
</blockquote>
<h5 id="Dubbo-客户端实现"><a href="#Dubbo-客户端实现" class="headerlink" title="Dubbo 客户端实现"></a>Dubbo 客户端实现</h5><ul>
<li>实现 <code>HystrixCommand</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultHystrixCommand</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(</span><br><span class="line">                <span class="string">&quot;ResultHystrixCommand&quot;</span>),</span><br><span class="line">                <span class="number">100</span>); <span class="comment">// 设置超时时间</span></span><br><span class="line">        <span class="comment">// 关联 Dubbo Invoker 和 Invocation</span></span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 远程方法调用执行</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当目标方法执行时间超过 100 ms 时，触发熔断，并抛出 <code>new UnsupportedOperationException(&quot;No fallback available.&quot;)</code>。</p>
<ul>
<li>Dubbo  <code>Filter</code> 整合 <code>ResultHystrixCommand</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = Constants.CONSUMER, value = &quot;hystrix&quot;)</span> <span class="comment">// 命名当前 Filter 为 &quot;hystrix&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultHystrixCommand(invoker, invocation).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>创建并配置 <code>Filter</code> SPI 配置文件</li>
</ul>
<p>在相对于 ClassPath 资源 <code>META-INF/dubbo/</code> 下创建 <code>com.alibaba.dubbo.rpc.Filter</code>，并配置如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix</span>=<span class="string">com.alibaba.boot.dubbo.demo.consumer.filter.HystrixFilter</span></span><br></pre></td></tr></table></figure>



<ul>
<li>配置 <code>@Reference</code> <code>filter</code> 属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference(</span></span><br><span class="line"><span class="meta">            version = &quot;$&#123;demo.service.version&#125;&quot;,</span></span><br><span class="line"><span class="meta">            application = &quot;$&#123;dubbo.application.id&#125;&quot;,</span></span><br><span class="line"><span class="meta">            url = &quot;dubbo://localhost:12345&quot;,</span></span><br><span class="line"><span class="meta">            filter = &quot;hystrix&quot; // 指向 HystrixFilter 实现</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sayHello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="Dubbo-服务端实现"><a href="#Dubbo-服务端实现" class="headerlink" title="Dubbo 服务端实现"></a>Dubbo 服务端实现</h6><ul>
<li>服务提供者实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(</span></span><br><span class="line"><span class="meta">        version = &quot;$&#123;demo.service.version&#125;&quot;,</span></span><br><span class="line"><span class="meta">        application = &quot;$&#123;dubbo.application.id&#125;&quot;,</span></span><br><span class="line"><span class="meta">        protocol = &quot;dubbo&quot;,</span></span><br><span class="line"><span class="meta">        registry = &quot;$&#123;dubbo.registry.id&#125;&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        hold();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Say : Hello, &quot;</span> + name + <span class="string">&quot; (from Spring Boot)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hold</span><span class="params">()</span> </span>&#123; <span class="comment">// 随机等待 &lt; 200 ms，当时间超过 100 ms 时，触发客户端熔断</span></span><br><span class="line">        <span class="keyword">long</span> time = random.nextInt(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;To hold &quot;</span> + time + <span class="string">&quot; ms!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="测试客户端-REST-服务"><a href="#测试客户端-REST-服务" class="headerlink" title="测试客户端 REST 服务"></a>测试客户端 REST 服务</h5><p>依次启动服务端 和客户端 Spring Boot 应用，</p>
<ul>
<li>执行 <code>curl</code> 命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mercyblitz$ curl http:&#x2F;&#x2F;localhost:8080&#x2F;sayHello?name&#x3D;Hello</span><br></pre></td></tr></table></figure>

<ul>
<li>测试结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:&quot;2018-06-23T01:33:58.682+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;ResultHystrixCommand timed-out and no fallback available.&quot;,&quot;path&quot;:&quot;&#x2F;sayHello&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果说明服务端方法执行超过 100 ms，引起客户端熔断。</p>
<p>（EOF）</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/">Dubbo 官网</a>：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/">https://dubbo.apache.org/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">Dubbo 工程</a>：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo-spring-boot-project">Dubbo Spring Boot 工程</a>：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></li>
<li><a target="_blank" rel="noopener" href="https://landscape.cncf.io/">CNCF Landscape</a>：<a target="_blank" rel="noopener" href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-cloud/">Spring Cloud 官网</a>：<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-cloud/">https://projects.spring.io/spring-cloud/</a></li>
<li><a target="_blank" rel="noopener" href="https://konghq.com/kong-community-edition/">Kong 社区官网</a>：<a target="_blank" rel="noopener" href="https://konghq.com/kong-community-edition/">https://konghq.com/kong-community-edition/</a></li>
<li><a target="_blank" rel="noopener" href="http://opentracing.io/">Opentracing 官网</a>：<a target="_blank" rel="noopener" href="http://opentracing.io/">http://opentracing.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">Jaeger 官网</a>：<a target="_blank" rel="noopener" href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus 官网</a>：<a target="_blank" rel="noopener" href="https://prometheus.io/">https://prometheus.io/</a></li>
<li><a target="_blank" rel="noopener" href="http://opentsdb.net/">OpenTsdb 官网</a>：<a target="_blank" rel="noopener" href="http://opentsdb.net/">http://opentsdb.net/</a></li>
<li><a target="_blank" rel="noopener" href="https://grafana.com/">Grafana 官网</a>：<a target="_blank" rel="noopener" href="https://grafana.com/">https://grafana.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mercyblitz">小马哥 Github</a>：<a target="_blank" rel="noopener" href="https://github.com/mercyblitz">https://github.com/mercyblitz</a> </li>
</ul>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/网络通信/Socket网络编程/">Socket网络编程</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h2 id="更详细的代码及测试方法请参照github项目-https-github-com-RobinLiew-SocketInAction-，测试方法与说明请参照readme"><a href="#更详细的代码及测试方法请参照github项目-https-github-com-RobinLiew-SocketInAction-，测试方法与说明请参照readme" class="headerlink" title="更详细的代码及测试方法请参照github项目 https://github.com/RobinLiew/SocketInAction ，测试方法与说明请参照readme."></a>更详细的代码及测试方法请参照github项目 <a target="_blank" rel="noopener" href="https://github.com/RobinLiew/SocketInAction">https://github.com/RobinLiew/SocketInAction</a> ，测试方法与说明请参照readme.</h2><h3 id="Socket基础类"><a href="#Socket基础类" class="headerlink" title="Socket基础类"></a>Socket基础类</h3><ul>
<li>服务端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.robinliew.basedemo;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 知识要点：</span><br><span class="line"> * 1.无论是服务器端ServerSocket通过accept()方法接收到的Socket，还是客户端连接服务器端的Socket，</span><br><span class="line"> * 在创建输入输出流时不允许两个同时首先创建输入流，否则会堵塞Socket通道。</span><br><span class="line"> * </span><br><span class="line"> * 2.服务器Socket和客户端Socket可以创建多个输入输出流对象，但是两端创建的个数必须保持对应，</span><br><span class="line"> * 即通过客户端Socket创建多少个输入输出流对象，对应的服务器端的ServerSocket通过accepte()方法</span><br><span class="line"> * 接收到Socket也必须创建多少个输入输出流对象，否则抛出java.io.StreamCorruptedException异常。</span><br><span class="line"> * </span><br><span class="line"> * @author RobinLiew</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;专门用来创建Socket服务器的类</span><br><span class="line">			ServerSocket server&#x3D;new ServerSocket(10000);&#x2F;&#x2F;这个服务器使用10000端口号</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * 当一个客户端程序建立一个连接端口号为10000的Socket连接时，</span><br><span class="line">			 * 服务器对象server便响应这个连接，并且用accept()方法创建</span><br><span class="line">			 * 一个Socket对象,服务器端可以利用这个对象与客户端通讯。</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			Socket socketServer&#x3D;server.accept();</span><br><span class="line">			&#x2F;&#x2F;输入流和输出流的封装</span><br><span class="line">			BufferedReader in&#x3D;new BufferedReader(new InputStreamReader(socketServer.getInputStream()));</span><br><span class="line">			PrintWriter out&#x3D;new PrintWriter(socketServer.getOutputStream(),true);</span><br><span class="line">			&#x2F;&#x2F;得到客户端的输入</span><br><span class="line">			String inFromClient&#x3D;in.readLine();</span><br><span class="line">			&#x2F;&#x2F;向客户端发送数据</span><br><span class="line">			out.println();</span><br><span class="line">			&#x2F;&#x2F;关闭两个数据流</span><br><span class="line">			out.close();</span><br><span class="line">			in.close();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.robinliew.basedemo;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 代码中这两个方法read()和readLine()都会读取对端发送过来的数据，如果无数据可读，就会阻塞直到有数据可读。或者到达流的末尾，这个时候分别返回-1和null。</span><br><span class="line"> *	这个特性使得编程非常方便也很高效。</span><br><span class="line"> *	但是这样也有一个问题，就是如何让程序从这两个方法的阻塞调用中返回。</span><br><span class="line"> *</span><br><span class="line"> *	总结一下，有这么几个方法：</span><br><span class="line"> *	1）发送完后调用Socket的shutdownOutput()方法关闭输出流，这样对端的输入流上的read操作就会返回-1。</span><br><span class="line"> *	注意不能调用socket.getInputStream().close()。这样会导致socket被关闭。</span><br><span class="line"> *	当然如果不需要继续在socket上进行读操作，也可以直接关闭socket。</span><br><span class="line"> *	但是这个方法不能用于通信双方需要多次交互的情况。</span><br><span class="line"> *</span><br><span class="line"> *	2）发送数据时，约定数据的首部固定字节数为数据长度。这样读取到这个长度的数据后，就不继续调用read方法。</span><br><span class="line"> *</span><br><span class="line"> *	3）为了防止read操作造成程序永久挂起，还可以给socket设置超时。</span><br><span class="line"> *	如果read()方法在设置时间内没有读取到数据，就会抛出一个java.net.SocketTimeoutException异常。</span><br><span class="line"> *	例如下面的方法设定超时3秒。</span><br><span class="line"> *	socket.setSoTimeout(3000);</span><br><span class="line"> * </span><br><span class="line"> * @author RobinLiew</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ClientDemo &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * 客户端需要用服务器所在机器的ip以及服务器的端口作为参数创建一个Socket对象</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			Socket socket &#x3D; new Socket(&quot;10.10.40.59&quot;,10000);</span><br><span class="line">			BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));  </span><br><span class="line">			PrintWriter out &#x3D; new PrintWriter(socket.getOutputStream(),true); </span><br><span class="line">			&#x2F;&#x2F;得到服务端的输入</span><br><span class="line">			String inFromServer&#x3D;in.readLine();</span><br><span class="line">			&#x2F;&#x2F;向服务端发送数据</span><br><span class="line">			out.println();</span><br><span class="line">			&#x2F;&#x2F;关闭两个数据流</span><br><span class="line">			out.close();</span><br><span class="line">			in.close();</span><br><span class="line">		&#125; catch (UnknownHostException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;  </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Socket设置字符流的编码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.robinliew.basedemo2;</span><br><span class="line"></span><br><span class="line">import java.io.DataInputStream;   </span><br><span class="line">import java.io.DataOutputStream;   </span><br><span class="line">import java.io.IOException;   </span><br><span class="line">import java.net.ServerSocket;   </span><br><span class="line">import java.net.Socket; </span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 注意：</span><br><span class="line"> * 1.Socket的发送与接收是需要同步进行的，即客户端发送一条信息，服务器必需先接收这条信息，   </span><br><span class="line">* 而后才可以向客户端发送信息，否则将会有运行时出错。   </span><br><span class="line">* </span><br><span class="line">* 2.注意这里我们前面的例子处理字符流默认使用Unicode编码，这里通过</span><br><span class="line">* writeUTF在写入数据流的时候会加上两个字节以表示字节的长度，且使用UTF-8编码。</span><br><span class="line"> * @author RobinLiew</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerDemoUTF &#123;</span><br><span class="line">	public static void main(String[] args) &#123;   </span><br><span class="line">		ServerSocket ss &#x3D; null;   </span><br><span class="line">		try &#123;   </span><br><span class="line">			ss &#x3D; new ServerSocket(10002);   </span><br><span class="line">			&#x2F;&#x2F;服务器接收到客户端的数据后，创建与此客户端对话的Socket   </span><br><span class="line">			Socket socket &#x3D; ss.accept();   </span><br><span class="line">			&#x2F;&#x2F;用于向客户端发送数据的输出流   </span><br><span class="line">			DataOutputStream dos &#x3D; new DataOutputStream(socket.getOutputStream());   </span><br><span class="line">			&#x2F;&#x2F;用于接收客户端发来的数据的输入流   </span><br><span class="line">			DataInputStream dis &#x3D; new DataInputStream(socket.getInputStream());   </span><br><span class="line">			System.out.println(&quot;服务器接收到客户端的连接请求：&quot; + dis.readUTF());   </span><br><span class="line">			&#x2F;&#x2F;服务器向客户端发送连接成功确认信息   </span><br><span class="line">			dos.writeUTF(&quot;接受连接请求，连接成功!&quot;);   </span><br><span class="line">			&#x2F;&#x2F;不需要继续使用此连接时，关闭连接   </span><br><span class="line">			socket.close();   </span><br><span class="line">			ss.close();   </span><br><span class="line">		&#125; catch (IOException e) &#123;   </span><br><span class="line">			e.printStackTrace();   </span><br><span class="line">		&#125;   </span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Socket URL通讯</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.robinliew.basedemo2;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;  </span><br><span class="line">import java.io.BufferedWriter;  </span><br><span class="line">import java.io.File;  </span><br><span class="line">import java.io.FileWriter;  </span><br><span class="line">import java.io.InputStreamReader;  </span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * basedemo中的例子中客户端的知道服务端的IP地址与端口号后可以与其进行通信，但如果我们只知道网络URL地址，不知道IP呢？</span><br><span class="line"> * </span><br><span class="line"> * 在JAVA中，Java.net包里面的类是进行网络编程的，其中java.net.URL类和java.net.URLConection类使编程者方便地</span><br><span class="line"> * 利用URL在Internet上进行网络通信。</span><br><span class="line"> * </span><br><span class="line"> * @author RobinLiew</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class URLReader &#123;  </span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;构建一URL对象</span><br><span class="line">		URL tirc &#x3D; new URL(&quot;https:&#x2F;&#x2F;robinliew.github.io&#x2F;&quot;);  </span><br><span class="line">		&#x2F;&#x2F;用于存放服务器返回的数据</span><br><span class="line">		File writeFile &#x3D; new File(&quot;d:\\information.html&quot;);  </span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 使用openStream得到一输入流并由此构造一个BufferedReader对象 </span><br><span class="line">		BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(tirc.openStream()));  </span><br><span class="line">		BufferedWriter bos &#x3D; new BufferedWriter(new FileWriter(writeFile));  </span><br><span class="line">		 </span><br><span class="line">		String inputLine;  </span><br><span class="line">		 </span><br><span class="line">		while ((inputLine &#x3D; in.readLine()) !&#x3D; null)&#123;  </span><br><span class="line">			bos.write(inputLine);  </span><br><span class="line">			System.out.println(inputLine);  </span><br><span class="line">		&#125;  </span><br><span class="line">		bos.flush();  </span><br><span class="line">		in.close();  </span><br><span class="line">		bos.close();  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">- Socket服务端与客户端交互</span><br><span class="line">服务端</span><br></pre></td></tr></table></figure>
<p>package com.robinliew.basethreaddemo;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p>
<p>/**</p>
<ul>
<li><p>ServerDemo的例子是单线程的，只能服务一个客户，现将其改为多线程</p>
</li>
<li><p>@author RobinLiew</p>
</li>
<li></li>
<li><p>/<br>public class ServerThread extends Thread{</p>
<p>  public ServerThread(Socket socketServer, int i) {</p>
<pre><code>  System.out.println(&quot;这是第：&quot;+i+&quot;个Socket！&quot;);</code></pre>
<p>  }</p>
<p>  public void run() {</p>
<pre><code>  try&#123;

      ServerSocket server = new ServerSocket(10000);  
      int i=0;
      //循环检测是否有客户连接到服务器上，如果有，则创建一个线程来服务这个客户
      for(;;)&#123;
          Socket socketServer = server.accept();
          new ServerThread(socketServer,i);
          i++;

          //输入流和输出流的封装
          final BufferedReader in=new BufferedReader(new InputStreamReader(socketServer.getInputStream()));
          final PrintWriter out=new PrintWriter(socketServer.getOutputStream(),true);

          out.println(&quot;这是服务端向客户端的第：&quot;+i+&quot;次响应！&quot;);

          //为了可以随时得到客户端传过来消息，创建该线程
          new Thread()&#123;
              public void run() &#123;
                  while(true)&#123;
                      checkInput(in);
                      try &#123;
                          sleep(1000);//每1000毫秒检测一次
                      &#125; catch (InterruptedException e) &#123;
                          e.printStackTrace();
                      &#125;
                  &#125;
              &#125;
          &#125;.start();

          out.close();
          in.close();
      &#125;

  &#125;catch (IOException e)&#123;
      e.printStackTrace(); 
  &#125;   </code></pre>
<p>  }</p>
<p>  private void checkInput(BufferedReader in) {</p>
<pre><code>  String line;  
  try&#123;
      if((line=in.readLine())!=null)&#123;
          //检测输入流中是否有新的数据  
          //将数据流中的消息显示出来 
      &#125;
  &#125;catch(Exception e)&#123;

  &#125; </code></pre>
<p>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.robinliew.basethreaddemo;</p>
<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStreamReader;<br>import java.io.PrintWriter;<br>import java.net.Socket;<br>import java.net.UnknownHostException;</p>
<p>/**</p>
<ul>
<li><p>为了和ServerThread配合使用</p>
</li>
<li><p>@author RobinLiew</p>
</li>
<li></li>
<li><p>/<br>public class ClientThread extends Thread {</p>
<p>  public void run() {</p>
<pre><code>  try &#123;
      //模拟10个客户端向服务端发送数据
      for(int i=0;i&lt;10;i++)&#123;
          Socket socket = new Socket(&quot;10.10.40.59&quot;,10000);
          final BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));  
          PrintWriter out = new PrintWriter(socket.getOutputStream(),true); 

          out.println(&quot;这是第：&quot;+i+&quot;个客户向服务端发送数据！&quot;);

          //为了可以随时得到服务端返回的消息，创建该线程
          new Thread()&#123;
              public void run() &#123;
                  while(true)&#123;
                      //检查服务端返回的信息
                      checkInput(in);
                      try &#123;
                          sleep(1000);//每1000毫秒检测一次
                      &#125; catch (InterruptedException e) &#123;
                          e.printStackTrace();
                      &#125;
                  &#125;
              &#125;
          &#125;.start();

          out.close();
          in.close();
      &#125;
  &#125; catch (UnknownHostException e) &#123;
      e.printStackTrace();
  &#125; catch (IOException e) &#123;
      e.printStackTrace();
  &#125;</code></pre>
<p>  }</p>
<p>  private void checkInput(BufferedReader in) {</p>
<pre><code>  String line;  
  try&#123;
      if((line=in.readLine())!=null)&#123;
          //检测输入流中是否有新的数据  
          //将数据流中的消息显示出来 
      &#125;
  &#125;catch(Exception e)&#123;

  &#125; </code></pre>
<p>  }<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Socket多线程一般设计原则</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.robinliew.basethreaddemo;</p>
<p>import java.io.<em>;<br>import java.net.</em>;<br>import java.util.<em>;<br>import java.lang.</em>; </p>
<p>/**</p>
<ul>
<li><p>Java Socket线程的设计原理：</p>
</li>
<li><p>1.服务器端接受客户端的连接请求，同时启动一个线程处理这个连接，线程不停的读取客户端输入，然后把输入加入队列中，等候处理。</p>
</li>
<li><p>2.在线程启动的同时将线程加入队列中，以便在需要的时候定位和取出。</p>
</li>
<li></li>
<li><p>下面是一个简易聊天室的例子</p>
</li>
<li><p>@author RobinLiew</p>
</li>
<li></li>
<li><p>/<br>public class Server extends ServerSocket   {<br>  private static ArrayList User_List = new ArrayList();<br>  private static ArrayList Threader = new ArrayList();<br>  private static LinkedList Message_Array = new LinkedList();<br>  private static int Thread_Counter = 0;<br>  private static boolean isClear = true;<br>  protected static final int SERVER_PORT = 10000;<br>  protected FileOutputStream LOG_FILE = new FileOutputStream(“d:/connect.log”, true);<br>  public Server() throws FileNotFoundException, IOException   {   </p>
<pre><code>  super(SERVER_PORT);   
  new Broadcast();   
  //append connection log   
  Calendar now = Calendar.getInstance();   
  String str = &quot;[&quot; + now.getTime().toString() + &quot;] Accepted a connection&quot;;   
  byte[] tmp = str.getBytes();   
  LOG_FILE.write(tmp);   
  try &#123;   
      while (true) &#123;   
          Socket socket = accept();   
          new CreateServerThread(socket);   
      &#125;   
  &#125;finally &#123;   
      close();   
  &#125;   </code></pre>
<p>  }<br>  public static void main(String[] args) throws IOException {   </p>
<pre><code>  new Server();   </code></pre>
<p>  }<br>  //Broadcast处理存放消息的队列<br>  class Broadcast extends Thread {   </p>
<pre><code>  public Broadcast() &#123;   
      start();   
  &#125;   
  public void run() &#123;   
      while (true) &#123;   
          if (!isClear)&#123;   
              String tmp = (String)Message_Array.getFirst();   
              for (int i = 0; i &lt; Threader.size(); i++) &#123;   
                  CreateServerThread client = (CreateServerThread)Threader.get(i);   
                  client.sendMessage(tmp);   
              &#125;  
              Message_Array.removeFirst();   
              isClear = Message_Array.size() &gt; 0 ? false : true;   
          &#125;   
      &#125;   
  &#125;   </code></pre>
<p>  }<br>  //— CreateServerThread<br>  class CreateServerThread extends Thread {   </p>
<pre><code>  private Socket client;   
  private BufferedReader in;   
  private PrintWriter out;   
  private String Username;   
  public CreateServerThread(Socket s) throws IOException &#123;   
      client = s;   
      in = new BufferedReader(new InputStreamReader(client.getInputStream()));   
      out = new PrintWriter(client.getOutputStream(), true);   
      out.println(&quot;--- Welcome to this chatroom ---&quot;);   
      out.println(&quot;Input your nickname:&quot;);   
      start();   
  &#125;   
  public void sendMessage(String msg) &#123;   
      out.println(msg);   
  &#125;   
  public void run() &#123;   
      try &#123;   
          int flag = 0;   
          Thread_Counter++;   
          String line = in.readLine();   
          while (!line.equals(&quot;bye&quot;)) &#123;   
              if (line.equals(&quot;l&quot;)) &#123;   
                  out.println(listOnlineUsers());   
                  line = in.readLine();   
                  continue;   
              &#125;   
              if (flag++ == 0) &#123;   
                  Username = line;   
                  User_List.add(Username);   
                  out.println(listOnlineUsers());   
                  Threader.add(this);   
                  pushMessage(&quot;[&lt; &quot; + Username + &quot; come on in &gt;]&quot;);   
              &#125; else &#123;   
                  pushMessage(&quot;&lt;&quot; + Username + &quot;&gt;&quot; + line);   
              &#125;   
              line = in.readLine();   
          &#125;   
          out.println(&quot;--- See you, bye! ---&quot;);   
          client.close();   
      &#125;catch (IOException e) &#123;

      &#125;finally &#123;   
          try &#123;  
              client.close();   
          &#125; catch (IOException e) &#123;

          &#125;   
          Thread_Counter--;   
          Threader.remove(this);   
          User_List.remove(Username);   
          pushMessage(&quot;[&lt; &quot; + Username + &quot; left&gt;]&quot;);   
      &#125;   
  &#125;   
  private String listOnlineUsers() &#123;   
      String s =&quot;-+- Online list -+-1512&quot;;   
      for (int i = 0; i &lt; User_List.size(); i++) &#123;   
          s += &quot;[&quot; + User_List.get(i) + &quot;]&quot;;   
      &#125;   
      s += &quot;-+---------------------+-&quot;;   
      return s;   
  &#125;   
  private void pushMessage(String msg)   &#123;   
      Message_Array.addLast(msg);   
      isClear = false;   
  &#125;   </code></pre>
<p>  }<br>}  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Socket传输的序列化对象介绍</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.robinliew.transferdemo;</p>
<p>import java.io.ByteArrayInputStream;<br>import java.io.ByteArrayOutputStream;<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.io.OutputStream;<br>import java.util.Date; </p>
<p>/**</p>
<ul>
<li>序列化是一种对象持久化的手段。普遍应用在网络传输、RMI等场景中.</li>
<li></li>
<li>序列化与反序列化：</li>
<li></li>
<li>1.只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。</li>
<li></li>
<li>2.通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化。</li>
<li></li>
<li>3.虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</li>
<li></li>
<li>4.序列化并不保存静态变量。</li>
<li></li>
<li>5.要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</li>
<li></li>
<li>6.Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，</li>
<li>在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</li>
<li></li>
<li>7.服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，</li>
<li>而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
<li></li>
<li></li>
<li>这个例子是用文件持久化展示，Socket传输中亦是如此。</li>
<li>@author RobinLiew</li>
<li></li>
<li>/<br>public class Persistence {<br>  public static void main(String[] args) {  <pre><code>  Persistence.savePerson();  
  Persistence.getPerson();  </code></pre>
  }<br>  public static void getPerson() {  <pre><code>  try &#123;  
      InputStream in = new FileInputStream(&quot;d:\\person.dat&quot;);  
      ObjectInputStream dataInput = new ObjectInputStream(in);  
      Person p = (Person) dataInput.readObject();  
      System.out.println(p.getName());  
      System.out.println(p.getTall());  
      System.out.println(p.getBirthday());  
      System.out.println(p.getAddress().getCity());  
      System.out.println(p.getAddress().getStreet());  
  &#125; catch (Exception e) &#123;  
  // TODO Auto-generated catch block  
      e.printStackTrace();  
  &#125;  </code></pre>
  }<br>  public static void savePerson() {  <pre><code>  Person p = new Person();  
  p.setName(&quot;Robin Liew&quot;);  
  p.setTall(176);  
  p.setBirthday(new Date());  
  p.setAddress(new Address(&quot;xian&quot;, &quot;tumen&quot;));  
  OutputStream out = new ByteArrayOutputStream();  
  try &#123;  
      OutputStream fileOut = new FileOutputStream(new File(  
      &quot;d:\\person.dat&quot;));  
      ObjectOutputStream dataOut = new ObjectOutputStream(fileOut);  
      dataOut.writeObject(p);  
      dataOut.close();  
      fileOut.close();  
  &#125; catch (IOException e) &#123;  
  // TODO Auto-generated catch block  
      e.printStackTrace();  
  &#125;  </code></pre>
  }<br>}  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Socket网络交互的例子</span><br><span class="line">- 单线程</span><br><span class="line">	- 服务端</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>package com.robinliew.inaction.singlethread;

import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.ServerSocket;  
import java.net.Socket;  

/**
 * Server类，这个类用来监听10000端口，并从这个端口接收消息然后输出，当收到“bye”时退出。
 * @author RobinLiew
 *
 */
public class MyServer &#123;  
    public static void main(String[] args) throws IOException &#123;  
        ServerSocket server = new ServerSocket(10000);  
        Socket socket = server.accept();  
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));  
        PrintWriter out = new PrintWriter(socket.getOutputStream());  

        while (true) &#123;  
            String msg = in.readLine();  
            System.out.println(msg);  
            out.println(&quot;Server received &quot; + msg);  
            out.flush();  
            if (msg.equals(&quot;bye&quot;)) &#123;  
                break;  
            &#125;  
        &#125;  
        socket.close();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.singlethread;

import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.Socket;  

/**
 * 一个Client类，这个类连接上面启动的Server类，然后接收任何用户输入，当遇到回车时发送字符串到Server上，当输入“bye”是退出。
 * @author RobinLiew
 *
 */
public class MyClient &#123;  
    public static void main(String[] args) throws Exception &#123;  
        //注意创建Socket除了使用IP+port的形式，还可以用 服务器主机名+port的形式
        Socket socket = new Socket(&quot;localhost&quot;, 10000);  
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));  
        PrintWriter out = new PrintWriter(socket.getOutputStream());  
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  

        while (true) &#123;  
            String msg = reader.readLine();  
            out.println(msg);  
            out.flush();  
            if (msg.equals(&quot;bye&quot;)) &#123;  
                break;  
            &#125;  
            System.out.println(in.readLine());  
        &#125;  
        socket.close();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 多线程</span><br><span class="line">	- 服务端</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.multithread;

import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.ServerSocket;  
import java.net.Socket;  

/**
 * singlethread包中的例子有一个问题就是Server只能接受一个Client请求，当第一个Client连接后就占据了这个位置，后续Client不能再继续连接，所以需要做些改动，
 * 当Server没接受到一个Client连接请求之后，都把处理流程放到一个独立的线程里去运行，然后等待下一个Client连接请求，这样就不会阻塞Server端接收请求了。
 * 每个独立运行的程序在使用完Socket对象之后要将其关闭。
 * 
 * @author RobinLiew
 *
 */
public class MyServer &#123;  
    public static void main(String[] args) throws IOException &#123;  
        ServerSocket server = new ServerSocket(10000);  

        while (true) &#123;  
            Socket socket = server.accept();  
            invoke(socket);  
        &#125;  
    &#125;  

    private static void invoke(final Socket client) throws IOException &#123;  
        new Thread(new Runnable() &#123;  
            public void run() &#123;  
                BufferedReader in = null;  
                PrintWriter out = null;  
                try &#123;  
                    in = new BufferedReader(new InputStreamReader(client.getInputStream()));  
                    out = new PrintWriter(client.getOutputStream());  

                    while (true) &#123;  
                        String msg = in.readLine();  
                        System.out.println(msg);  
                        out.println(&quot;Server received &quot; + msg);  
                        out.flush();  
                        if (msg.equals(&quot;bye&quot;)) &#123;  
                            break;  
                        &#125;  
                    &#125;  
                &#125; catch(IOException ex) &#123;  
                    ex.printStackTrace();  
                &#125; finally &#123;  
                    try &#123;  
                        in.close();  
                    &#125; catch (Exception e) &#123;&#125;  
                    try &#123;  
                        out.close();  
                    &#125; catch (Exception e) &#123;&#125;  
                    try &#123;  
                        client.close();  
                    &#125; catch (Exception e) &#123;&#125;  
                &#125;  
            &#125;  
        &#125;).start();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 客户端</span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.singlethread;

import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.io.PrintWriter;  
import java.net.Socket;  

/**
 * 一个Client类，这个类连接上面启动的Server类，然后接收任何用户输入，当遇到回车时发送字符串到Server上，当输入“bye”是退出。
 * @author RobinLiew
 *
 */
public class MyClient &#123;  
    public static void main(String[] args) throws Exception &#123;  
        //注意创建Socket除了使用IP+port的形式，还可以用 服务器主机名+port的形式
        Socket socket = new Socket(&quot;localhost&quot;, 10000);  
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));  
        PrintWriter out = new PrintWriter(socket.getOutputStream());  
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  

        while (true) &#123;  
            String msg = reader.readLine();  
            out.println(msg);  
            out.flush();  
            if (msg.equals(&quot;bye&quot;)) &#123;  
                break;  
            &#125;  
            System.out.println(in.readLine());  
        &#125;  
        socket.close();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Socket传输对象</span><br><span class="line">- 传输序列化对象</span><br><span class="line">	- 服务端</span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferobject;

import java.io.*;  
import java.net.ServerSocket;  
import java.net.Socket;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

/**
 * 使用Java Socket来传输对象
 * @author RobinLiew
 *
 */
public class MyServer &#123;  

    private final static Logger logger = Logger.getLogger(MyServer.class.getName());  

    public static void main(String[] args) throws IOException &#123;  
        ServerSocket server = new ServerSocket(10000);  

        while (true) &#123;  
            Socket socket = server.accept();  
            invoke(socket);  
        &#125;  
    &#125;  

    private static void invoke(final Socket socket) throws IOException &#123;  
        new Thread(new Runnable() &#123;  
            public void run() &#123;  
                ObjectInputStream is = null;  
                ObjectOutputStream os = null;  
                try &#123;  
                    is = new ObjectInputStream(new BufferedInputStream(socket.getInputStream()));  
                    os = new ObjectOutputStream(socket.getOutputStream());  

                    Object obj = is.readObject();  
                    User user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  

                    user.setName(user.getName() + &quot;_new&quot;);  
                    user.setPassword(user.getPassword() + &quot;_new&quot;);  

                    os.writeObject(user);  
                    os.flush();  
                &#125; catch (IOException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; catch(ClassNotFoundException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; finally &#123;  
                    try &#123;  
                        is.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        os.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        socket.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                &#125;  
            &#125;  
        &#125;).start();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 客户端</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferobject;

import java.io.BufferedInputStream;  
import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  
import java.net.Socket;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

/**
 * 使用Java Socket来传输对象
 * @author RobinLiew
 *
 */
public class MyClient &#123;  

    private final static Logger logger = Logger.getLogger(MyClient.class.getName());  

    public static void main(String[] args) throws Exception &#123;  
        for (int i = 0; i &lt; 100; i++) &#123;  
            Socket socket = null;  
            ObjectOutputStream os = null;  
            ObjectInputStream is = null;  

            try &#123;  
                socket = new Socket(&quot;localhost&quot;, 10000);  

                os = new ObjectOutputStream(socket.getOutputStream());  
                User user = new User(&quot;user_&quot; + i, &quot;password_&quot; + i);  
                os.writeObject(user);  
                os.flush();  

                is = new ObjectInputStream(new BufferedInputStream(socket.getInputStream()));  
                Object obj = is.readObject();  
                if (obj != null) &#123;  
                    user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  
                &#125;  
            &#125; catch(IOException ex) &#123;  
                logger.log(Level.SEVERE, null, ex);  
            &#125; finally &#123;  
                try &#123;  
                    is.close();  
                &#125; catch(Exception ex) &#123;&#125;  
                try &#123;  
                    os.close();  
                &#125; catch(Exception ex) &#123;&#125;  
                try &#123;  
                    socket.close();  
                &#125; catch(Exception ex) &#123;&#125;  
            &#125;  
        &#125;  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 传输压缩对象</span><br><span class="line">	- 服务端</span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferGZIPobject;

import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  
import java.net.ServerSocket;  
import java.net.Socket;  
import java.util.logging.Level;  
import java.util.logging.Logger;  
import java.util.zip.GZIPInputStream;  
import java.util.zip.GZIPOutputStream;  

/**
 * transfer包中用Java Socket来传输对象，但是在有些情况下比如网络环境不好或者对象比较大的情况下需要把数据对象进行压缩然后在传输，
 * 此时就需要压缩这些对象流，此时就可以GZIPInputStream和GZIPOutputStream来处理一下socket的InputStream和OutputStream。
 * @author RobinLiew
 *
 */
public class MyServer &#123;  

    private final static Logger logger = Logger.getLogger(MyServer.class.getName());  

    public static void main(String[] args) throws IOException &#123;  
        ServerSocket server = new ServerSocket(10000);  

        while (true) &#123;  
            Socket socket = server.accept();  
            socket.setSoTimeout(10 * 1000);  
            invoke(socket);  
        &#125;  
    &#125;  

    private static void invoke(final Socket socket) throws IOException &#123;  
        new Thread(new Runnable() &#123;  
            public void run() &#123;  
                GZIPInputStream gzipis = null;  
                ObjectInputStream ois = null;  
                GZIPOutputStream gzipos = null;  
                ObjectOutputStream oos = null;  

                try &#123;  
                    gzipis = new GZIPInputStream(socket.getInputStream());  
                    ois = new ObjectInputStream(gzipis);  
                    gzipos = new GZIPOutputStream(socket.getOutputStream());  
                    oos = new ObjectOutputStream(gzipos);  

                    Object obj = ois.readObject();  
                    User user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  

                    user.setName(user.getName() + &quot;_new&quot;);  
                    user.setPassword(user.getPassword() + &quot;_new&quot;);  

                    oos.writeObject(user);  
                    oos.flush();  
                    gzipos.finish();  
                &#125; catch (IOException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; catch(ClassNotFoundException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; finally &#123;  
                    try &#123;  
                        ois.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        oos.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        socket.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                &#125;  
            &#125;  
        &#125;).start();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 客户端</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferGZIPobject;

import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  
import java.net.InetSocketAddress;  
import java.net.Socket;  
import java.net.SocketAddress;  
import java.util.logging.Level;  
import java.util.logging.Logger;  
import java.util.zip.GZIPInputStream;  
import java.util.zip.GZIPOutputStream;  

/**
 * Client也和Server端类似，同样要不socket的XXXStream包装成GZIPXXXStream，然后再包装成ObjectXXXStream
 * @author RobinLiew
 *
 */
public class MyClient &#123;  

    private final static Logger logger = Logger.getLogger(MyClient.class.getName());  

    public static void main(String[] args) throws Exception &#123;  
        for (int i = 0; i &lt; 10; i++) &#123;  
            Socket socket = null;  
            GZIPOutputStream gzipos = null;  
            ObjectOutputStream oos = null;  
            GZIPInputStream gzipis = null;  
            ObjectInputStream ois = null;  

            try &#123;  
                socket = new Socket();  
                SocketAddress socketAddress = new InetSocketAddress(&quot;localhost&quot;, 10000);   
                socket.connect(socketAddress, 10 * 1000);  
                socket.setSoTimeout(10 * 1000);  

                gzipos = new GZIPOutputStream(socket.getOutputStream());  
                oos = new ObjectOutputStream(gzipos);  
                User user = new User(&quot;user_&quot; + i, &quot;password_&quot; + i);  
                oos.writeObject(user);  
                oos.flush();  
                gzipos.finish();  

                gzipis = new GZIPInputStream(socket.getInputStream());  
                ois = new ObjectInputStream(gzipis);  
                Object obj = ois.readObject();  
                if (obj != null) &#123;  
                    user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  
                &#125;  
            &#125; catch(IOException ex) &#123;  
                logger.log(Level.SEVERE, null, ex);  
            &#125;  
            try &#123;  
                oos.close();  
            &#125; catch (IOException e) &#123;  
            &#125;  
            try &#123;  
                ois.close();  
            &#125; catch (IOException e) &#123;  
            &#125;  
            try &#123;  
                socket.close();  
            &#125; catch (IOException e) &#123;  
            &#125;  
        &#125;  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 传输加密对象</span><br><span class="line">	- 服务端</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferSSLobject;

import java.io.BufferedInputStream;  
import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  
import java.net.ServerSocket;  
import java.net.Socket;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

import javax.net.ServerSocketFactory;  
import javax.net.ssl.SSLServerSocketFactory;  

/**
 * 这里需要用到ServerSocketFactory类来创建SSLServerSocket类实例，然后在通过SSLServerSocket来获取SSLSocket实例，
 * 这里考虑到面向对象中的面向接口编程的理念，所以代码中并没有出现SSLServerSocket和SSLSocket，而是用了他们的父类ServerSocket和Socket。
 * 在获取到ServerSocket和Socket实例以后，剩下的代码就和不使用加密方式一样了。
 * @author RobinLiew
 *
 */
public class MyServer &#123;  

    private final static Logger logger = Logger.getLogger(MyServer.class.getName());  

    public static void main(String[] args) &#123;  
        try &#123;  
            ServerSocketFactory factory = SSLServerSocketFactory.getDefault();  
            ServerSocket server = factory.createServerSocket(10000);  

            while (true) &#123;  
                Socket socket = server.accept();  
                invoke(socket);  
            &#125;  
        &#125; catch (Exception ex) &#123;  
            ex.printStackTrace();  
        &#125;  
    &#125;  

    private static void invoke(final Socket socket) throws IOException &#123;  
        new Thread(new Runnable() &#123;  
            public void run() &#123;  
                ObjectInputStream is = null;  
                ObjectOutputStream os = null;  
                try &#123;  
                    is = new ObjectInputStream(new BufferedInputStream(socket.getInputStream()));  
                    os = new ObjectOutputStream(socket.getOutputStream());  

                    Object obj = is.readObject();  
                    User user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  

                    user.setName(user.getName() + &quot;_new&quot;);  
                    user.setPassword(user.getPassword() + &quot;_new&quot;);  

                    os.writeObject(user);  
                    os.flush();  
                &#125; catch (IOException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; catch(ClassNotFoundException ex) &#123;  
                    logger.log(Level.SEVERE, null, ex);  
                &#125; finally &#123;  
                    try &#123;  
                        is.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        os.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                    try &#123;  
                        socket.close();  
                    &#125; catch(Exception ex) &#123;&#125;  
                &#125;  
            &#125;  
        &#125;).start();  
    &#125;  
&#125; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 客户端</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
package com.robinliew.inaction.transferSSLobject;

import java.io.BufferedInputStream;  
import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  
import java.net.Socket;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

import javax.net.SocketFactory;  
import javax.net.ssl.SSLSocketFactory;  

public class MyClient &#123;  

private final static Logger logger = Logger.getLogger(MyClient.class.getName());  

    public static void main(String[] args) throws Exception &#123;  
        for (int i = 0; i &lt; 100; i++) &#123;  
            Socket socket = null;  
            ObjectOutputStream os = null;  
            ObjectInputStream is = null;  

            try &#123;  
                SocketFactory factory = SSLSocketFactory.getDefault();  
                socket = factory.createSocket(&quot;localhost&quot;, 10000);  

                os = new ObjectOutputStream(socket.getOutputStream());  
                User user = new User(&quot;user_&quot; + i, &quot;password_&quot; + i);  
                os.writeObject(user);  
                os.flush();  

                is = new ObjectInputStream(new BufferedInputStream(socket.getInputStream()));  
                Object obj = is.readObject();  
                if (obj != null) &#123;  
                    user = (User)obj;  
                    System.out.println(&quot;user: &quot; + user.getName() + &quot;/&quot; + user.getPassword());  
                &#125;  
            &#125; catch(IOException ex) &#123;  
                logger.log(Level.SEVERE, null, ex);  
            &#125; finally &#123;  
                try &#123;  
                    is.close();  
                &#125; catch(Exception ex) &#123;&#125;  
                try &#123;  
                    os.close();  
                &#125; catch(Exception ex) &#123;&#125;  
                try &#123;  
                    socket.close();  
                &#125; catch(Exception ex) &#123;&#125;  
            &#125;  
        &#125;  
    &#125;  
&#125; 

```</code></pre>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/网络通信/TCP_IP详解/">TCP_IP详解</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <p>注意：图片中的文字看起来有些小，不是很清楚，可以单击右键，选择点击“查看图像”，然后放大图像即可查看清晰的文字。</p>
<p><img src="http://img.blog.csdn.net/20171205200108454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<title>TCP-IP详解卷1</title>
</head>
<body>
<h1 align="center" class="root">
<a name="3touudo3fl6uca57ncjpi00kdc">TCP-IP详解卷1</a>
</h1>
<div align="center" class="globalOverview">
<img src="TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71_files/images/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71.jpg"></div>
<h2 class="topic">
<a name="18q1clk040hbs1q74rgqsv5ds4">第1章：概述</a>
</h2>
<h3 class="topic">
<a name="258lfpsrhcq1fq3qfu6fr1ulmf">&nbsp;1.TCP/IP分层：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="79lpnk3js14j2f9bd1u7ni7nj3">&nbsp;&nbsp;A.应用层（Telent：远程登录、FTP、e-mail等）；</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5orjh07dtuj6mtppsbgeqtf14l">&nbsp;&nbsp;B.运输层（TCP和UDP）；</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5lqr5tffdp595fc9inq9vchmj7">&nbsp;&nbsp;C.网络层（IP、ICMP、IGMP）；</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="023qdirtll8019se93e7gd7960">&nbsp;&nbsp;D.链路层（设备驱动程序及接口卡、ARP和RARP）</a>
</h3>
<h3 class="topic">
<a name="6njlemgs4eku99thghfn255f4b">&nbsp;2.端系统（例，两台主机）和中间系统（中间的路由器）。应用层和传输层使用端到端协议（End-to-end），网络层提供逐跳协议(Hop-by-hop)。</a>
</h3>
<h3 class="topic">
<a name="5rkp595gic1kv5jdsbdeoa2ih6">&nbsp;3.ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</a>
</h3>
<h3 class="topic">
<a name="4ajelbiq6e0h1f15c0lc0qcgvh">&nbsp;4.IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</a>
</h3>
<h3 class="topic">
<a name="297cnujg88uoj220pin624umqg">&nbsp;5.ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来装换IP层和网络层使用的地址。</a>
</h3>
<h3 class="topic">
<a name="2tte8m3rsgqc7iqk14bg2bdopg">&nbsp;6.互联网地址。A、B、C、D、E五类互联网地址。结构：头标志+网络号+主机号</a>
</h3>
<h3 class="topic">
<a name="1bp2ee61sg8o9tgb5m5dd906a2">&nbsp;7.三类IP地址：单播地址（目的为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）</a>
</h3>
<h3 class="topic">
<a name="1ef2f994u5j036bsm7402bhhbc">&nbsp;8.域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</a>
</h3>
<h3 class="topic">
<a name="0kg7l686ah3vvla6p15mtc8rjd">&nbsp;9.封装：TCP报文段（或TCP段）-&gt; IP数据报 -&gt; 帧（Frame，通过以太网传输的比特流）</a>
</h3>
<h3 class="topic">
<a name="20isslam503h579pivar2ma5mn">&nbsp;10.分用：当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。</a>
</h3>
<h3 class="topic">
<a name="26qskmg7v9p0pr4k8iui547ub0">&nbsp;11.客户-服务器模型：大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。这种服务分为两种类型：重复型或并发型。</a>
</h3>
<h3 class="topic">
<a name="1bsajrdjqhh5fc8biv97kmg078">&nbsp;12.端口号：任何TCP/IP实现所提供的服务都用知名的1~1023之间的端口号。大多数TCP/IP实现给临时端口分配1024-5000之间的端口号。大于5000的端口号是为其他服务器预留的。</a>
</h3>
<h3 class="topic">
<a name="6hhs0d90m6pi1j8vklj9up2pt0">&nbsp;13.应用编程接口。使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口，Transport Layer Interface）</a>
</h3>
<h2 class="topic">
<a name="72pg07q20lj25i44habvttv347">第2章：链路层</a>
</h2>
<h3 class="topic">
<a name="2u1jkqbe9p3umqm5155mlg013c">&nbsp;1.链路层的目的：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5mt0ok7afrhmp8r6pl8uu61o0d">&nbsp;&nbsp;A.为IP模块发送和接收IP数据报</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5r2oqu4sjo57ftel19lsfbrbp2">&nbsp;&nbsp;B.为ARP模块发送请求和接收ARP应答</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0tlsstnh4rudir2jcs3gi5pti0">&nbsp;&nbsp;C.为RARP发送RARP请求和接收RARP应答</a>
</h3>
<h3 class="topic">
<a name="7kquhsvnod5em9ob87nq384bu4">&nbsp;2.以太网和IEEE802封装（注意两种帧的格式封装的不同）。两种帧格式都采用48bit的目的地址和源地址（硬件地址）。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。</a>
</h3>
<h3 class="topic">
<a name="1gg46p8rq7t1l4k9k4g5gt2ms0">&nbsp;3.SLIP：串行线路IP。开始结束用称作END的特殊字符表示，称作ESC的转义字符。</a>
</h3>
<h3 class="topic">
<a name="6sagvdgoqkcbnhea8o79q53vnq">&nbsp;4.PPP：点对点协议。注意PPP协议相对于SLIP协议的优点。</a>
</h3>
<h3 class="topic">
<a name="2ucp0i0jsroc3hp6dcr7er8kfu">&nbsp;5.环回接口：允许运行在同一台主机上的客户程序和服务程序通过TCP/IP进行通信。大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2eubaduo2oegceqvjbekaq0hh4">&nbsp;&nbsp;A.传给回环地址的任何数据均作为IP输入</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="14426o82uclfqv68s1uockmsro">&nbsp;&nbsp;B.传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7n93h3696t1nr5if58mll7nivs">&nbsp;&nbsp;C.任何传给该主机IP地址的数据均送到环回接口。</a>
</h3>
<h3 class="topic">
<a name="4b7npdi6nrbqfofr7n1qlsi5t0">&nbsp;6.最大传输单元MTU和路径MTU。MTU是一个逻辑限制，目的是为了交互使用提供足够快的响应时间。</a>
</h3>
<h2 class="topic">
<a name="0hanjbjujj7jhmcu9vr6bhbe47">第3章：IP网际协议</a>
</h2>
<h3 class="topic">
<a name="6clusuq2mp8kb6o843seff1ra5">&nbsp;1.提供不可靠、无连接的数据报传送服务</a>
</h3>
<h3 class="topic">
<a name="0s8mnfdtapj55ghmeortb73f1p">&nbsp;2.不可靠：它不能保证IP数据报能成功地到达目的地</a>
</h3>
<h3 class="topic">
<a name="24emueb7q7h76ru6u78mitepfg">&nbsp;3.无连接：IP并不维护任何关于后续数据报的状态信息，每个数据报的处理是相互独立的。</a>
</h3>
<h3 class="topic">
<a name="5ssvonqonmlpfrdjvrs3rlkbmu">&nbsp;4.IP首部（普通IP首部长为20个字节）</a>
</h3>
<h3 class="topic">
<a name="0mbpi9u8rsdi0ri33u8j1r6ocq">&nbsp;&nbsp;1.big endian字节序。TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</a>
</h3>
<h3 class="topic">
<a name="7e8n4lrpu6h3366qlml3jhdohn">&nbsp;&nbsp;2.注意IP数据报格式及首部中的各字段含义</a>
</h3>
<h3 class="topic">
<a name="758lr241kk7k5svo4ivtu8g1t0">&nbsp;&nbsp;&nbsp;1.服务类型（TOS）：有4bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。大多数实现不使用TOS字段。</a>
</h3>
<h3 class="topic">
<a name="243o2bbscrrae630mfnjmsmivb">&nbsp;&nbsp;&nbsp;2.总长度字段是指整个IP数据报的长度。该字段长16bit，所以IP数据报最长可达65535字节（MTU）。尽管可以传递一个长达65535字节的IP数据报，但大多数链路层都会对它进行分片。</a>
</h3>
<h3 class="topic">
<a name="18ktti62ts147ecpj05s8jao6g">&nbsp;&nbsp;&nbsp;3.TTL（time-to-time）生存时间字段设置了数据报可以经过的最多路由数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减1</a>
</h3>
<h3 class="topic">
<a name="7li0m1bciflbeqshap4kcbn21e">&nbsp;5.IP路由选择</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6pvv8k6a70ag63r25927vbrrj0">&nbsp;&nbsp;A.从概念上说，IP路由选择是简单的，特别是对于主来说。如果目的主机与源主机直接相连（如点对点链路）或者都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7se1n83luq52rvdbsa5pj9rtm7">&nbsp;&nbsp;B.IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么（1）如果IP层被设置为路由器的功能，那么就对数据报进行转发；否则（2）数据报被丢弃。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="19np4eqo595h99j422vpl248ol">&nbsp;&nbsp;C.路由表的每一项都包含下面这些信息：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5cq6adp988qdiv7gaqqimf4j02">&nbsp;&nbsp;&nbsp;a.目的IP地址。可以为完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中所有的主机。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3er738psdgjfrnt8n259e7qvlq">&nbsp;&nbsp;&nbsp;b.下一站路由器的IP地址，或者有直接连接的网络IP地址。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0srg0okr1u5eno3l922gac8ata">&nbsp;&nbsp;&nbsp;c.标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器。还是一个直接相连接的接口。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3j6lum7uvaid7tlopfm19ueid7">&nbsp;&nbsp;&nbsp;d.为数据报的传输指定一个网络接口。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3tkfqhhphincrpbb52l4s2r90k">&nbsp;&nbsp;D.为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模。</a>
</h3>
<h3 class="topic">
<a name="0gf5qfl95rqmpshse4sgla6c91">&nbsp;6.子网寻址</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1q02hiug38v1u2h9f6c0k0juja">&nbsp;&nbsp;A.不是把IP地址看成由单纯的网络号和一个主机号组成，而是把主机号再分成一个网络号和主机号。原因：A类和B类地址为主机号分配了太多的空间，事实上，一个网络中人们并不安排这么多的主机。例：B类地址，网络号（16位）+子网号（8位）+主机号（8位）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5ijfb8tstj2qihl4pmhk783v2g">&nbsp;&nbsp;B.子网对外部路由器来说隐藏了内部网络组织的细节，对子网内部的路由器是不透明的。</a>
</h3>
<h3 class="topic">
<a name="1llbt3k4fp69ddlfvgoj7g4bsk">&nbsp;7.子网掩码</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6s0oe3mt7fc3dt681r3d9ki1p0">&nbsp;&nbsp;A.子网掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3f8daiielfhnbvfftve54tp584">&nbsp;&nbsp;B.给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：（1）本子网上的主机；（2）本网络中其他子网中的主机；（3）其他网络上的主机</a>
</h3>
<h3 class="topic">
<a name="54i6on5e99mjiqrbch63p8qb8c">&nbsp;8.ipconfig命令和netstat（-n参数打印出IP地址，而不是主机名字）命令</a>
</h3>
<h3 class="topic">
<a name="45ffr8n5ujq7vgfjd56l56qpkq">&nbsp;9.网络字节序。4个字节的32bit以下面的次序传输：首先是0~7bit，其次8~15bit，然后16bit~23bit，最后24~31bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</a>
</h3>
<h2 class="topic">
<a name="3f8vlfor3g629bb1p0agqeg21t">第4章：ARP地址解析协议</a>
</h2>
<h3 class="topic">
<a name="0e9ea7qojmah4p11emr3bjqvia">&nbsp;1.地址解析协议为这两种不同的地址形式提供映射：32bit的IP地址和数据链路层使用的任何类型的地址（一般为48bit）。</a>
</h3>
<h3 class="topic">
<a name="2o8cjocn87gutmic7ke8jpu9fl">&nbsp;2.ARP高速缓存。ARP高速运行的关键是由于每个主机上都有一个高速缓存，这个缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟。</a>
</h3>
<h3 class="topic">
<a name="2b5erln6pjv6bmis8qq0pqaush">&nbsp;3.ARP的分组格式</a>
</h3>
<h2 class="topic">
<a name="1of5ku86k4v3tshp3um52t3kf3">第5章：RARP逆地址解析协议</a>
</h2>
<h2 class="topic">
<a name="04h9qj39vsn99f2avj3tst09b5">第6章：ICMP  Internet控制报文协议</a>
</h2>
<h3 class="topic">
<a name="7v6dcnpf0pv6l0rl2t4ovvjlsl">&nbsp;1.ICMP报文是在IP数据报内部被传输的。IP数据报（IP首部：ICMP报文）</a>
</h3>
<h3 class="topic">
<a name="2m3c79h2e6hm6o4vjfblp18kt7">&nbsp;2.具体格式参考TCP-IP详解卷1第6章</a>
</h3>
<h3 class="topic">
<a name="4h1vlbresi9e1t646guk4mc6ah">&nbsp;3.不会导致产生ICMP差错报文的情况（这些规则是为了防止过去容许ICMP差错报文对广播分组响应所带来的广播风暴）：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="23d3niokeqmfi5am0s0srvplo1">&nbsp;&nbsp;A.ICMP差错报文（但ICMP查询报文可能会产生ICMP差错报文）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="67cbeo6jpqo5jcfv0i9i8fg5e2">&nbsp;&nbsp;B.目的地址是广播地址或多播地址的IP数据报</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="27el63tjjcr90aiuudkholp0fh">&nbsp;&nbsp;C.作为链路层广播的数据报</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7n2vqe3o232o837hejupbfv7t9">&nbsp;&nbsp;D.不是IP分片的第一片</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5qjods7gh2jddetjvi87b118va">&nbsp;&nbsp;E.源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</a>
</h3>
<h3 class="topic">
<a name="39q8son7sk8gsho897naj6acu4">&nbsp;4.剩下的有时间再补充</a>
</h3>
<h2 class="topic">
<a name="3ucfgbv1qa6ittio896kuf2crd">第7章：UDP用户数据报协议</a>
</h2>
<h3 class="topic">
<a name="1e5ufa7i3ij0iih3r874qnggob">&nbsp;1.UDP首部各个字段。（16位源端口号：16位目的端口号：16位UDP长度：16位UDP校验和）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2qc7b9eag2030fnmkpu1do0058">&nbsp;&nbsp;A.端口号表示发送进程和接收进程</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="53bm4cti867r62a8180v38vup9">&nbsp;&nbsp;B.UDP端口号和TCP端口号是相互独立的</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="266vr31rusu8l1qo528q6m2flm">&nbsp;&nbsp;C.UDP长度字段指的是UDP首部和UDP数据的字节长度</a>
</h3>
<h3 class="topic">
<a name="5dhoic40700mfkfuuc57mfl87c">&nbsp;2.UDP校验和</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6nhjt1ematjof7o28cjkkb8eo2">&nbsp;&nbsp;A.UDP校验和覆盖UDP首部和UDP数据（作为对比，IP首部的校验和只覆盖IP首部，不覆盖IP数据报中的任何数据）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6r45jo3i0ij219d633oti76vnb">&nbsp;&nbsp;B.UDP数据报的长度可以为奇数字节，但检验和算法是把若干个16bit字相加。必要时在最后增加填充字节0，这只是为了检验和的计算。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7pnd5apjfv3gvjauak4rtbrnt9">&nbsp;&nbsp;C.UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算校验和而设置的。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1bncqn0447naugejig44ngao1m">&nbsp;&nbsp;D.校验算法流程：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2rnrq9ku7og6t7l9ivm8oj8jik">&nbsp;&nbsp;&nbsp;a.发送数据</a>
</h3>
<h3 class="topic">
<a name="4slgbvm1k8586a2hdtgvr0brh7">&nbsp;&nbsp;&nbsp;&nbsp;1.把校验和字段置为0；</a>
</h3>
<h3 class="topic">
<a name="28mn9ln2ne4vedm2nt0ld84dit">&nbsp;&nbsp;&nbsp;&nbsp;2.把需要校验的数据看成以16位为单位的数字组成，依次进行二进制反码求和；</a>
</h3>
<h3 class="topic">
<a name="56558dn581qip5ur26cbrhhb0d">&nbsp;&nbsp;&nbsp;&nbsp;3.把得到的结果存入校验和字段中；</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6g3t6p4tupjro68orom598kspj">&nbsp;&nbsp;&nbsp;b.接收数据</a>
</h3>
<h3 class="topic">
<a name="2v0sdvn1jrgp6b4j90nkhjvho6">&nbsp;&nbsp;&nbsp;&nbsp;1.把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段；</a>
</h3>
<h3 class="topic">
<a name="0dbllmkjqlil9go4sbmhej87t9">&nbsp;&nbsp;&nbsp;&nbsp;2.检查计算出的校验和的结果是否为0；</a>
</h3>
<h3 class="topic">
<a name="0c63uirek6149lqpktgvifgbnq">&nbsp;&nbsp;&nbsp;&nbsp;3.如果等于0，说明被整除，校验和是正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。</a>
</h3>
<h3 class="topic">
<a name="75ikrnfulec5hb3pr02a6pfn6a">&nbsp;3.IP分片</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0gu1nj03s6p6a5j24s7oapisji">&nbsp;&nbsp;A.物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据，并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="672l0b03g8p2pn4j043ptan9ql">&nbsp;&nbsp;B.一份IP数据报分片后，要在目的地才进行重新组装（这里的重新组装与其他网络协议不同，他们要求在下一站就进行重新组装，而不是最终目的地）。已经分片过的数据报有可能会再次进行分片（可能不止一次）。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="63uei3j4ro1meq05hvgse2c10r">&nbsp;&nbsp;C.当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3sj18skjk03n4a417hn8la0jv7">&nbsp;&nbsp;D.IP数据报是指IP层端到端的传输单元，分组是指IP层和链路层之间的传输单元，一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。</a>
</h3>
<h3 class="topic">
<a name="420ljfrdbln4ma2523i5vg68co">&nbsp;&nbsp;E.MTU发现机制：如果某个程序需要判断到达目的地端的路途中最小MTU是多少（是否分片需要通过与MTU的比较确定）</a>
</h3>
<h3 class="topic">
<a name="59vaiki8ovggoo6tkvus3j3nd2">&nbsp;4.最大UDP数据报长度：IP数据报的最大长度是65535字节，这是由IP首部16bit总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但大多数实现所提供的长度比这个最大值小。</a>
</h3>
<h3 class="topic">
<a name="0go3hvnu7ob3ans1jf58dho4a5">&nbsp;5.UDP输入队列：通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序。然而，排队溢出造成内核中UDP模块丢弃数据报的可能性是存在的。</a>
</h3>
<h2 class="topic">
<a name="4cs7r7km7b33bf5sca40odiju3">第8章：广播和多播</a>
</h2>
<h3 class="topic">
<a name="1d7mi6fa0o6r1bc0jqs91c6mnu">&nbsp;1.广播和多播仅应用于UDP，它们对需要将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。</a>
</h3>
<h3 class="topic">
<a name="60m169vg8i3qear6d713qljpci">&nbsp;2.考虑包含多个主机的共享信道网络如以太网。每个以太网帧包含源主机和目的主机的以太网地址（48bit）。通常每个以太网仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播。这种情况下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。</a>
</h3>
<h3 class="topic">
<a name="1doemlb8lkcorh1mirqiiiloep">&nbsp;3.有时一个主机要向网上的所有其他主机发送帧，这就是广播。多播处于单播和广播之间：帧仅传送给属于多播组的多个主机。</a>
</h3>
<h3 class="topic">
<a name="6bhhjit6qhn8pjapir7of90rh4">&nbsp;4.对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址，用十六进制可表示为01:00:00:00:00:00（以太网广播地址ff:ff:ff:ff:ff:ff可看做是以太网多播地址的特例）。</a>
</h3>
<h3 class="topic">
<a name="0vn438olj51qscfnq318h1qh5m">&nbsp;5.使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。使用多播，主机可以加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在的多播组的那些多播帧。</a>
</h3>
<h3 class="topic">
<a name="5k6n7jdipde1r1p277qaep11sc">&nbsp;6.四种IP广播地址</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3u8mrj4jpj7jhpinkuo1220kn2">&nbsp;&nbsp;A.受限的广播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="285in2hikdec1gltvi7eu0ehf8">&nbsp;&nbsp;&nbsp;a.受限的广播地址是25.255.255.255  。该地址用于主机配置过程中IP数据报的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7r5f1s92ft30eac1656an8s5jn">&nbsp;&nbsp;&nbsp;b.任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0551stkmfce8cfbgrcnm3iaafj">&nbsp;&nbsp;B.指向网络的广播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="23tmck7g16k4pout0bbpfs2bit">&nbsp;&nbsp;&nbsp;a.指向网络的广播地址是主机号全1的地址。A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4iobhkka1vnhbrf2fk4f3esvhh">&nbsp;&nbsp;&nbsp;b.一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="70oq0gvt95pe201fol9vjssadl">&nbsp;&nbsp;C.指向子网的广播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4cm9h1o7sftf2c4jhq05qstl6v">&nbsp;&nbsp;&nbsp;a.指向子网的广播地址为主机号为全1且有特定子网号的地址。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6fl511d6rildq5dednuikj24sv">&nbsp;&nbsp;&nbsp;b.通过子网掩码和IP地址确定指向子网的广播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1518ntorlof1p7v4kit2cfq4km">&nbsp;&nbsp;D.指向所有子网的广播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1akf3t1kq23a7mpsqfu69sp8e5">&nbsp;&nbsp;&nbsp;a.指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7231vilg8sco717j43dvgi1tll">&nbsp;&nbsp;&nbsp;b.指向所有子网的广播地址的子网号及主机号为全1。</a>
</h3>
<h3 class="topic">
<a name="73cr2ofomcs970nh4kp9iiufjm">&nbsp;7.多播</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6ig2eekj227gcs39cc5rb9kvdg">&nbsp;&nbsp;A.IP多播提供两类服务：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7cvg9jpoj93lhfqapbfbj3lhol">&nbsp;&nbsp;&nbsp;a.向多个目的地址传送数据。有许多向多个接收者传送信息的应用：例如交互式会议系统和向多个接收者发送邮件或新闻。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3h88f3hi1bmsjektd5fkfcuvcf">&nbsp;&nbsp;&nbsp;b.客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的，但使用多播可降低不提供这项服务主机的负担。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="24f351jl14g6or8je7p2b7lbdm">&nbsp;&nbsp;B.多播组地址（D类IP地址）。D类IP地址格式：1110+多播组ID（28位）。不像其他三类IP地址（A、B、C），分配的28bit均用作多播组号而不再表示其他。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2mnmmu3ibqmialsgube8bu2q6f">&nbsp;&nbsp;C.多播组地址为1110的最高4bit和多播组号。它们通常表示为点分十进制数，范围从224.0.0.0到239.255.255.255</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3v1gqi7aphfeebpup03hfpdkk5">&nbsp;&nbsp;D.能够接收发往一个特定多组播地址数据的主机集合称为主机组。一个主机组可以跨越多个网络。主机组中对主机的数量没有限制，同时不屑于某一主机组的主机可以向该组发送信息。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4lqfp8huksl1lupt8aglmrbgqt">&nbsp;&nbsp;E.一些多播组地址被IANA确定为知名地址。例如，224.0.0.1代表&ldquo;该子网内的所有系统组&rdquo;，224.0.0.2代表&ldquo;该子网内的所有路由器组&rdquo;等。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="73cuk51k9g9b2a7fv3tr6ujnvd">&nbsp;&nbsp;F.多播组地址到以太网地址的转换</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="31s3nsiqihq5rv2d402cpjekfq">&nbsp;&nbsp;&nbsp;a.IANA拥有一个以太网地址块，即高位24bit为00:00:5e（十六进制表示），这意味着该地址所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一般分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是01，这意味着与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0aj1elrkle011059sce3t0l6om">&nbsp;&nbsp;&nbsp;b.由于地址映射不是唯一的，因此需要其他的协议实现额外的数据报过滤。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0nl5fe99t180tgflfct2h43h2t">&nbsp;&nbsp;&nbsp;c.由于IP组播地址的高4bit是1110，标识了组播组，而低28bit中只有23bit被映射到组播MAC地址上，这样IP组播地址中就会有5bit没有使用，从而出现了32个IP组播地址映射到同一MAC地址上的结果</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3d5do93p1k5nkf82qh379qp584">&nbsp;&nbsp;&nbsp;d.网络中的主机通过发送IGMP报文相临近的路由器申请加入（或离开）组播组，交换机侦听用户与路由器之间的交互IGMP报文，跟踪组播信息及申请的端口。当交换机侦听到主机向路由器发出报文时，交换机用他来完成组播组的动态注册。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="10ga06t9hvc65oidc10842dads">&nbsp;&nbsp;&nbsp;e.IGMP侦听是组播约束机制。交换机侦听用户主机与路由器之间的交互IGMP报文，跟踪组播信息及其申请的端口。当交换机侦听到主机向路由器发送报告报文时，交换机便把该端口加入组播地址表中；当交换机侦听到主机发送离开的报文时，路由器会发送该端口的特定组查询报文，若还有其他主机需要该组播，则将回应报告报文，若路由器收不到任何主机的回应，交换机便把该端口从组播地址表中删除。</a>
</h3>
<h2 class="topic">
<a name="1cifrsi25aorpm5vgc8kbe5391">第9章：IGMP  Internet组管理协议</a>
</h2>
<h3 class="topic">
<a name="1gp1bveejnhslj0k6btqugcol6">&nbsp;1.IGMP用于支持主机和路由器进行多播。它让一个物理网络上的所有系统知道主机当前所在的多组播。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</a>
</h3>
<h3 class="topic">
<a name="31391dkk631bg565qgufj82irl">&nbsp;2.正如ICMP一样，IGMP也被当做IP层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。封装在IP层中的格式：IP首部（20字节）+IGMP报文（8字节）</a>
</h3>
<h3 class="topic">
<a name="55mk9ktksi0d3ajjrbgi2f2b07">&nbsp;3.组播过程（一个典型的过程）：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0fei209iahe9o7pcih1n03jsci">&nbsp;&nbsp;A.IP主机的一个进程可随时加入和离开主机接口的一个组播组，该主机需要维护接口的一张表，该表包含了有哪些组以及这些组中的进程数量。此时主机需要发送一个IGMP报告。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1vc05fakgo6b59c1jr58gok98o">&nbsp;&nbsp;B.路由器会定时发送IGMP查询报文，此时报文中组地址为0</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5e0bcpmcvut392j1f7mfsbb9bc">&nbsp;&nbsp;C.IP主机回应路由器的IGMP查询报文，对于一个主机，如果它加入了多个组，则需要为每个组返回一个IGMP报告。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4gh0llgd6m4d4vek6851ro2gb6">&nbsp;&nbsp;D.路由器根据这些信息，会对每个接口维护一张表，表中说明了该接口的组。</a>
</h3>
<h2 class="topic">
<a name="3gf1ks4f1e6fu907n4lescsm5l">第10章：DNS域名系统</a>
</h2>
<h3 class="topic">
<a name="7o0tqegg33o51vrfpf7oas1sps">&nbsp;1.域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名称和IP地址之间的转换及有关电子邮件的选路信息。</a>
</h3>
<h2 class="topic">
<a name="28mflcuhulk766i57f95ljgfc8">第11章：TCP传输控制协议</a>
</h2>
<h3 class="topic">
<a name="3bsj3tsjtp98coopdqa23hvas6">&nbsp;1.TCP通过下列方式提供可靠性：</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7lgc2565bg7aejhgat7k2ei36g">&nbsp;&nbsp;A.应用数据被分割成TCP认为最合适发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2lppnsmrhklqmvv2ilsn9sg1mm">&nbsp;&nbsp;B.当TCP发出一个段后，它将启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6maghu6dtvlj96gnq7sl3cqkpi">&nbsp;&nbsp;C.当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="65virmu0v6con0dghc6r9hasmi">&nbsp;&nbsp;D.TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发送端超时并重发）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="35u25803le825tvmq07tk1ip1j">&nbsp;&nbsp;E.既然TCP报文段作为IP数据来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="37hq1dk9mrk9g7abbf8l9j2e7s">&nbsp;&nbsp;F.既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1hkvli9pkmb1q2nltfbkqihqrg">&nbsp;&nbsp;G.TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只容许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</a>
</h3>
<h3 class="topic">
<a name="1fp12dvqff656tl78b0mgpqbae">&nbsp;2.TCP首部</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="632f20sm9sltfj48t8p4i7ogq4">&nbsp;&nbsp;A.16位源端口号+16位目的端口号。每个TCP段都包含源端和目的端的端口号，用于寻找发端和收段应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4kd0or9cgle6i6g26m7u4h8h5h">&nbsp;&nbsp;B.32位序号+32位确认序号。序号用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。如果将字节流看做在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达2^32-1后又从0开始。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2sqgop8p62kdt46a11ccncfpok">&nbsp;&nbsp;C.4位首部长度+保留（6位）+6个标志比特</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3nccsgaeake7dro0827ilubjgr">&nbsp;&nbsp;&nbsp;a.URG紧急指针有效</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="12bdf2e4ske2mrp60nrl97ao0i">&nbsp;&nbsp;&nbsp;b.ACK确认序号有效</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="69t0ol47htc92mvu0pdh7j0jt9">&nbsp;&nbsp;&nbsp;c.PSH接收方应该尽快将这个报文段交给应用层</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="3vs4rv23b54qef8h5m32bkp14h">&nbsp;&nbsp;&nbsp;e.RST重建连接</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="32b1211t457ggm92fdh0lhotm0">&nbsp;&nbsp;&nbsp;f.SYN同步序号用来发起一个连接</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="30hfp9cfbfncd20at7vq7ift5b">&nbsp;&nbsp;&nbsp;g.FIN发端完成任务</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="17c0gknjmjojdlgc32ju06so7f">&nbsp;&nbsp;D.16位窗口大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2s5ed7j2ebh2ckejnrq3fgu34b">&nbsp;&nbsp;E.16位校验和。校验和覆盖了整个的TCP报文段：TCP首部和TCP数据。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="0fqgbons96u2acep13h4s5i8v0">&nbsp;&nbsp;F.16位紧急指针。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="4jng0sklgvpandh62qb85b0kng">&nbsp;&nbsp;G.最常见的可选字段</a>
</h3>
<h3 class="topic">
<a name="79rmnl6ieas91rc8ve9fuo9g1s">&nbsp;3.建立连接协议（三次握手）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="2ijje41ukm7s93sgdmc1rjdq1u">&nbsp;&nbsp;A.请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口。SYN=1，seq=J（客户将SYN置为1，发送序号为seq=J）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="6q309voesd66edne3l58gh8mgr">&nbsp;&nbsp;B.服务器由标志位SYN=1知道客户端要建立连接，服务端将自己的SYN和ACK置为1，应答序号置为ack=J+1，并将发送序号设为seq=K。SYN=1,ACK=1,ack=J+1,seq=K。</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="1uhfcdoea5f2guti2263iq7iuj">&nbsp;&nbsp;C.客户将检查ACK ?=1,ack ?=J+1，如果正确则将自己的ACK置为1，将应答序号设置为ack=K+1。服务端收到后会检查ack=K+1?，ACK=1?，如果正确则建立连接。ACK=1,ack=K+1</a>
</h3>
<h3 class="topic">
<a name="3oq0p4gqp5t0gekpt1d6gjakb0">&nbsp;4.连接终止协议（四次挥手）</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="26uet5ljm8llf7e4a19smui1o9">&nbsp;&nbsp;A.客户端发送一个FIN，用来关闭客户端到服务器的数据传输</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="7v52quqbp6cvmsjphf1tcaj2e0">&nbsp;&nbsp;B.服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="37cua5tvrfe0ej9m9olrf18621">&nbsp;&nbsp;C.服务端发送一个FIN，用来关闭服务器到客户端的数据传输</a>
</h3>
<h3 class="topic">
&nbsp;&nbsp;<a name="5g6glh413sa93f5pc0eermjf15">&nbsp;&nbsp;D.客户端收到FIN后，确认序号置为发送序号+1</a>
</h3>
<h3 class="topic">
<a name="7tn0kjgr2d6rm5s45nb4mnr0i1">&nbsp;5.建立一个连接需要三次握手，而终止一个连接需要经过4次握手。这是由于TCP的半关闭造成的。既然一个TCP连接是全双工的（即数据能在两个方向上同时传输），因此每个方向必须单独关闭。</a>
</h3>
</body>
</html>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/04/08/Java/Java Web基础/">Java Web基础</a></h1>
  

      
        <time datetime="2018-04-08T07:33:00.000Z">2018-04-08</time>
      
    </header>
    <div class="entry">
      
        <h1 id="自己以前的学习笔记，希望可以帮助到一些学习Java-web的人。还有一部分内容没写完，以后抽时间补上。"><a href="#自己以前的学习笔记，希望可以帮助到一些学习Java-web的人。还有一部分内容没写完，以后抽时间补上。" class="headerlink" title="自己以前的学习笔记，希望可以帮助到一些学习Java web的人。还有一部分内容没写完，以后抽时间补上。"></a>自己以前的学习笔记，希望可以帮助到一些学习Java web的人。还有一部分内容没写完，以后抽时间补上。</h1><p>注意：图片可以右击点击查看图片，放大（使用火狐浏览器）<br><img src="http://img.blog.csdn.net/20180106163022914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1YmluMTk5MWxpdWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<title>Java  Web基础</title>
</head>
<body>
<h1 align="center" class="root">
<a name="3lom1e5j736r5uur199n0plia9">Java  Web基础</a>
</h1>
<h2 class="topic">
<a name="232m1dm7gd4es3cvpinephqotg">一、Servlet</a>
</h2>
<h3 class="topic">
<a name="7j6f49fbov0c0ames6emgj2m9t">&nbsp;1.创建Servlet</a>
</h3>
<h3 class="topic">
<a name="1cl95fvn9nilac4067obs3rii6">&nbsp;&nbsp;1.实现Servlet接口</a>
</h3>
<h3 class="topic">
<a name="0uknjl7kc992oaufp2lukb7io9">&nbsp;&nbsp;2.继承javax.servlet.GenericServlet</a>
</h3>
<h3 class="topic">
<a name="7ai02ql6qfbtfgo8593vfntcst">&nbsp;&nbsp;3.继承javax.servlet.http.HttpServlet</a>
</h3>
<h3 class="topic">
<a name="6bfa8jtu2nlo00ckmtojchcsdk">&nbsp;2.Servlet生命周期</a>
</h3>
<h3 class="topic">
<a name="362hosloaauvfgpvfqeftdku4s">&nbsp;&nbsp;1.出生--&gt;init方法:在构造方法之后调用</a>
</h3>
<h3 class="topic">
<a name="271nos0qaql10hpjc4dq90u16t">&nbsp;&nbsp;2.使命--&gt;service方法：请求发过来时，处理请求使用</a>
</h3>
<h3 class="topic">
<a name="33lqf3uvro44ilrhtktfgs6voq">&nbsp;&nbsp;3.销毁--&gt;destory方法：服务器关闭时，会销毁Servlet，在销毁前调用该方法释放资源，销毁内存中的实例</a>
</h3>
<h3 class="topic">
<a name="764thv1au6458bhp6m4huojdt8">&nbsp;3.Servlet在web.xml中的注册</a>
</h3>
<h3 class="topic">
<a name="2n4oh9up3efcp9n9d74b77d315">&nbsp;&nbsp;1.注册Servlet到项目中</a>
</h3>
<h3 class="topic">
<a name="7p2n5617hanjufj791vevlpt80">&nbsp;&nbsp;2.分配给Servlet路径</a>
</h3>
<h3 class="topic">
<a name="0s6h696q16ejhb073vkn69o0r5">&nbsp;&nbsp;&nbsp;1.Servlet路径配置详解</a>
</h3>
<h3 class="topic">
<a name="5j1b0fmi9ssdu0hov4pplgige9">&nbsp;&nbsp;&nbsp;&nbsp;1.路径匹配：/ServletDemo,  /ABC/ServletDemo  ,/ABC/*</a>
</h3>
<h3 class="topic">
<a name="54ktcee0el80et3rpofr966v50">&nbsp;&nbsp;&nbsp;&nbsp;2.后缀名匹配：*.do  ,*.action  ,*.html</a>
</h3>
<h3 class="topic">
<a name="1j2v805656i49e7qu1gihepb3g">&nbsp;&nbsp;&nbsp;&nbsp;3.配置的路径匹配范围越大优先级越低</a>
</h3>
<h3 class="topic">
<a name="0ht48dvdbatsee0csfuro8njoh">&nbsp;4.访问Servlet的时序过程</a>
</h3>
<h3 class="topic">
<a name="5gus2oprq9t4tf46l1b9karbi8">&nbsp;&nbsp;1.一般情况下，Servlet在第一次被访问时于内存中创建对象，随后调用init方法进行初始化，对每一次请求都调用service方法进行处理，此时会用Request对象封装请求信息，并用Response对象（初始为null）代表响应消息，传入service方法供其使用。</a>
</h3>
<h3 class="topic">
<a name="18skgo3j09buc53g3ucjh3ok75">&nbsp;&nbsp;2.当service方法处理完后，返回服务器，服务器根据response中的信息组织响应消息，返回给浏览器。响应结束后，servlet并不会销毁，一直驻留在在内存中等待下一次请求，直到服务器关闭或web应用被移除。</a>
</h3>
<h3 class="topic">
<a name="5pam58nmjqfu0usbq5kh0bfdf9">&nbsp;5.Servlet的 线程安全问题：解决办法，使用局部变量保存用户数据</a>
</h3>
<h3 class="topic">
<a name="3aphd4c4okbv2uns6dl0jss36r">&nbsp;6.Servlet技术三大组件</a>
</h3>
<h3 class="topic">
<a name="19g5s9qe9jatcti70pg8ukk721">&nbsp;&nbsp;1.Servlet</a>
</h3>
<h3 class="topic">
<a name="49ip1vquf8g560qtm5t132nlm0">&nbsp;&nbsp;2.Filter过滤器</a>
</h3>
<h3 class="topic">
<a name="7uv2hjvv0njsp3fteq99c2jnnm">&nbsp;&nbsp;3.Listener监听器</a>
</h3>
<h2 class="topic">
<a name="2l77j370q57vdvcbqm4l0v9mdt">二、ServletConfig</a>
</h2>
<h3 class="topic">
<a name="70e5bskeuq7fs5ghgfv44rj0gp">&nbsp;1.代表Servlet的配置对象（可以在web.xml中配置）</a>
</h3>
<h3 class="topic">
<a name="18tioijddh4l573a05mkpgi2in">&nbsp;&nbsp;1.Servlet中可以用this.getServletConfig()获得该对象</a>
</h3>
<h3 class="topic">
<a name="5ek7aoe5o5kbulfim7re41qbmd">&nbsp;&nbsp;2.常用方法：getServletName()和getInitParameterNames()（可以遍历出配置中的配置项）</a>
</h3>
<h3 class="topic">
<a name="1rmqe7h05t1d6ra2hkibtt1atk">&nbsp;&nbsp;3.&lt;servlet&gt;&lt;init-param&gt;&lt;param-name&gt;&lt;/param-name&gt;&lt;param-value&gt;&lt;/param-value&gt;&lt;/init-param&gt;&lt;/servlet&gt;</a>
</h3>
<h3 class="topic">
<a name="66jt8n8vircubsuq1pnvv7ddn9">&nbsp;2.设置Servlet随着项目的启动而创建</a>
</h3>
<h3 class="topic">
<a name="2nht5j5a4ncnjvc9b63l4b6iob">&nbsp;&nbsp;1.&lt;servlet&gt;&lt;load-on-startup&gt;填写一个整数，整数越小优先级越高&lt;/load-on-startup&gt;&lt;/servlet&gt;</a>
</h3>
<h2 class="topic">
<a name="7r5e3dvgtc89jl2grh44r9bv59">三、ServletContext</a>
</h2>
<h3 class="topic">
<a name="3asd15fej53i3etv3nc48crrid">&nbsp;1.ServletContext代表对整个应用的配置，获得方法，getServletContext方法</a>
</h3>
<h3 class="topic">
<a name="0kneaglen1tjnqqfncad8p4kr5">&nbsp;2.ServletContext的作用</a>
</h3>
<h3 class="topic">
<a name="1n88o61a46hi2tumjk5bkem9u8">&nbsp;&nbsp;1.封装了web.xml中的配置</a>
</h3>
<h3 class="topic">
<a name="1aqs708csqg8u3k8p0sgprlc1u">&nbsp;&nbsp;2.Servlet技术中三大域对象之一。ServletContext  application；session；request</a>
</h3>
<h3 class="topic">
<a name="220ainhjph392ml7o2upcr26vv">&nbsp;&nbsp;3.获得项目中资源</a>
</h3>
<h3 class="topic">
<a name="43ic7mvi1kqn6ct7mkkl68sdgt">&nbsp;&nbsp;&nbsp;ServletContext sc=getServletContext();InputStream is=sc.getResourceAsStream("/WEB-INF/cities.xml");String path=sc.getRealPath("/WEB-INF/cities.xml")获取资源的绝对路径</a>
</h3>
<h3 class="topic">
<a name="3j51il8q5d956b3pdfvoopmei5">&nbsp;3.application域。原理：利用一个项目中只有一个ServletContext实例的特点，在ServletContext中放置了一个Map，这个Map 就是所谓的域。</a>
</h3>
<h2 class="topic">
<a name="4o5liropmfbm0l8t32b1c6128j">四、Response</a>
</h2>
<h3 class="topic">
<a name="4142r8slp4714n5a9m4c4btnng">&nbsp;1.response对象代表响应，我们在其中填入要发送到浏览器的内容，服务器把这些内容组装成http响应</a>
</h3>
<h3 class="topic">
<a name="0bf44khpf6u1on9q1a0rg39g4e">&nbsp;2.http响应及对应操作方法</a>
</h3>
<h3 class="topic">
<a name="00131811tu1sfk7uo37rt4h0i1">&nbsp;&nbsp;1.响应首行（协议/版本号  状态码  状态码描述）。添加状态码和描述的方法：void setStatus(int sc);  void setStatus(int sc,String sm);  void sendError(int sc);void sendError(int sc,String msg)</a>
</h3>
<h3 class="topic">
<a name="1tiktrae1hhmd175fjhj2ce3q1">&nbsp;&nbsp;2.响应头。添加响应头</a>
</h3>
<h3 class="topic">
<a name="34bal31in0nnv42l6848pri2fi">&nbsp;&nbsp;&nbsp;1.设置响应头，key一样会覆盖。void setHeader(String name,String value);  setIntHeader(String name,int value);  setDateHeader(String name,long date)</a>
</h3>
<h3 class="topic">
<a name="0m663ktjg6h2se1622skma548o">&nbsp;&nbsp;&nbsp;2.设置响应头，无论如何都新增。addHeader(String name,String value);  addIntHeader(String name,int value);  addDateHeader(String name,long date);</a>
</h3>
<h3 class="topic">
<a name="4hcaf7u0rn9t1362uqeo9rfneq">&nbsp;&nbsp;3.响应正文（响应空行）。发送字节流 getOutputStream;发送字符流getWriter</a>
</h3>
<h3 class="topic">
<a name="3r9lo2afu2uq9ljsqjgqq1uvor">&nbsp;4.重定向</a>
</h3>
<h3 class="topic">
<a name="5n7s17564c5v88eksdcr7ppv9k">&nbsp;&nbsp;1.response.setHeader("location","http://www.baidu.com")  or  response.setHeader("location","day1/ServletDemo")    +response.setStatus(302)</a>
</h3>
<h3 class="topic">
<a name="06bv45b2da7rg5u6mdcdbppgln">&nbsp;&nbsp;2.response.sendRedirect(String url);</a>
</h3>
<h3 class="topic">
<a name="1eogn0n9gc2lqg0hea4d21qrr8">&nbsp;5.乱码问题的解决</a>
</h3>
<h3 class="topic">
<a name="3prv5aq04ckj6b5sujfnr7rp6t">&nbsp;&nbsp;1.字节流。服务器端：string.getBytes("码表&ldquo;)   ;浏览器端：浏览器通过标签&lt;meta  http-equiv="content-type"  content="text/html;charset=utf-8"&gt;控制使用码表解码。对应的响应头：content-type：text/html;charset=utf-8。</a>
</h3>
<h3 class="topic">
<a name="44o4iahfc17528tqt8jqe7vv2q">&nbsp;&nbsp;2.字符流。PrintWriter pw=response.getWriter();  pw.print("你好世界")   服务端默认是使用ISO-8859-1码表。控制字符流使用码表response.setCharacterEncoding("UTF-8")（这个一般要放在最上面，因为得到流时要先取码表）</a>
</h3>
<h3 class="topic">
<a name="1tf9dbmb4pq8130lmpcmqgosdp">&nbsp;&nbsp;3.Java EE提供了一个方法，可以同时解决编码和解码的问题。response.setContextType("text/html;charset=utf-8");</a>
</h3>
<h3 class="topic">
<a name="08adfgb75niu7db4r85ep1da89">&nbsp;6.使用字节流发送图片</a>
</h3>
<h3 class="topic">
<a name="33pcegjc6vpabugs9oljvdcumv">&nbsp;&nbsp;1.告诉浏览器发给你流的MIME类型。response.setContentType("image/jpeg&ldquo;);</a>
</h3>
<h3 class="topic">
<a name="5bgvoo9pne6mhparn8o7mq70e6">&nbsp;&nbsp;2.获得图片输入流。InputStream in=getServletContext().getResourceAsStream("WEB-INF/1.jpg");</a>
</h3>
<h3 class="topic">
<a name="7qbsnrptbmahqb8fcssrvvffns">&nbsp;&nbsp;3.获得输出字节流。OutputStream out=response.getOutputStream();</a>
</h3>
<h3 class="topic">
<a name="6dg43h8en7avnrpb5prl8hogd6">&nbsp;&nbsp;4.对接输入输出流（略）</a>
</h3>
<h3 class="topic">
<a name="6jdnpcl5pqngg06vlf1ecjp6tl">&nbsp;7.使用字节流发送文件</a>
</h3>
<h3 class="topic">
<a name="7r89b1lhs2kte5e1mh8idfn294">&nbsp;&nbsp;1.文件的类型可以参考Tomcat中conf/web.xml中配置的MIME类型。例：&lt;mime-mapping&gt;&lt;extension&gt;jar&lt;/extension&gt;&lt;mime-type&gt;application/java-archive&lt;/mime-type&gt;&lt;/mime-mapping&gt;</a>
</h3>
<h3 class="topic">
<a name="0iufvdbrs595ujhm6e6k2g55sh">&nbsp;&nbsp;2.代码实现</a>
</h3>
<h3 class="topic">
<a name="54p993nn394drn4f3m143q5iag">&nbsp;&nbsp;&nbsp;1.告诉浏览器要发送的是什么。response.setContentType("application/java-archive");  引号中的内型可以通过getServletContext().getMimeType(".jar")获得（可以获得&ldquo;.jar&rdquo;的MIME类型）。</a>
</h3>
<h3 class="topic">
<a name="100sjra0rd6fs1pdca57ph78i3">&nbsp;&nbsp;&nbsp;2.告诉浏览器推荐用户使用什么名称下载（不设置的话默认文件名为路径名）。response.setHeader("content-disposition","attachment;filename="+filename); filename为String类型。</a>
</h3>
<h3 class="topic">
<a name="66brat2699nu7745s8nm3uf87q">&nbsp;&nbsp;&nbsp;3.开启输入输出流，并对接。</a>
</h3>
<h2 class="topic">
<a name="2811n9nfpj8tuf6g9pn8e2vr3u">五、Request</a>
</h2>
<h3 class="topic">
<a name="1ca3nscdtr4li26hd2n94l310b">&nbsp;1.http请求及对应操作方法</a>
</h3>
<h3 class="topic">
<a name="6ecargnmuf307r8sc0tngaiisq">&nbsp;&nbsp;1.请求行  请求方式  请求路径  协议/版本号。request.getMethod();GET    request.getRequestURI();/day12/ServletDemo    request.getServletPath();/day12    request.getScheme();http</a>
</h3>
<h3 class="topic">
<a name="188398cr31qptko0dbaq6i6lvh">&nbsp;&nbsp;2.请求头，request的方法。String getHeader(String name);  long getDateHeader(String name);  int getIntHeader(String name);  Enumeration getHeaders(String name);  Enumeration getHeaderNames();</a>
</h3>
<h3 class="topic">
<a name="0klisfqeu82qc67i3m7i7fqign">&nbsp;&nbsp;3.请求正文（请求空行之后），表单传递过来的键值对。</a>
</h3>
<h3 class="topic">
<a name="6at8vqd7s804sjl0vn7uq4j26t">&nbsp;2.GET提交</a>
</h3>
<h3 class="topic">
<a name="40rv2560ebl5agsbdqi8lq39hn">&nbsp;&nbsp;1.由于HTTP协议规定URL路径只能存在ASCII码中的字符，所以URL中存在中文或其他特殊的字符需要进行URL编码。原理：a.将空格转换为+；b.对0~9，a-z，A-Z之间的字符保持不变； c.用这个字符的当前字符集编码在内存中的十六进制表示，并在每个字节前加上一个百分号%</a>
</h3>
<h3 class="topic">
<a name="61otc3tnise199d29sobt4pibm">&nbsp;&nbsp;2.获得表单提交上来的键值对。String name=request.getParameter("name");  String age=request.getParameter("age");  </a>
</h3>
<h3 class="topic">
<a name="49houf3fnlspcrohg43d1a99ua">&nbsp;&nbsp;3.解决乱码。byte[ ] nameByte=name.getBytes("ISO-8859-1");  String newName=new String(nameByte,"UTF-8");</a>
</h3>
<h3 class="topic">
<a name="1352jqk3a9qislhqjso7mec5g6">&nbsp;&nbsp;4.服务器默认使用ISO-8859-1解码，如下的URIEncoding来决定解码码表（conf/web.xml）。&lt;connector port="8080" protocol="HTTP/1.1"  URIEncoding="UTF-8"  connectionTimeout="2000"  redirectPort="8443" /&gt;</a>
</h3>
<h3 class="topic">
<a name="2jc8uog74tdolg58aoa9sdngr1">&nbsp;3.POST提交</a>
</h3>
<h3 class="topic">
<a name="676873f3vrmhgpf33q67kheld7">&nbsp;&nbsp;1.因为POST解码是在第一次调用getParameter之前，那么那么解决乱码则需要在该方法之前设置编码。request.setCharacterEncoding("UTF-8");</a>
</h3>
<h3 class="topic">
<a name="281m5pm43jam5l8g50feod74hc">&nbsp;4.获得表单参数的方法</a>
</h3>
<h3 class="topic">
<a name="1iu2f08alqqdcunne2e4097ja9">&nbsp;&nbsp;1.String getParameter();根据键获得值，  Map getParameterMap();获得服务器保存表单参数的容器，  Enumeration getParameterNames();获得提交的所有键，  String[ ] getParameterValues(String name);根据键获得值</a>
</h3>
<h3 class="topic">
<a name="230j1q0pj1ugrls4rvftqnip4a">&nbsp;5.request请求转发和包含功能</a>
</h3>
<h3 class="topic">
<a name="6o7q23g69u19t3f4bgj87sbhmi">&nbsp;&nbsp;1.转发：一个Servlet处理完毕交给下面的Servlet（JSP）继续处理。作用：完成分工：Servlet处理业务，JSP完成显示功能。注意：转发的时候，从分工上讲Servlet中不要做输出正文的动作（没有效果）。</a>
</h3>
<h3 class="topic">
<a name="7ki7h41d3mgkufbuoucuaob6su">&nbsp;&nbsp;2.request.getDispatcher("  ").forward(request,response);  request.getDispatcher("  ").include(request,response);</a>
</h3>
<h3 class="topic">
<a name="5bal2rjpqggvd8ncafiq4be53s">&nbsp;6.request域</a>
</h3>
<h3 class="topic">
<a name="5q45cpeevg5ga1dq23hkqbq565">&nbsp;&nbsp;1.使用请求转发时，Servlet处理完数据，处理结果要交给JSP显示，可以使用request域将处理结果由Servlet带给JSP显示</a>
</h3>
<h3 class="topic">
<a name="141dohjpj811i6u5s4rrl7o0h7">&nbsp;&nbsp;2.常用的操作方法。setAttribute;  getAttribute;  getAttributeNames;  removeAttribute;</a>
</h3>
<h3 class="topic">
<a name="6iv2pvudn2qrqg3aha8veasece">&nbsp;&nbsp;3.request范围：一个request对应一个request域，有多少request就有多少request域</a>
</h3>
<h2 class="topic">
<a name="5vjpck0do5244m4qgdse92ah49">六、路径小结</a>
</h2>
<h3 class="topic">
<a name="3nd3samcbbavf0cg68s45m8dq2">&nbsp;1.客户端路径（给浏览器用的路径）</a>
</h3>
<h3 class="topic">
<a name="5gvcnln3adkjo49qf3i3lkfa6k">&nbsp;&nbsp;1.&lt;from action="  "&gt;;  &lt;a href="  "&gt;;  &lt;img src="  "&gt;;  response.sendRequestDispatcher("url");  Refresh:3;url="  "</a>
</h3>
<h3 class="topic">
<a name="77403a442b9aiirh9dpm3vdsr9">&nbsp;&nbsp;2.客户端路径的写法</a>
</h3>
<h3 class="topic">
<a name="7u68jtbkhq5tlj8qhukfcv8d9r">&nbsp;&nbsp;&nbsp;1.带"/"  :  "/" 表示相对主机。例如，表单所在页面路径为--&gt;http://localhost:8080/day12/index.jsp , "/"代表http://localhost:8080/  。在JSP页面等可以使用request.getContextPath()得到应用路径，这样移动index.jsp页面到其他应用目录下时，不用做多余的修改。</a>
</h3>
<h3 class="topic">
<a name="2as7u6edbr3kdn4mtmumbq7n6u">&nbsp;&nbsp;&nbsp;不带&ldquo;/"： 表示从当前目录中找（开发中尽量避免不带&rdquo;/"的情况）。例，表单所在页面路径为http://localhost:8080/day12/index.jsp表示为http://localhost:8080/day12/    。一旦移动该页面到其他应用，还要对路径做相应的修改，不推荐。</a>
</h3>
<h3 class="topic">
<a name="3qkoch9ft61njopc1o93sm1n7t">&nbsp;&nbsp;3.服务器端路径写法</a>
</h3>
<h3 class="topic">
<a name="5nk3jsdpjt7jjve01vnln16s32">&nbsp;&nbsp;&nbsp;1.&ldquo;/"相对于项目。例如http://localhost:8080/day12/ServletDemo中就是相对于如http://localhost:8080/day12/这一段。</a>
</h3>
<h2 class="topic">
<a name="2dv4mc2b4n2enoncfrco0qir8d">七、JSP概述</a>
</h2>
<h3 class="topic">
<a name="63rsldjoc3i2qlm44qa3nsv5l3">&nbsp;1.JSP(java server page)  可以在tomcat中的work/catalina/localhost/day12/org/apache/jsp中可以查看.jsp文件转化后的文件</a>
</h3>
<h3 class="topic">
<a name="3mh7eig0s94ao43k0npjnv6u9i">&nbsp;2.JSP的构成：HTML+JSP脚本（JAVA）+标签。HTML代码会使用out.write()拼接输出。</a>
</h3>
<h3 class="topic">
<a name="4e68vp69ruhntoocsg3i36cn5m">&nbsp;3.JSP中的脚本</a>
</h3>
<h3 class="topic">
<a name="1vujv8u7cuclctev8cev8uj54v">&nbsp;&nbsp;1.声明标签&lt;%   %&gt;, 标签中可以写Java代码，该脚本中写的Java代码会生成到JSP对应类中的service方法中。</a>
</h3>
<h3 class="topic">
<a name="0hcub6eo18b5su0n6pnijstr6i">&nbsp;&nbsp;2.表达式&lt;%= i%&gt;, 编译之后的代码：out.print(i);</a>
</h3>
<h3 class="topic">
<a name="4lkpmkae4javok8bvvqrdda7b1">&nbsp;&nbsp;3.声明标签&lt;%! int i=0; %&gt;，编译之后，脚本中的代码会出现在类中，可以使用该脚本定义全局变量和方法。</a>
</h3>
<h3 class="topic">
<a name="1s3a1tb6lmd12rsnlq7mfqiqmh">&nbsp;&nbsp;4.注释&lt;%-- --%&gt;, 被注释掉的内容不会参与编译。注意和&lt;!-- --&gt;html注释的区别。</a>
</h3>
<h2 class="topic">
<a name="6fbjlneupigqcrj4b6hbvf6a82">八、Cookie</a>
</h2>
<h3 class="topic">
<a name="4dvsg3jdqcnn8ojjtu5n8n8s74">&nbsp;1.cookie原理：让浏览器记住键值对，是向响应头中添加一下头即可set-cookie:name=robin;  浏览器记住之后，向服务器发送键值对，是在请求头中添加下面的信息cookie:name=robin。</a>
</h3>
<h3 class="topic">
<a name="55gb33bbfnvoed9likg8lshr2d">&nbsp;2.添加一个cookie到浏览器</a>
</h3>
<h3 class="topic">
<a name="7hj9hqpn5nbsmeq3bci75rgllk">&nbsp;&nbsp;1.新建一个cookie（键值对）。Cookie cookie=new Cookie("name","robin");</a>
</h3>
<h3 class="topic">
<a name="6n66kqnqhbflgk4i5hn8tpv38b">&nbsp;&nbsp;2.将cookie添加到响应中。response.addCookie(cookie);</a>
</h3>
<h3 class="topic">
<a name="48ilt5lpaah6bfpirtnspbsblq">&nbsp;3.让浏览器发送cookie到服务器</a>
</h3>
<h3 class="topic">
<a name="3fsmqq16jk7cnvom8s1fk56neh">&nbsp;&nbsp;1.获得所有浏览器发送的cookie。Cookie[ ] cookies=request.getCookies();</a>
</h3>
<h3 class="topic">
<a name="2mfr5jjsdu8l6nasl7jbrkp2gn">&nbsp;&nbsp;2.遍历并判断我们要找的cookie。if(cookies!=null&amp;&amp;cookies.length)&gt;0{for(Cookie c:cookies){if(c.getName().equals("name"){... ...}}}}</a>
</h3>
<h3 class="topic">
<a name="3qtf1f1fpn12uagefg710oie09">&nbsp;4.浏览器记录cookie的时间及其设置</a>
</h3>
<h3 class="topic">
<a name="3crl3eo4gdqnavd9s1rvi4g77v">&nbsp;&nbsp;1.默认是在会话期间有效（关闭浏览器，cookie就会被删除）</a>
</h3>
<h3 class="topic">
<a name="5frotaqdn9gtdi5vh1ofth2g16">&nbsp;&nbsp;2.有效时间的设置。Cookie cookie= new Cookie("age","18");  cookie.setMaxAge(60*60);//单位是秒。  cookie.setMaxAge(-1);//设置为-1，就是相当于默认的有效时间，浏览器关闭就消失。 cookie.setMaxAge(0);//表示cookie一发送到浏览器就消失了。注：可以利用有效时间为0这个特性进行删除cookie的操作。</a>
</h3>
<h3 class="topic">
<a name="76bavpqri7jqe7s43tffp8h33p">&nbsp;5.浏览器发送cookie的时机</a>
</h3>
<h3 class="topic">
<a name="5auqp2818944ngn5fhujbf457b">&nbsp;&nbsp;1.cookie默认的时机就是发送cookie的Servlet所在的目录。例：day13/    ，   访问路径如果是该cookie的子路径，浏览器就会把该cookie带给服务器，例：/day13/abcd/xxServlet</a>
</h3>
<h3 class="topic">
<a name="42chhs0g7vqaphsc29n1m7525d">&nbsp;&nbsp;2.访问特定Servlet发送cookie。cookie.setPath("day13/ServletDemo");</a>
</h3>
<h3 class="topic">
<a name="4p1u0aob2gcc580q25m3tf219m">&nbsp;6.cookie中的域</a>
</h3>
<h3 class="topic">
<a name="2j1jorftpucfj0mfb2c6epfspc">&nbsp;&nbsp;1.想要一下三个主机能共享一个cookie，www.robin.com;music.robin.com;basketball.robin.com,完成一下两步设置即可1，设置cookie的domain为".robin.com"，设置cookie的path为"/"。以上就是跨主机访问cookie</a>
</h3>
<h2 class="topic">
<a name="5lpln2kabbg91kr92j72f82nlk">九、Session</a>
</h2>
<h3 class="topic">
<a name="7ujq0qfpq7so2gfprtuqhs3obf">&nbsp;1.Session技术：服务器端保存会话信息的技术。原理：浏览器第一次访问服务器，服务器会在内存中开辟一个空间（session），并把该session对应的ID发送给浏览器，当下次浏览器再去访问服务器，会把SessionID交给服务器，服务器通过SessionID找到刚才开辟的空间。注：请求头中cookie:JessionID=......;...  ...</a>
</h3>
<h3 class="topic">
<a name="722p3t3j8v2ikqlb3auptcutb9">&nbsp;2.SessionID丢失的时间</a>
</h3>
<h3 class="topic">
<a name="7crn395a1imbv06o8tmoai8bf6">&nbsp;&nbsp;1.服务器让浏览器记住SessionID的cookie的默认过期时间是（-1），关闭浏览器cookie就丢失，也就是说cookie丢失，SessionID就丢失了。</a>
</h3>
<h3 class="topic">
<a name="7jggm7hucs4v3uiui11engceuq">&nbsp;3.session的方法</a>
</h3>
<h3 class="topic">
<a name="3e375gk2bpcgfuhe6uk91koevf">&nbsp;&nbsp;1.  获得session,request.getSession();</a>
</h3>
<h3 class="topic">
<a name="7jmtgen7qplfnmuavcoqu1mrjd">&nbsp;&nbsp;2.   4个操作Map的方法</a>
</h3>
<h3 class="topic">
<a name="3ml2g5gmsvl16kv19d0uruk1gs">&nbsp;&nbsp;3.其他方法。long getCreationTime();//获得创建时间，     String getId();//获得sessionID，     long getLastAccessedTime();//获得最后一次访问的时间，     int getMaxInactiveInterval();//获得最大存活时间（session），   void setMaxInactiveInterval(int interval);//设置最大存活时间，    void invalidate();//立刻销毁Session，  boolean isNew();//是否是新创建的Session。</a>
</h3>
<h3 class="topic">
<a name="1a5lg03csna0knv0de9468moq6">&nbsp;4.session最大有效时间的设置</a>
</h3>
<h3 class="topic">
<a name="4ae7uhajrupf93ptnldr1de2n7">&nbsp;&nbsp;1.默认30分钟。 Tomcat的web.xml的&lt;session-config&gt;标签中有该配置。</a>
</h3>
<h3 class="topic">
<a name="7emc78068gt3vbo1cf4e0kc462">&nbsp;&nbsp;2.session过期时间的修改</a>
</h3>
<h3 class="topic">
<a name="7k58944m44ff2icnci2c5919o6">&nbsp;&nbsp;&nbsp;1.修改Tomcat的web.xml的&lt;session-config&gt;标签，影响服务器中的所有项目</a>
</h3>
<h3 class="topic">
<a name="4d4ru2b9f39am6ah789tnvrblk">&nbsp;&nbsp;&nbsp;2.在项目的web.xml中加入&lt;session-config&gt;配置，影响的是当前项目</a>
</h3>
<h3 class="topic">
<a name="11nnvgt3i9obpamj6alpo1651j">&nbsp;&nbsp;&nbsp;3.通过setMaxInactiveInterval(int interval)方法设置，影响的是当前操作的Session</a>
</h3>
<h3 class="topic">
<a name="7ipcb08glpc71hq6b1uq1sv58f">&nbsp;5.钝化和激活</a>
</h3>
<h3 class="topic">
<a name="3ab9rjgnm6afuut9ksv9d8g6be">&nbsp;&nbsp;1.服务器内存消耗太大</a>
</h3>
<h3 class="topic">
<a name="2832gel5dl85dlgfdqip5r86pr">&nbsp;&nbsp;2.某些HTTPSession对象已经长时间不用了，但还不至于销毁</a>
</h3>
<h3 class="topic">
<a name="4cknforg26ih7765j2f99a6473">&nbsp;&nbsp;3.服务器重启了</a>
</h3>
<h3 class="topic">
<a name="0e9htrhqb1d5mt78m4vg4mk61u">&nbsp;6.URL重写</a>
</h3>
<h3 class="topic">
<a name="5t0sv2fk1c3c7tqn2fks0ep235">&nbsp;&nbsp;1.如果浏览器禁用cookie功能不能保存任何cookie，那么session技术要用cookie来保存SessionID，没有cookie的话如何操作？使用URL重写：将页面中所有的链接末尾都加上cookie id的参数（jessionid=...），这样用户点击链接访问网站时，通过URL把SessionID带到服务器，这样就解决了。</a>
</h3>
<h3 class="topic">
<a name="036nan6hvin7i8t3omghdp6loj">&nbsp;7.Servlet技术中三大域对象小结</a>
</h3>
<h3 class="topic">
<a name="7if8e5jii8l2960knkhovgabdd">&nbsp;&nbsp;1.application--&gt;ServletContext:范围是整个项目，只有一个ServletContext对象，所有的Servlet组件都能被访问到</a>
</h3>
<h3 class="topic">
<a name="5ogmhrhtjlas1fcqla2cbepp0h">&nbsp;&nbsp;2.session--&gt;HttpSession:范围是一次会话，一个没有保存SessionID的浏览器链接到服务器就会开启一个会话，有多少个浏览器访问就至少有多少个Session</a>
</h3>
<h3 class="topic">
<a name="32aa31vslhg6a8vbr17u6mjds3">&nbsp;&nbsp;3.request--&gt;HttpServletRequest:范围是一次请求之内，当前正在处理的请求有多少个就存在几个request域</a>
</h3>
<h2 class="topic">
<a name="11evl2iloeca8ud09kl38j9uq8">十、JSP指令元素</a>
</h2>
<h3 class="topic">
<a name="285nv9lf4dmrfnmg7omnfj81v5">&nbsp;1.JSP指令写法和分类</a>
</h3>
<h3 class="topic">
<a name="3ru4fnnloik3nni8ba4q4a66lf">&nbsp;&nbsp;1.写法：&lt;%@  指令  属性=&ldquo;  &rdquo; %&gt;</a>
</h3>
<h3 class="topic">
<a name="6a7qebs08ipdkqj4h4ced8j941">&nbsp;&nbsp;2.page指令标记</a>
</h3>
<h3 class="topic">
<a name="6c7q1hup5fdtpi6q58b1ae5hsi">&nbsp;&nbsp;&nbsp;1.page属性包含在"&lt;%@page"和"%&gt;"之间</a>
</h3>
<h3 class="topic">
<a name="7rre701slq9ont3rqt7ptnjutp">&nbsp;&nbsp;&nbsp;2.这些属性可以单独存在，也可以几个或多个同时使用</a>
</h3>
<h3 class="topic">
<a name="76n4slqgqlnl8cl4n4hum2796m">&nbsp;&nbsp;&nbsp;3.page指令用来定义JSP文件的全局属性</a>
</h3>
<h3 class="topic">
<a name="5ekqse61lk9qp83c1tfms2aoc0">&nbsp;&nbsp;&nbsp;4.在JSP页面中，只有import可以出现多次，其他属性都只能出现一次</a>
</h3>
<h3 class="topic">
<a name="6ojc3jf762okuj99egcn1g1eaj">&nbsp;&nbsp;3.page属性</a>
</h3>
<h3 class="topic">
<a name="1c8t1ka2tru4mkjs83087km5mn">&nbsp;&nbsp;&nbsp;1.language:描述当前页面使用的语言（目前取值只有Java）language="java"</a>
</h3>
<h3 class="topic">
<a name="4eabuld2i3d0c8dgoeoepsjcve">&nbsp;&nbsp;&nbsp;2.import:用于导入Java包或类的列表。唯一一个可以出现多次的属性。例：import="java.util.Date"</a>
</h3>
<h3 class="topic">
<a name="6e51htav54dqos4boum2lejs0k">&nbsp;&nbsp;&nbsp;3.pageEncoding:决定服务器读取JSP时，采用什么编码。pageEncoding="UTF-8"</a>
</h3>
<h3 class="topic">
<a name="3fk4q3s2kbe9s6sc5gn39s3qju">&nbsp;&nbsp;&nbsp;4.contentType="text/html;charset=UTF-8"响应浏览器时，告诉浏览器用什么码表解码。注：contentType和pageEncoding属性只需指定一个，另外一个会自动指定。</a>
</h3>
<h3 class="topic">
<a name="5paqblb50sq4a4n9eprj2tmqfv">&nbsp;&nbsp;&nbsp;5.buffer=&ldquo;8kb"：决定缓存的大小</a>
</h3>
<h3 class="topic">
<a name="544u44a26ubai92rmeibifv4m2">&nbsp;&nbsp;&nbsp;6.autoFlush="true"：如果缓存写满了，如果该属性为true，会将缓存中的内容自动输出到浏览器</a>
</h3>
<h3 class="topic">
<a name="4p1hm8g3r846vti1o278lvlrik">&nbsp;&nbsp;&nbsp;7.errorPage="  "：当JSP页面出现了异常，指定要跳转到的页面</a>
</h3>
<h3 class="topic">
<a name="7c7cbcc0r8a5fqf7danrmk8avu">&nbsp;&nbsp;&nbsp;8.isErrorPage="false":标识当前页面是否是处理错误的页面。拓展：错误页面可以使用下面的统一配置。&lt;error-page&gt;&lt;error-code&gt;500&lt;/error-code&gt;&lt;location&gt;/Error/ErrorDemo.jsp&lt;/location&gt;&lt;/error-page&gt;</a>
</h3>
<h3 class="topic">
<a name="65ro3n086ig2kpjcmjmmqgq1d9">&nbsp;&nbsp;&nbsp;9.session="true"（一般不要修改）：页面中是否使用session对象。如果为false，那么session内置对象会消失，默认为true</a>
</h3>
<h3 class="topic">
<a name="77nrds4mt6ludffcthv1i41mn7">&nbsp;&nbsp;&nbsp;10.extends=&ldquo;  &rdquo;：一般不用。JSP生成的Java文件继承哪个类。默认继承：org.apache.jasper.runtime.HttpJspBase</a>
</h3>
<h3 class="topic">
<a name="7bs9a9ddunkvnmf3vfa5pc90f3">&nbsp;&nbsp;&nbsp;11.isELIgnored:用来指定EL表达式语言是否被忽略。true则忽略，false则计算表达式的值</a>
</h3>
<h3 class="topic">
<a name="3r686h2nv442fskmnokbk4588e">&nbsp;&nbsp;4.include指令标记</a>
</h3>
<h3 class="topic">
<a name="2odh96efrm4k61ng6djncvmi8f">&nbsp;&nbsp;&nbsp;1.&lt;%@include  file="filename"%&gt;</a>
</h3>
<h3 class="topic">
<a name="33pq2gcbshrgv3u16h3kea5ps0">&nbsp;&nbsp;&nbsp;2.include指令的作用是在JSP页面中静态包含一个文件，同时由JSP解析包含的文件内容</a>
</h3>
<h3 class="topic">
<a name="5rsvlpjkinisi9fahobjfnrufa">&nbsp;&nbsp;&nbsp;3.不可以在file所指定的文件后面接任何参数。&lt;%@include  file="jw.jsp?nm=browser"</a>
</h3>
<h3 class="topic">
<a name="11rh6v0km0cte2n0iot6283bi7">&nbsp;&nbsp;5.taglib指令标记</a>
</h3>
<h3 class="topic">
<a name="7ntibibba3jn70qt9vvh071bbo">&nbsp;&nbsp;&nbsp;1.taglib指令用于在JSP页面中导入标签库。常用的标签库JSTL</a>
</h3>
<h3 class="topic">
<a name="1mc62v3ndgtqml46r89l6qpha4">&nbsp;&nbsp;&nbsp;2.常用属性。uri:标签文件的URL地址，prefix：标签组的命名空间前缀</a>
</h3>
<h2 class="topic">
<a name="0in3mjp4oi1a3il3hamnbj56ku">十一、JSP九大内置对象</a>
</h2>
<h3 class="topic">
<a name="3p4uc5v9322mn6e8ot89aou17d">&nbsp;1.九大内置对象。HTTPServletRequest  request;   HTTPServletResponse  response;  HTTPSession session;  ServletContext application;  ServletConfig config;  Throwable exception;           Object page;  JspWriter out;  pageContext pageContext</a>
</h3>
<h3 class="topic">
<a name="47pdiu9qrr8igll6pm1ja55t8p">&nbsp;2.page对象一般指向了Servlet的实例（一般不用）</a>
</h3>
<h3 class="topic">
<a name="4mhd2q7t1tg49uul0ce5n3pd2g">&nbsp;3.JSPWriter对象</a>
</h3>
<h3 class="topic">
<a name="140e7a3vlsb3sbqvva6j8o2lj7">&nbsp;&nbsp;1.JSP中都使用JSPWriter再向外输出内容</a>
</h3>
<h3 class="topic">
<a name="2m3ftc3ur0g2279b81hnoco60a">&nbsp;&nbsp;2.response.getWriter和JSPWriter的区别：response.getWriter的输出会出现在JSPWriter输出的前面；JSPWriter缓存会附加到response.getWriter缓存后，最终输出response.getWriter缓存。注：JSP中不要直接使用response.getWriter</a>
</h3>
<h3 class="topic">
<a name="07p99ab49dqnugqr0v9ekhgoiq">&nbsp;4.pageContext对象</a>
</h3>
<h3 class="topic">
<a name="0djirprpnhma1viv5qomj8b5jl">&nbsp;&nbsp;1.page域：范围只在当前页面中（4个域中最小的一个域）。常用方法：setAttribute( , );  getAttribute();  removeAttribute();</a>
</h3>
<h3 class="topic">
<a name="2fttokn3v5n6c851lgnc6a4clu">&nbsp;&nbsp;2.操作其他三个域。以操作request域为例。</a>
</h3>
<h3 class="topic">
<a name="4eb0tggjimeb1mqu0khlrfcali">&nbsp;&nbsp;&nbsp;1.存值pageContext.setAttribute("name","robin",pageContext.REQUEST_SCOPE);</a>
</h3>
<h3 class="topic">
<a name="6f7re4s8h9clqi0sfii3oclfp0">&nbsp;&nbsp;&nbsp;2.取值 pageContext.getAttribute("name",pageContext.REQUEST_SCOPE);</a>
</h3>
<h3 class="topic">
<a name="1plp809qlk4v6jkno8csd20mgr">&nbsp;&nbsp;&nbsp;3.遍历所有键pageContext.getAttributeNamesInScope(pageContext.REQUEST_SCOPE);</a>
</h3>
<h3 class="topic">
<a name="3ii9dg130ecq44acv9gi7ct6ea">&nbsp;&nbsp;&nbsp;4.删除一个值pageContext.removeAttribute("name",pageContext.REQUEST_SCOPE);</a>
</h3>
<h3 class="topic">
<a name="73gb7gsl9d0o9mg7cr2n23r1le">&nbsp;&nbsp;3.获得其他八个内置对象</a>
</h3>
<h3 class="topic">
<a name="24krhrksh97kmikqnnq2nk4qo9">&nbsp;&nbsp;&nbsp;1.getRequest();  getResponse();  getSession;  ...  ...</a>
</h3>
<h2 class="topic">
<a name="65bqk4iqlpge6caeulufp707gj">十二、JSP标签</a>
</h2>
<h3 class="topic">
<a name="6l587au07ninlgfkcfqfoalhgg">&nbsp;1.已经不怎么用了，暂时略过</a>
</h3>
<h2 class="topic">
<a name="2nmqmaegdm1lgr237i7heujg40">十三、EL表达式</a>
</h2>
<h3 class="topic">
<a name="3qf2e504m79ldvqsv5dq8ak7cb">&nbsp;1.功能：替换掉页面中的表达式(&lt;%=表达式 %&gt;)</a>
</h3>
<h3 class="topic">
<a name="3belrm4rqp8p3rjgkj2nm6nq9b">&nbsp;2.EL内置对象</a>
</h3>
<h3 class="topic">
<a name="4a896su0vdqh28bsmglhst0rg4">&nbsp;&nbsp;1.通过四大内置对象对四大域进行访问</a>
</h3>
<h3 class="topic">
<a name="34iuito71h4hef9hvederholco">&nbsp;&nbsp;&nbsp;1.包括requestScope;  sessionScope;  applicationScope;  pageScope</a>
</h3>
<h3 class="topic">
<a name="3cfea5si815lac9nqqmrfh7ce4">&nbsp;&nbsp;&nbsp;2.使用格式。${requestScope.name};  ${sessionScope.name};  ${applicationScope.name};  ${pageScope.name}  ,这些表达式表示从四大域中取出键为name的值。${name}从最小的域开始，找key为name的属性值。</a>
</h3>
<h3 class="topic">
<a name="6enao77fmf8kces3d9kplgofao">&nbsp;&nbsp;&nbsp;3.域操作示例</a>
</h3>
<h3 class="topic">
<a name="5sbv5u02k4rrjrsv09m0ngn9tk">&nbsp;&nbsp;&nbsp;&nbsp;1.${requestScope.user.name}和${requestScope.user['name']等价于&lt;%((User)request.getAttribute("user")).getName(); %&gt;</a>
</h3>
<h3 class="topic">
<a name="1192vlj1kgpk6b899q7ed7gn4m">&nbsp;&nbsp;&nbsp;&nbsp;2.例：先存值，&lt;%String[ ] array=new String[ ]{"jack","rose","jerry","tom"};  request.setAttribute("array",array);%&gt;     通过EL取值，${requestScope.array[1]}   --&gt;rose</a>
</h3>
<h3 class="topic">
<a name="14n78u26h9n3ckn0cjkhps15gc">&nbsp;&nbsp;2.其他内置对象</a>
</h3>
<h3 class="topic">
<a name="60k73n23juqvll3ajtj1nsa5th">&nbsp;&nbsp;&nbsp;1.param 和paramValues这两个对象封装了表单参数</a>
</h3>
<h3 class="topic">
<a name="51ntgj05ns71b3u2ntcq5bc8hr">&nbsp;&nbsp;&nbsp;2.header和headerValues封装了HTTP请求头</a>
</h3>
<h3 class="topic">
<a name="7bttim9tkrkka9ajkgo8ttaikb">&nbsp;&nbsp;&nbsp;3.initParam封装了web.xml中的配置</a>
</h3>
<h3 class="topic">
<a name="2aa3de327e24cc8nbl0v4p0hcp">&nbsp;&nbsp;&nbsp;4.pageContext封装了九大内置对象的pageContext</a>
</h3>
<h3 class="topic">
<a name="3vou9cv9hqjm62j49i2ejk7qtq">&nbsp;&nbsp;&nbsp;5.cookie封装了cookie信息</a>
</h3>
<h3 class="topic">
<a name="2btgvhn4s5ukb7onm65ld4qukl">&nbsp;3.EL表达式中支持比较运算符和逻辑运算符。${empty  p1}，    empty：判断一个对象是否为null，String是否为&ldquo; &rdquo;，集合中是否有元素</a>
</h3>
<h3 class="topic">
<a name="4c3ds75lasj1m4d30p3fgo7iul">&nbsp;4.EL函数库</a>
</h3>
<h3 class="topic">
<a name="33n04pfkn22hghu8cpsehclrel">&nbsp;&nbsp;1.作用：简化页面中静态方法的调用，使用EL函数代替Java代码</a>
</h3>
<h3 class="topic">
<a name="7p8v4bast6751dfselb90q0ir1">&nbsp;&nbsp;2.自定义EL函数库过程</a>
</h3>
<h3 class="topic">
<a name="3o8onpj6252euq9m15ib0563tp">&nbsp;&nbsp;&nbsp;1.定义工具类，在类中定义静态方法</a>
</h3>
<h3 class="topic">
<a name="6ic9h57h80ri2v55or2vdoku4e">&nbsp;&nbsp;&nbsp;2.填写配置文件xxx.tld放置到WEB-INF下</a>
</h3>
<h3 class="topic">
<a name="1a9d3bhgmj5vhsmds84vfteopg">&nbsp;&nbsp;&nbsp;3.配置文件中内容。参考笔记</a>
</h3>
<h3 class="topic">
<a name="7ne11g83la9ckdi9soc09vagvh">&nbsp;5.系统自带的EL函数</a>
</h3>
<h3 class="topic">
<a name="1g512fh9tsr9u9dmvb5l3isa2e">&nbsp;&nbsp;1.${fn:contains("hello","el")}  判断是否包含</a>
</h3>
<h3 class="topic">
<a name="5ekpjkafi26js8k9238ah7rj5s">&nbsp;&nbsp;2.${fn:endsWith("abcd","cd")}  判断是否以某字符串结尾</a>
</h3>
<h3 class="topic">
<a name="3si34mce88ehi26dddbbhahihr">&nbsp;&nbsp;3.${fn:escapeXml("&lt;font color='red'&gt;haha&lt;/font&gt;")}  自动将HTML关键字符转义</a>
</h3>
<h2 class="topic">
<a name="5f9892ap3e33arhkm5t5uan1ro">十四、自定义标签（简单标签）</a>
</h2>
<h3 class="topic">
<a name="5b7s3qgjf0c7s06p37g2r2gunk">&nbsp;1.标签作用：自定义标签属于JSP规范.替换掉JSP中的JSP脚本&lt;% %&gt;，实现一些简单的逻辑运算。</a>
</h3>
<h3 class="topic">
<a name="5v4c1jcv65hqoog7nih8gol960">&nbsp;2.标签开发步骤</a>
</h3>
<h3 class="topic">
<a name="7icuceoopk49qf3svkhgmqoqg0">&nbsp;&nbsp;1.编写一个类，实现一个接口javax.servlet.jsp.tagext.SimpleTag或者继承javax.servlet.jsp.tagext.SimpleTagSupport。具体例子参照笔记</a>
</h3>
<h3 class="topic">
<a name="4s7ujh2nr9okhvrv2buh10n944">&nbsp;&nbsp;2.在WEB-INF目录下，建立一个扩展名为tld(Tag Library Definition)的xml文件。注：tld文件在WEB-INF或者jar包的META-INF目录下，都能自动找到。配置文件的写法参照笔记</a>
</h3>
<h3 class="topic">
<a name="2c3adpn67tqnvm3fatv8564iet">&nbsp;&nbsp;3.在JSP中使用。引入&lt;%@ taglib uri="http://www.robinliew.com/simpletag"  prefix="xxx" %&gt;   ,使用时标签的写法：&lt;xxx:ShowTime/&gt;</a>
</h3>
<h2 class="topic">
<a name="4qgqjemnt67k7jdt5qb1a3m8a8">十五、JSTL标签库</a>
</h2>
<h3 class="topic">
<a name="6tcq3oavg99i6lcku3e51n651v">&nbsp;1.JSTL简单介绍</a>
</h3>
<h3 class="topic">
<a name="561bs4spitbl2l0gs3rb65hkeq">&nbsp;&nbsp;1.JSTL：Java Standard Tag Library。Apache实现的一套标准的标签库(可访问JCP.org)</a>
</h3>
<h3 class="topic">
<a name="6u00j8b7fc2s5q4u1ngs4djkpa">&nbsp;&nbsp;2.由五部分组成：Core:核心    Functions:EL函数     Format：国际化    SQL：操作数据库    Xml：操作xml</a>
</h3>
<h3 class="topic">
<a name="0dm6nbhbtefom0r2mi0l3ep0ji">&nbsp;&nbsp;3.常用的core标签</a>
</h3>
<h3 class="topic">
<a name="3h16kk0fbs0m6enf4igkdn60ak">&nbsp;&nbsp;&nbsp;1.c:out 输出数据到页面上。&lt;c:out  value="${p}"  default="木有&ldquo;" esccpeXml="true"&gt;&lt;/c:out&gt;  其中escapeXml属性表示是否转义。</a>
</h3>
<h3 class="topic">
<a name="3n1hul39g1jo72gr0hhn647s0p">&nbsp;&nbsp;&nbsp;2.c:if    如果test表达式的值为 true 则执行其主体内容var属性：记住test表达式的运行结果；  scope：page（默认）|request|session|application 。例，&lt;c:if  test="${1==1}"   var="result"&gt;相等&lt;/c:if&gt;  。</a>
</h3>
<h3 class="topic">
<a name="5mu8002sgeqdvbmr5q72be0ian">&nbsp;&nbsp;&nbsp;3.c:choose    c:when     c:otherwise组合起来模拟了if  else  if</a>
</h3>
<h3 class="topic">
<a name="6lk0a73uudr9njrb7jhvvcomsu">&nbsp;&nbsp;&nbsp;4.c:forEach   模拟了for循环。迭代：数组，集合，Map和String（用逗号分隔）</a>
</h3>
<h3 class="topic">
<a name="49fac88bem6rofgl2hpc1rvvcd">&nbsp;&nbsp;&nbsp;5.c:url   对地址进行url重写，还能进行url编码</a>
</h3>
<h3 class="topic">
<a name="74nte3k14v71evjonetd578oro">&nbsp;&nbsp;&nbsp;6.c:import  动态包含，可以包含任何页面</a>
</h3>
<h3 class="topic">
<a name="5om6or0155kh2vb1gn4qnp2eso">&nbsp;&nbsp;&nbsp;7.c:forTokens  用分隔符隔离字符串</a>
</h3>
<h3 class="topic">
<a name="3o1q5hpojbe97tma114prl2eu0">&nbsp;&nbsp;&nbsp;8.c:set  用于设置变量值和对象属性</a>
</h3>
<h3 class="topic">
<a name="5v1t4rbge0pn4kdtc7reajehoa">&nbsp;&nbsp;&nbsp;9.具体用法可以参照笔记或网站http://www.runoob.com/jsp/jsp-jstl.html</a>
</h3>
<h3 class="topic">
<a name="2a609os3k41dfjf4nk8jbosbpd">&nbsp;2.JSTL自定义标签</a>
</h3>
<h2 class="topic">
<a name="4phf63keua0t9v275pdsrck24o">十六、SQL</a>
</h2>
<h3 class="topic">
<a name="6n3pkslfvrufn8004f2qdeqd1r">&nbsp;1.SQL：Structured Query Language 结构化查询语言。作用：是一种定义、操作、管理关系数据库的句法。</a>
</h3>
<h3 class="topic">
<a name="0cc6rgqmtm51kidgn7lhd0l67h">&nbsp;2.SQL语句的组成。DQL：结构查询语言     DML：数据操作语言     DDL：数据定义语言    DCL：数据控制语言     TPL：事务处理语言    CCL：指针控制语言</a>
</h3>
<h3 class="topic">
<a name="6mmv1rakc9347gbaoeck7gh2br">&nbsp;3.关系性数据库</a>
</h3>
<h3 class="topic">
<a name="36n553k58hkt72u5dti8q38h7i">&nbsp;&nbsp;1.属性：用来描述所在列的项目的语义</a>
</h3>
<h3 class="topic">
<a name="4u31m9904b1bftqrnvs5uvu1a2">&nbsp;&nbsp;2.模式：关系名和其属性集合的组合称为这个关系的模式。例，Movies(title,year,length,genre)。在关系模型中，数据库是由一个或多个关系组成。</a>
</h3>
<h3 class="topic">
<a name="1cj7agq586prcqckbna019g5ij">&nbsp;&nbsp;3.元组：关系中除含有属性名所在行以外的其他行称为元组（turple）。每个元组均有一个分量（component）对应于关系的每个属性。</a>
</h3>
<h3 class="topic">
<a name="3g1r6r3l572e2llagh11pavrrv">&nbsp;&nbsp;4.原子性。关系模型要求元组的每个分量具有原子性。也就是说，它必须属于某种元素类型，如Integer或String，而不能是记录，集合，数组或者其他任何可以分解成更小分量的组合类型。</a>
</h3>
<h3 class="topic">
<a name="0sdnu652omhrq5naikaopeq473">&nbsp;&nbsp;5.域：与关系的每个属性相关联的是一个域（domain），即一个特殊的元素类型，关系中任一元组的分量值必须属于对应列的域。例，关系Movies中四个分量对应的域分别是：String，integer，integer，String。Movies(title:string,year:integer,length:integer,genre:string)</a>
</h3>
<h3 class="topic">
<a name="5i3898eciviar5vt1qhrj7aqbf">&nbsp;&nbsp;6.关系实例：一个给定关系中元组的集合叫做关系的实例。关系的属性次序可以任意排列，关系不会改变，但重新排序关系模式时，要记住属性是列标题。</a>
</h3>
<h3 class="topic">
<a name="3p3199fnici1vbitqutucc16vg">&nbsp;&nbsp;7.键约束：键由关系的一组属性集组成，通过定义键可以保证关系实例上任何两个元组的值在定义键的属性集上取值不同。通常在形成键的属性或属性组下面画上下划线，用来表明它是键的组成部分。</a>
</h3>
<h3 class="topic">
<a name="6j3lult874t03ftpik0beallkd">&nbsp;4.SQL中的三类关系</a>
</h3>
<h3 class="topic">
<a name="7h18q3f5njnrnbianhn16vienl">&nbsp;&nbsp;1.存储关系，称为表（table）。这是通常要处理的一种关系，它在数据库中存储，用户能够对其元组进行查询和更新。</a>
</h3>
<h3 class="topic">
<a name="29a24jagflum3n7cb5c2p3ojab">&nbsp;&nbsp;2.视图（view），通过计算来定义的关系。这种关系并不在数据库中存储，它只是在需要的时候被完整或部分地构造。</a>
</h3>
<h3 class="topic">
<a name="4k8fgr7c2gtnancva900c192tm">&nbsp;&nbsp;3.临时表，它是在执行数据查询和更新时由SQL处理程序临时构造。这些临时表会在处理结束后被删除而不会存储在数据库里。</a>
</h3>
<h3 class="topic">
<a name="5qfs362f7rsscgk8835ppg606k">&nbsp;5.SQL中的数据类型</a>
</h3>
<h3 class="topic">
<a name="6fshm083ocdkfvo7f12r41o0ug">&nbsp;&nbsp;1.可变长度或固定长度的字符串</a>
</h3>
<h3 class="topic">
<a name="2edrmfvtd00mcu716crcns6lev">&nbsp;&nbsp;&nbsp;1.CHAR(n)：最大为n个字符的固定长度字符串</a>
</h3>
<h3 class="topic">
<a name="57f2cc3qbo289fsiki63rt8358">&nbsp;&nbsp;&nbsp;2.VARCHAR(n)：也表示最多可能有n个字符的字符串</a>
</h3>
<h3 class="topic">
<a name="4p7b3ju9v78jbqggcrqcktu2r9">&nbsp;&nbsp;&nbsp;3.区别：CHAR类型会以一些短的字符串来填充后面未满的空间来构成几个字符，而VARCHAR会使用一个结束符或字符长度值来标志字符串的结束，后面未满的空间不会做填充。</a>
</h3>
<h3 class="topic">
<a name="3ma2g1h8m672afqbcvo3qliju6">&nbsp;&nbsp;&nbsp;4.注：SQL中字符串是使用单引号</a>
</h3>
<h3 class="topic">
<a name="48slm3opk9f8ebggbe3ji4sv5t">&nbsp;&nbsp;2.类型INT和INTEGER表示典型的整数值。SHORTINT也表示整数，但表示的位数可能小一些，具体取决于实现。</a>
</h3>
<h3 class="topic">
<a name="1b1gm944iqmpdlnj9foo0n3vo8">&nbsp;&nbsp;3.浮点值能通过不同的方法表示</a>
</h3>
<h3 class="topic">
<a name="0vk0bfhssij9vmb3uunq03u1r2">&nbsp;&nbsp;&nbsp;1.FLOAT和REAL（同义词）：表示典型的浮点数值</a>
</h3>
<h3 class="topic">
<a name="5dup5cliq531hufetriaj7h80m">&nbsp;&nbsp;&nbsp;2.DOUBLE，PRECISION：高精度的浮点类型</a>
</h3>
<h3 class="topic">
<a name="496ulsfubj6jet715lailr264f">&nbsp;&nbsp;&nbsp;3.DECIMAL(n,d)：允许可以有n位有效数字的十进制，小数点是在右数第d位的位置。</a>
</h3>
<h3 class="topic">
<a name="2ljv819qi0v0p0taj0rnh44gcp">&nbsp;&nbsp;4.BOOLEAN表示具有逻辑类型的值。属性值是TRUE，FALSE，UNKNOWN</a>
</h3>
<h3 class="topic">
<a name="4309k5q36u823ti37v3jim1hoi">&nbsp;&nbsp;5.时间和日期分别通过TIME和DATA数据类型表示。例，TIME '15:00:02.5'    DATE '1948-05-14'</a>
</h3>
<h3 class="topic">
<a name="5p437of4fvg5g7f8od5kj55cn4">&nbsp;&nbsp;6.mysql和Java数据类型对比</a>
</h3>
<h3 class="topic">
<a name="1auefbc7oke3mr7c0prpd2b4o7">&nbsp;&nbsp;&nbsp;1.char(n)/varchar(n) ----String</a>
</h3>
<h3 class="topic">
<a name="0db7bb0kvk194jq7a9uemh5j3s">&nbsp;&nbsp;&nbsp;2.tinyint ----byte</a>
</h3>
<h3 class="topic">
<a name="4e2cbmtesmtd7rup2vokgkjpdl">&nbsp;&nbsp;&nbsp;3.smallint ----short</a>
</h3>
<h3 class="topic">
<a name="2j147gq1mmp1ci07gaf5osnag7">&nbsp;&nbsp;&nbsp;4.int ----int</a>
</h3>
<h3 class="topic">
<a name="6gjisl7hla93rfbascipssjfm1">&nbsp;&nbsp;&nbsp;5.bigint ----long</a>
</h3>
<h3 class="topic">
<a name="6picnlattt0gijc04i2baanbf7">&nbsp;&nbsp;&nbsp;6.double ----double</a>
</h3>
<h3 class="topic">
<a name="3ocjaj9fskmuq38pta1b3rbh17">&nbsp;&nbsp;&nbsp;7.bit(0/1) ----boolean</a>
</h3>
<h3 class="topic">
<a name="00vdg0ntv32vksl3f68lem35lk">&nbsp;&nbsp;&nbsp;8.Date/Time/DateTime/timeStamp ----Date</a>
</h3>
<h3 class="topic">
<a name="5u9vhmjmtfmn2tmkskh0q3gpdb">&nbsp;&nbsp;&nbsp;9.Blob/Text(大数据：图片，音频，视频二进制码；文本大数据)</a>
</h3>
<h3 class="topic">
<a name="0cl31dtchlpmcs200vhgr2il2t">&nbsp;6.DDL数据定义语言（对数据库的操作）</a>
</h3>
<h3 class="topic">
<a name="5p2m762ebd2d5f0adumumkcouc">&nbsp;&nbsp;1.常用关键字：create/alter/drop/truncate</a>
</h3>
<h3 class="topic">
<a name="266ji1fsash8jfcprj3dbj9pun">&nbsp;&nbsp;2.显示所有数据库：show databases;</a>
</h3>
<h3 class="topic">
<a name="1tekapd2amrvl7f032u6re08rb">&nbsp;&nbsp;3.创建一个名称为mydb1的数据库：create databases mydb1;</a>
</h3>
<h3 class="topic">
<a name="6991nnkpc8inhs0hkpqvdm1kr5">&nbsp;&nbsp;4.创建一个使用gbk字符集的mydb2数据库：create databases mydb2 character set gbk;</a>
</h3>
<h3 class="topic">
<a name="51eakbo62h09ieegojuuhovvtt">&nbsp;&nbsp;5.创建一个使用gbk字符集，并带校对规则的mydb3数据库：create database mydb3 character set gbk collate gbk_chinese_ci;</a>
</h3>
<h3 class="topic">
<a name="18qbq3i1m1sf4bvn6hlunpgkqt">&nbsp;&nbsp;6.查看数据库的创建细节，可以看到使用的字符集：show create database mydb1;</a>
</h3>
<h3 class="topic">
<a name="3k9rokgi1abt7i32ik9ce49vjf">&nbsp;&nbsp;7.删除当前创建的mydb3数据库：drop database mydb3;</a>
</h3>
<h3 class="topic">
<a name="6k73t9qa1sstik61ft1kt9qoge">&nbsp;&nbsp;8.查看服务器中的数据库，并把mydb2的字符集修改为utf8：alter database mydb2 character set utf8;</a>
</h3>
<h3 class="topic">
<a name="7mjqfksg4j3bl0q8iopd4n0noa">&nbsp;&nbsp;9.设置服务器端使用的编码：set character_set_client=gbk;</a>
</h3>
<h3 class="topic">
<a name="59m0u2ajpiog6qcadgvd5vfu51">&nbsp;&nbsp;10.查看数据库中的各种字符编码：show variables like 'character%' ;</a>
</h3>
<h3 class="topic">
<a name="0u8vo5sju922n9n870aho7pit3">&nbsp;7.DML数据操作语言</a>
</h3>
<h3 class="topic">
<a name="3j4cj1esqmv4vdpepn06nq4eiu">&nbsp;&nbsp;1.常用关键字：insert/update/delete</a>
</h3>
<h3 class="topic">
<a name="295t9ht5tt51lt2cii5h398vc4">&nbsp;&nbsp;2.表操作</a>
</h3>
<h3 class="topic">
<a name="15i4806bqld89hc2tjoglb4h1s">&nbsp;&nbsp;&nbsp;1.表操作前的准备工作：显示当前的数据库和选择数据库。</a>
</h3>
<h3 class="topic">
<a name="4g8enkakcjfrif7ts9vcbd394i">&nbsp;&nbsp;&nbsp;&nbsp;1.显示当前的数据库：select database();  </a>
</h3>
<h3 class="topic">
<a name="5ma6i76c61nte1vh67v609s5op">&nbsp;&nbsp;&nbsp;&nbsp;2.选择数据库：use mydb1;   创建表前，要先使用use db 语句使用库。</a>
</h3>
<h3 class="topic">
<a name="5qipsq4fgochtgucd9o4uue5j6">&nbsp;&nbsp;&nbsp;2.创建表</a>
</h3>
<h3 class="topic">
<a name="4198utrttosg7fp9919hf650gq">&nbsp;&nbsp;&nbsp;&nbsp;1.格式： create table tab_name( field1 type, field2 type, ... ,fieldn type)[character set xxx] [collate xxx];</a>
</h3>
<h3 class="topic">
<a name="3p46jquje60nbj27kdv61bdb4a">&nbsp;&nbsp;&nbsp;&nbsp;2.创建一个员工表employee。create table employee( id int primary key auto_increment, name varchar(20), gender bit default 1, birthday date, job varchar(20), salary double);</a>
</h3>
<h3 class="topic">
<a name="6ct611ve9jfomp3nq750fa1jab">&nbsp;&nbsp;&nbsp;3.查看表信息</a>
</h3>
<h3 class="topic">
<a name="7f0kuik1tj24fmuveub070c35f">&nbsp;&nbsp;&nbsp;&nbsp;1.desc tab_name 查看表结构</a>
</h3>
<h3 class="topic">
<a name="47mahv85ct6tu1bqbkvrf4sl2u">&nbsp;&nbsp;&nbsp;&nbsp;2.show tables 查看当前数据库中的所有表</a>
</h3>
<h3 class="topic">
<a name="459dgfuitcoptvffb0jrr78sgg">&nbsp;&nbsp;&nbsp;&nbsp;3.show create table tab_name 查看当前数据库建表语句</a>
</h3>
<h3 class="topic">
<a name="6fkbqipupbno4q33ds1cj1s5ul">&nbsp;&nbsp;&nbsp;4.修改表结构</a>
</h3>
<h3 class="topic">
<a name="30vel6m3c2avt6nbgud4fbj8co">&nbsp;&nbsp;&nbsp;&nbsp;1.增加一列：alter table tab_name add [column] 列名 类型;</a>
</h3>
<h3 class="topic">
<a name="1hmsian5kb2v6inp8ip0438tf9">&nbsp;&nbsp;&nbsp;&nbsp;2.修改一列类型：alter table tab_name modify 列名 类型;</a>
</h3>
<h3 class="topic">
<a name="69njod6cj6qnjpm8jif3abnroa">&nbsp;&nbsp;&nbsp;&nbsp;3.修改列名：alter table tab_name change [column] 列名 新列名 类型;</a>
</h3>
<h3 class="topic">
<a name="7e9k7im5l92cuss0aajar6nv18">&nbsp;&nbsp;&nbsp;&nbsp;4.删除一列：alter table tab_name drop [column] 列名;</a>
</h3>
<h3 class="topic">
<a name="46ea4hd9opjqs9bfi99ocg0oac">&nbsp;&nbsp;&nbsp;&nbsp;5.修改表明：rename table 表名 to 新表名;</a>
</h3>
<h3 class="topic">
<a name="4ti6pnj6c9e0mv847itqr7kgra">&nbsp;&nbsp;&nbsp;&nbsp;6.修改表所用的字符集：alter table 表明 character set utf8;</a>
</h3>
<h3 class="topic">
<a name="0k9huinov10b2u7c1gi4jh062j">&nbsp;&nbsp;&nbsp;&nbsp;7.删除表：drop table tab_name;</a>
</h3>
<h3 class="topic">
<a name="0kmldg7030qrtiblbg67hk9fuh">&nbsp;&nbsp;3.表的常用操作：增删改</a>
</h3>
<h3 class="topic">
<a name="5vtrfvjc2es0vhpi4atlnrv2eo">&nbsp;&nbsp;&nbsp;1.插入一条记录：insert into tab_name ( field1, field2, ...) values (value1, value2, ...);</a>
</h3>
<h3 class="topic">
<a name="7n38r3ie1rlo4ijhnai98mc5ps">&nbsp;&nbsp;&nbsp;&nbsp;1.插入的数据应与字段的的数据类型相同</a>
</h3>
<h3 class="topic">
<a name="0ltne1m5bkd99h58mgdeh9uegc">&nbsp;&nbsp;&nbsp;&nbsp;2.数据的大小应在列的规定范围内。例如，不能将一个长度为80的字符串加入到长度为40的列中</a>
</h3>
<h3 class="topic">
<a name="62hb736mi54qirc27gok9opom1">&nbsp;&nbsp;&nbsp;&nbsp;3.在values中列出的数据位置必须与被加入的列的排列位置相对应</a>
</h3>
<h3 class="topic">
<a name="3rhjv9vnd5vfms9qhmkm83hsor">&nbsp;&nbsp;&nbsp;&nbsp;4.字符和日期数据应该包含在单引号中</a>
</h3>
<h3 class="topic">
<a name="72iq6lan3q2q9trur1h2o10arc">&nbsp;&nbsp;&nbsp;&nbsp;5.不指定某列的值或insert into table (null)，则该列取空值</a>
</h3>
<h3 class="topic">
<a name="7lutd92pfrc9508coj2nd6tn6i">&nbsp;&nbsp;&nbsp;&nbsp;6.如果要插入所有字段可以省略列列表，直接按表中字段顺序写值。</a>
</h3>
<h3 class="topic">
<a name="3jn363gd5ndr34vu1oiihe7koj">&nbsp;&nbsp;&nbsp;2.修改表记录：update tab_name set field1=value1, field2=value2, ... [where语句];</a>
</h3>
<h3 class="topic">
<a name="1ooomupg46ubo0mv8fphb5ccrj">&nbsp;&nbsp;&nbsp;&nbsp;1.set子句指示要修改哪些列和要给予哪些值</a>
</h3>
<h3 class="topic">
<a name="2onqh8vt4f0fj837u30lhopetq">&nbsp;&nbsp;&nbsp;&nbsp;2.where 子句指定应更新哪些行。如果没有where子句，则更新所有行。</a>
</h3>
<h3 class="topic">
<a name="126qsfctnorre2vl0v64o4g2ag">&nbsp;&nbsp;&nbsp;&nbsp;3.例：将姓名为'zs'的员工薪水改为3000元。update emp set salary=300 where name='zs';    将姓名为&lsquo;xiaoliu'的员工薪水改为5000元，job改为enginer：update emp set salary=5000, job=enginer where name='xiaoliu';</a>
</h3>
<h3 class="topic">
<a name="36v9fmu6fc5r0qfirih8r4tf2n">&nbsp;&nbsp;&nbsp;3.删除表操作：delete from tab_name [where ...];</a>
</h3>
<h3 class="topic">
<a name="2155jlr80eqj5m7gplfrvhv7h3">&nbsp;&nbsp;&nbsp;&nbsp;1.如果不跟where子句则删除整张表中的数据</a>
</h3>
<h3 class="topic">
<a name="3v2thjha46pk4cedkksj8ofji0">&nbsp;&nbsp;&nbsp;&nbsp;2.delete只能用来删除一行记录，不能删除一行记录中的某一列值</a>
</h3>
<h3 class="topic">
<a name="22tq8dh9480c7nhcdlku5htivd">&nbsp;&nbsp;&nbsp;&nbsp;3.delete语句只能删除表中的内容，不能删除表本身，要想删除表，用drop</a>
</h3>
<h3 class="topic">
<a name="73r6lntbt3bkd0f63cghdstj6v">&nbsp;&nbsp;&nbsp;&nbsp;4.truncate table 可以删除表中所有数据，此语句首先摧毁表，再新建表。此种方式删除的数据不能再从事务中恢复。</a>
</h3>
<h3 class="topic">
<a name="1h6o45ujl5t75egnm9r283jghp">&nbsp;&nbsp;&nbsp;&nbsp;5.例，删除表中名称为'zs'的记录。delete from emp where name='zs';</a>
</h3>
<h3 class="topic">
<a name="2g4lb7n4mb1vbialjrl1o81h9f">&nbsp;8.DQL数据查询语言</a>
</h3>
<h3 class="topic">
<a name="1qq0vd42udd7q719lf7dnmslp1">&nbsp;&nbsp;1.查询表操作（select）</a>
</h3>
<h3 class="topic">
<a name="4d4umv8mfcmoulmf08mepk6lc3">&nbsp;&nbsp;&nbsp;1.select [distinct] * | field1,field2, ... from tab_name;  其中distinct用来剔除重复行。例，select name,english from exam; select distinct english from exam;</a>
</h3>
<h3 class="topic">
<a name="6g0mqiua06hm9p7856dpv8u5mh">&nbsp;&nbsp;&nbsp;2.select可以使用表达式，且可以使用as 别名</a>
</h3>
<h3 class="topic">
<a name="5og17fukrmhdekpa20374mslhf">&nbsp;&nbsp;&nbsp;&nbsp;1.select name,english+10,chinese+10,math+10 from exam;</a>
</h3>
<h3 class="topic">
<a name="0phv3jvceoggrjofmnna9o2s0v">&nbsp;&nbsp;&nbsp;&nbsp;2.select name,english+chinese+math as 总成绩 from exam;</a>
</h3>
<h3 class="topic">
<a name="455cnsjn68thavteln6a0ori1b">&nbsp;&nbsp;&nbsp;&nbsp;3.select name,english+chinese+math  总成绩 from exam;</a>
</h3>
<h3 class="topic">
<a name="710rpq0hsec4lt0jfa4p3p4fu6">&nbsp;&nbsp;2.使用where子句进行过滤查询</a>
</h3>
<h3 class="topic">
<a name="3ropa4emu9ocsnqehe8qc55cc6">&nbsp;&nbsp;&nbsp;1.查询姓名为'xx'的学生成绩</a>
</h3>
<h3 class="topic">
<a name="7v5ao7iq2reenhko6o6j3ltuiv">&nbsp;&nbsp;&nbsp;&nbsp;1.select * from exam where name='xx';</a>
</h3>
<h3 class="topic">
<a name="4lj2mdhjmrun0acehajj7kvcm6">&nbsp;&nbsp;&nbsp;2.where子句支持的格式</a>
</h3>
<h3 class="topic">
<a name="6tbu698tknb9mu8hktlpimjq4f">&nbsp;&nbsp;&nbsp;&nbsp;1.比较运算符：&gt;  &lt;  &gt;=  &lt;=  &lt;&gt;</a>
</h3>
<h3 class="topic">
<a name="37f6aj0n4h5vj2s12iutdi2ah3">&nbsp;&nbsp;&nbsp;&nbsp;2.between 10 an 20;  值在10到20之间。例：查询英语分数在80-100之间的同学，select name,english from exam where english between 80 and 100;</a>
</h3>
<h3 class="topic">
<a name="28i6j0otolnscc3r16j5l1acrg">&nbsp;&nbsp;&nbsp;&nbsp;3.in(10,20,30);  值是10或20或30。例：查询数学分数为75,76,77的同学，select name, math from exam where math in(75,76,77);</a>
</h3>
<h3 class="topic">
<a name="1jta2ndisndk69sufu6nmdjvc7">&nbsp;&nbsp;&nbsp;&nbsp;4.like '张pattern';  pattern可以是%或者_，如果是%则表示任意多字符，例：张三丰，张飞，张abcd;如果是_则表示一个字符张_，张飞符合。例：查询所有姓张的学生的成绩， select * from exam where name like '张%';</a>
</h3>
<h3 class="topic">
<a name="246mensd2d1mm5qdsgoq4l621a">&nbsp;&nbsp;&nbsp;&nbsp;5.逻辑运算符。在多个条件直接可以使用逻辑运算符 and or not 。 例：查询数学分数&gt;70，语文&gt;80的同学。select name from exam where math&gt;70 and chinese &gt;80;   查询缺考数学的学生的姓名：select name from exam where math is null;</a>
</h3>
<h3 class="topic">
<a name="22jb2h262g8lov1ul8v1gc47k9">&nbsp;&nbsp;3.order by 指定排序的列，排序的列即可是表中的列名，也可以是select后面指定的别名。order by [列名|别名] [asc|desc|...]   asc升序，desc降序。</a>
</h3>
<h3 class="topic">
<a name="761q82hkiv790aj5f3vpgdpi2m">&nbsp;&nbsp;&nbsp;1.例：对总分排序，按照从高到低的顺序输出。select name, (ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) 总成绩 from exam order by desc;</a>
</h3>
<h3 class="topic">
<a name="4jbprllcl45ar41s7vldo0rsip">&nbsp;&nbsp;4.聚合函数：技巧，先不管聚合函数要干什么，先把要求的内容查出来包上聚合函数即可。</a>
</h3>
<h3 class="topic">
<a name="05r90lva7h1c9kgjceliho61r8">&nbsp;&nbsp;&nbsp;1.count(列名);  例，统计一个班共有多少个学生，select count(*) from exam;</a>
</h3>
<h3 class="topic">
<a name="3jc9ioqfdm31g81s8uhdcrnjqb">&nbsp;&nbsp;&nbsp;2.sum(列名); //不会包含null   例，统计一个班级语文平均成绩，select sum(chinese)/count(*) from exam;</a>
</h3>
<h3 class="topic">
<a name="52bn72lftic6qepn22uond7f9h">&nbsp;&nbsp;&nbsp;3.avg(列名);  例，求一个班级的数学平均分，select avg(ifnull(math,0)) from exam;</a>
</h3>
<h3 class="topic">
<a name="799evgmipb6c3bm0rojc1uksmf">&nbsp;&nbsp;&nbsp;4.max/min   例，求班级最高分，select max(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) from exam;</a>
</h3>
<h3 class="topic">
<a name="41qgk6lttfnvaareqs9e96pk5q">&nbsp;&nbsp;5.group by子句：其后可以跟多个列名，也可以跟having子句对group by的结果进行筛选。</a>
</h3>
<h3 class="topic">
<a name="1o399h6tt0leod1l6s8hj2geno">&nbsp;&nbsp;&nbsp;1.例，对订单表中商品归类后，显示每一类商品的总价。select product, sum(price) from orders group by product; </a>
</h3>
<h3 class="topic">
<a name="5525ov3qil3nr6adv21ociq1dm">&nbsp;&nbsp;&nbsp;2.例，查询购买了几类商品，并且每类总价大于100的商品。select product, sum(price) from orders group by product having sum(price) &gt;100; </a>
</h3>
<h3 class="topic">
<a name="4u304661eveqncrke2u3lss0cr">&nbsp;&nbsp;&nbsp;3.having和where的差别： where语句在分组之前的筛选，having用在分组之后的筛选，having中可以使用聚合函数，where中就不行。使用where的地方可以使用having替换。</a>
</h3>
<h3 class="topic">
<a name="4obp8qdflrub5308jq41hekqdn">&nbsp;&nbsp;&nbsp;&nbsp;1.查询商品列表中除了橘子以外的商品，每一类商品的总价格大于500元的商品的名字。select product, sum(price) from orders where product&lt;&gt;'桔子&rsquo; group by having sum(price)&gt;500;</a>
</h3>
<h3 class="topic">
<a name="2oe84qcrfjco0t67u8p9bn0nr6">&nbsp;&nbsp;6.SQL关键字：select from where group by having order by  ;  MySQL在执行SQL语句时的顺序：from where select group by having order by ;</a>
</h3>
<h3 class="topic">
<a name="43ihldj67nmklfa7o37i00tk2i">&nbsp;9.数据完整性：是为了保证插入到数据中的数据是正确的，它防止了用户可能的输入错误。</a>
</h3>
<h3 class="topic">
<a name="5rbfre8min1slra7p397ruh8t6">&nbsp;&nbsp;1.实体（行）完整性：规定表的一行（即每一条记录）在表中是唯一的实体。</a>
</h3>
<h3 class="topic">
<a name="31urrvvcqachb027nh8posdf5f">&nbsp;&nbsp;&nbsp;1.通过定义主键约束来实现。主键：primary key（特点：不能为null，且唯一）</a>
</h3>
<h3 class="topic">
<a name="271ev1ntbbhoa713i8gpr5ku66">&nbsp;&nbsp;&nbsp;&nbsp;1.分为：逻辑主键：比如ID，不代表实际的业务意义，只用来唯一标识一条记录。（推荐）</a>
</h3>
<h3 class="topic">
<a name="452dpa7kve9qfh3i51orhsddhc">&nbsp;&nbsp;&nbsp;&nbsp;2.业务主键：比如username作为主键</a>
</h3>
<h3 class="topic">
<a name="7ven3ugm6nss8miioeu0jfprjt">&nbsp;&nbsp;&nbsp;2.主键的声明方式：</a>
</h3>
<h3 class="topic">
<a name="1pu255g96nq4ptb1n6omjq9sve">&nbsp;&nbsp;&nbsp;&nbsp;1.create table t1( id int primary, name varchar(100) );</a>
</h3>
<h3 class="topic">
<a name="3ltbaf3rip3bbd2l1f36doet3m">&nbsp;&nbsp;&nbsp;&nbsp;2.create table t2( id int,name varchar(100), primary(id) ); 此种方式可以定义联合主键</a>
</h3>
<h3 class="topic">
<a name="6b7uid571j1v35vt0leq3j47u2">&nbsp;&nbsp;&nbsp;&nbsp;3.推荐的方式。create table t3( id int, name varchar(100) ); alter table t3 add primary key(id);</a>
</h3>
<h3 class="topic">
<a name="7dkvb9f93b1o3u1r3ukrf6ufp1">&nbsp;&nbsp;&nbsp;&nbsp;4.自动增长的主键（只针对mysql，oracle没有）。create table t4( id int primary key auto_increment, name varchar(100) );</a>
</h3>
<h3 class="topic">
<a name="5egac3fj9p8tsk4b4mpb7pbo9g">&nbsp;&nbsp;2.域（列）完整性：指数据库表的列（即字段）必须符合某种特定数据类型或约束。</a>
</h3>
<h3 class="topic">
<a name="6200rbc2nnadmq9o0j8086gvq8">&nbsp;&nbsp;&nbsp;1.非空约束：not null     唯一约束：unique</a>
</h3>
<h3 class="topic">
<a name="0no28ig75dml2ljap91g29i6s6">&nbsp;&nbsp;&nbsp;2.例，create table t5( username varchar(100) not null unique, gender varchar(100) not null, phonenum unique );</a>
</h3>
<h3 class="topic">
<a name="1kusfem49po7n4een6jcq7i8qo">&nbsp;&nbsp;3.参照完整性：多表，外键约束。多表设计</a>
</h3>
<h3 class="topic">
<a name="5lc7ujlgtrt4m03jg2r0ojdjao">&nbsp;&nbsp;&nbsp;1.一对多：create table customers( id int,name varchar(100),address varchar(255), primary key(id) );    create table orders( id int primary key, order_num varchar(100), price float(8,2), status int, customer_id int, constrant(定义外键） customer_id_fk（约束名称：库中要唯一） foreign key(customer_id) References customers(id) );</a>
</h3>
<h3 class="topic">
<a name="4vg7ofn2077ss6jbk80g61f1g3">&nbsp;&nbsp;&nbsp;2.类和数据库表结构对应，对象和数据库中的记录对应。public class Customer{ private int id; private string name; private string address; private List&lt;Order&gt; orders=new ArrayList&lt;Order&gt;(); }  public class Order{ private int id; private string orderNum; private float price; private int status;  private Customer customer; }     </a>
</h3>
<h3 class="topic">
<a name="6js0mm888fq8tisk49kebqh3ri">&nbsp;&nbsp;&nbsp;3.多对多：create table teachers( id int primary key, name varchar(100), salary varchar(100) );   create table Students( id int primary key, name varchar(100),grade varchar(100) ); create table teacher_student( t_id int, s_id int, primary key(t_id,s_id),联合主键  constraint teacher_id_fk foreign key(t_id) references teachers(id), constraint student_id_fk foreign key(s_id) references students(id) );</a>
</h3>
<h3 class="topic">
<a name="7sthruc4fl8s919afu53dmu5t2">&nbsp;10.多表查询</a>
</h3>
<h2 class="topic">
<a name="2gj84shudnb9tekm6abbj49cso">十七、JDBC技术</a>
</h2>
<h2 class="topic">
<a name="1iuqk4k7ljh2uo1uob5la4e8kl">十八、事务</a>
</h2>
<h2 class="topic">
<a name="0iikfm57umv79folgab0iukaan">十九、数据库连接池</a>
</h2>
<h2 class="topic">
<a name="515evvmturp81abu24hm15hquc">二十、过滤器和监听器</a>
</h2>
<h2 class="topic">
<a name="45sq0maapnm98ctcjcpi0toc8r">二十一、文件上传</a>
</h2>
</body>
</html>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2018/03/06/JVM/2018-04-11_6_1Java的client模式和server模式_/">Java的client模式和server模式</a></h1>
  

      
        <time datetime="2018-03-05T19:33:00.000Z">2018-03-06</time>
      
    </header>
    <div class="entry">
      
        <!-- image url 
https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages
　　首行缩进
<font color="red">  </font>
-->

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="1、解释和比较"><a href="#1、解释和比较" class="headerlink" title="1、解释和比较"></a>1、解释和比较</h2><p>hotspot包括server和client两种模式的实现：<br/><br>Java HotSpot Client VM(-client)，为在客户端环境中减少启动时间而优化；<br/><br>Java HotSpot Server VM(-server)，为在服务器环境中最大化程序执行速度而设计。<br/><br>比较：<br/></p>
<p>两种模式的区别在于，Client模式启动速度较快，Server模式启动较慢；但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。</p>
<p>因为因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化，server模式会尝试收集更多的系统性能信息，使用更复杂的优化算法对程序进行优化。而Client模式启动的JVM采用的是轻量级的虚拟机</p>
<p>因此当系统完全启动并进入运行稳定期后，server模式的执行速度会远远快于client模式，所以在对于后台长期运行的系统，使用server模式启动对系统的整体性能可以有不小的帮助，但对于用户界面程序，运行时间不长，又追求启动速度建议使用client模式启动</p>
<h2 id="2、模式根据"><a href="#2、模式根据" class="headerlink" title="2、模式根据"></a>2、模式根据</h2><p>看了一下hotspot的安装的模式，32位的hotspot都是client模式；64位的都是server模式的。</p>
<p>1、查看当前虚拟机处于那种模式，如下图是64位的虚拟机</p>
<p>Java -version</p>
<p><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-144901@2x.png" alt="WX20180411-144901@2x"></p>
<p>下图是32位的虚拟机</p>
<p><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-144945@2x.png" alt="WX20180411-144945@2x"></p>
<p>2、 Client与Server切换</p>
<p>首先要确认JDK支持哪一种或两种模式。查看JAVA_HOME/jre/bin目录下是否存在client或server目录。32位的JDK一般都支持server和client两种模式。64位的虚拟机好像只支持server模式(不能修改模式)，没有client目录。如下为32位JDK模式支持目录： </p>
<p><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-145050@2x.png" alt="WX20180411-145050@2x"></p>
<p>在32位JDK中，jvm.cfg位置为：JAVA_HOME/jre/lib/i386/jvm.cfg； <br/><br>切换模式只需要将client和server的声明语句互换位置即可。如下图所示<br><img src="https://raw.githubusercontent.com/HealerJean/HealerJean.github.io/master/blogImages/WX20180411-145255@2x.png" alt="WX20180411-145255@2x"></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">Prev</a>
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:jony.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/07/19/JVM/2018-09-10-JVM调优/">JVM调优</a>
      </li>
    
      <li>
        <a href="/2018/07/02/JVM/2018-07-02-项目中遇到的java堆溢出解决/">项目中遇到的java堆溢出解决</a>
      </li>
    
      <li>
        <a href="/2018/04/11/JVM/2018-04-11-8_虚拟机类加载机制/">虚拟机类加载机制</a>
      </li>
    
      <li>
        <a href="/2018/04/11/JVM/2018-04-11-7_Class文件结构/">Class文件结构</a>
      </li>
    
      <li>
        <a href="/2018/04/11/JVM/2018-04-11-6_JVM参数/">JVM参数</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/AngularJS/">AngularJS</a><small>1</small></li>
  
    <li><a href="/categories/JVM/">JVM</a><small>12</small></li>
  
    <li><a href="/categories/Java/">Java</a><small>12</small></li>
  
    <li><a href="/categories/Java并发/">Java并发</a><small>5</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>3</small></li>
  
    <li><a href="/categories/Maven/">Maven</a><small>1</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>3</small></li>
  
    <li><a href="/categories/网络编程/">网络编程</a><small>3</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/AngularJS/" style="font-size: 10px;">AngularJS</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91/" style="font-size: 16.67px;">Java并发</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 13.33px;">网络编程</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 jony
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

