<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="会飞的鱼" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Reactive Programming 一种技术，各自表述｜undefined
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2018/12/19/2018-07-25-Reactive Programming 一种技术 各自表述/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost="true" data-istags="false
" data-ishome="false">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    会飞的鱼
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img" src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Reactive Programming 一种技术，各自表述</h1>
                    
                    <span class="meta">
                         作者 tianyaojiang
                        <span>
                          日期 2018-12-19
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Reactive Programming 一种技术，各自表述
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="Reactive-Programming-一种技术，各自表述"><a href="#Reactive-Programming-一种技术，各自表述" class="headerlink" title="Reactive Programming 一种技术，各自表述"></a>Reactive Programming 一种技术，各自表述</h1><!-- TOC -->autoauto- <a href="#reactive-programming-一种技术各自表述">Reactive Programming 一种技术，各自表述</a>auto    - <a href="#前言">前言</a>auto    - <a href="#初识-reactive">初识 Reactive</a>auto    - <a href="#理解-reactive">理解 Reactive</a>auto        - <a href="#关于-reactive-的一些讲法">关于 Reactive 的一些讲法</a>auto        - <a href="#传统编程模型中的某些困境">传统编程模型中的某些困境</a>auto            - <a href="#reactorhttpprojectreactoriodocscorereleasereference_blocking_can_be_wasteful-认为阻塞可能是浪费的"><a href="http://projectreactor.io/docs/core/release/reference/#_blocking_can_be_wasteful" target="_blank" rel="noopener">Reactor</a> 认为阻塞可能是浪费的</a>auto                - <a href="#理解阻塞的弊端">理解阻塞的弊端</a>auto                - <a href="#理解并行的复杂">理解并行的复杂</a>auto            - <a href="#reactorhttpprojectreactoriodocscorereleasereference_asynchronicity_to_the_rescue-认为异步不一定能够救赎"><a href="http://projectreactor.io/docs/core/release/reference/#_asynchronicity_to_the_rescue" target="_blank" rel="noopener">Reactor</a> 认为异步不一定能够救赎</a>auto                - <a href="#理解-callback-hell">理解 “Callback Hell”</a>auto                - <a href="#理解-future-的限制">理解 <code>Future</code> 的限制</a>auto                    - <a href="#限制一future-的阻塞性">限制一：<code>Future</code> 的阻塞性</a>auto                    - <a href="#限制二future--不支持链式操作">限制二：<code>Future</code>  不支持链式操作</a>auto            - <a href="#reactive-streams-jvmhttpsgithubcomreactive-streamsreactive-streams-jvmgoals-design-and-scope-认为异步系统和资源消费需要特殊处理"><a href="https://github.com/reactive-streams/reactive-streams-jvm#goals-design-and-scope" target="_blank" rel="noopener">Reactive Streams JVM</a> 认为异步系统和资源消费需要特殊处理</a>auto        - <a href="#什么是-reactive-programming">什么是 Reactive Programming</a>auto            - <a href="#the-reactive-manifestohttpswwwreactivemanifestoorg-中的定义"><a href="https://www.reactivemanifesto.org/" target="_blank" rel="noopener">The Reactive Manifesto</a> 中的定义</a>auto            - <a href="#维基百科httpsenwikipediaorgwikireactive_programming中的定义"><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">维基百科</a>中的定义</a>auto            - <a href="#springhttpsdocsspringiospringdocscurrentspring-framework-referenceweb-reactivehtmlwebflux-why-reactive-5-中的定义"><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive" target="_blank" rel="noopener">Spring</a> 5 中的定义</a>auto            - <a href="#reactivexhttpreactivexiointrohtml-中的定义"><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a> 中的定义</a>auto            - <a href="#reactorhttpprojectreactoriodocscorereleasereferenceintro-reactive-中的定义"><a href="http://projectreactor.io/docs/core/release/reference/#intro-reactive" target="_blank" rel="noopener">Reactor</a> 中的定义</a>auto            - <a href="#andré-staltzhttpsgistgithubcomstaltz-给出的定义"><a href="https://gist.github.com/staltz" target="_blank" rel="noopener">André Staltz</a> 给出的定义</a>auto        - <a href="#reactive-programming-使用场景">Reactive Programming 使用场景</a>auto            - <a href="#reactive-streams-jvmhttpsgithubcomreactive-streamsreactive-streams-jvm-认为的使用场景"><a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams JVM</a> 认为的使用场景</a>auto            - <a href="#spring-5httpsdocsspringiospringdocs507releasespring-framework-referenceweb-reactivehtmlwebflux-performance-认为的使用场景"><a href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance" target="_blank" rel="noopener">Spring 5</a> 认为的使用场景</a>auto            - <a href="#reactivexhttpreactivexiointrohtml-认为的使用场景"><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a> 认为的使用场景</a>auto            - <a href="#reactorhttpprojectreactoriodocscorereleasereferenceintro-reactive-认为的使用场景"><a href="http://projectreactor.io/docs/core/release/reference/#intro-reactive" target="_blank" rel="noopener">Reactor</a> 认为的使用场景</a>auto    - <a href="#总结-reactive-programming">总结 Reactive Programming</a>auto    - <a href="#后记">后记</a>autoauto<!-- /TOC -->
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名 Java 开发人员，尤其是 Java 服务端工程师，对于 Reactive Programming 的概念似乎相对陌生。随着 Java 9 以及 Spring Framework 5 的相继发布，Reactive 技术逐渐开始被广大从业人员所注意，笔者作为其中一员，更渴望如何理解 Reactive Programming，以及它所带来的哪些显著的编程变化，更为重要的是，怎么将其用于实际生产环境，解决当前面临的问题。然而，随着时间的推移和了解的深入，笔者对  Reactive Programming  的热情逐渐被浇息，对它的未来保持谨慎乐观的态度。</p>
<p>本文从理解 Reactive Programming 的角度出发，尽可能地保持理性和中立的态度，讨论 Reactive Programming 的实质。</p>
<h2 id="初识-Reactive"><a href="#初识-Reactive" class="headerlink" title="初识 Reactive"></a>初识 Reactive</h2><p>笔者第一次接触 Reactive 技术的时间还要回溯到 2015年末，当时部分应用正使用 Hystrix 实现服务熔断，而 Hystrix 底层依赖是 RxJava 1.x，RxJava 是 Reactive 在 Java 编程语言的扩展框架。当时接触 Reactive 只能算上一种间接的接触，根据 Hystrix 特性来理解 Reactive 技术，感觉上，Hystrix 超时和信号量等特性与 Java 并发框架（J.U.C）的关系密切，进而认为 Reactive 是 J.U.C 的扩展。随后，笔者便参考了两本关于 Reactive Java 编程方面的书：《Reactive Java Programming》和《Reactive Programming with RxJava》。遗憾的是，两者尽管详细地描述 RxJava 的使用方法，然而却没有把 Reactive 使用场景讨论到要点上，如《Reactive Programming with RxJava》所给出的使用场景说明：</p>
<blockquote>
<p>When You Need Reactive Programming</p>
<p>Reactive programming is useful in scenarios such as the following:</p>
<ul>
<li>Processing user events such as mouse movement and clicks, keyboard typing,GPS signals changing over time as users move with their device, device gyroscope signals, touch events, and so on.</li>
<li>Responding to and processing any and all latency-bound IO events from disk or network, given that IO is inherently asynchronous …</li>
<li>Handling events or data pushed at an application by a producer it cannot control …</li>
</ul>
</blockquote>
<p>实际上，以上三种使用场景早已在 Java 生态中完全地实现并充分地实践，它们对应的技术分别是  Java AWT/Swing、NIO/AIO 以及 JMS（Java 消息服务）。那么，再谈 RxJava 的价值又在哪里呢？如果读者是初学者，或许还能蒙混过关。好奇心促使笔者重新开始踏上探索 Reactive 之旅。</p>
<h2 id="理解-Reactive"><a href="#理解-Reactive" class="headerlink" title="理解 Reactive"></a>理解 Reactive</h2><p>2017年 Java 技术生态中，最有影响力的发布莫过于 Java 9 和 Spring 5，前者主要支持模块化，次要地提供了 Flow API 的支持，后者则将”身家性命“压在 Reactive 上面，认为 Reactive 是未来的趋势，它以 Reactive 框架 Reactor 为基础，逐步构建一套完整的 Reactive 技术栈，其中以 WebFlux 技术为最引人关注，作为替代 Servlet Web 技术栈的核心特性，承载了多年 Spring 逆转 Java EE 的初心。于是，业界开始大力地推广 Reactive 技术，于是笔者又接触到一些关于 Reactive 的讲法。 </p>
<h3 id="关于-Reactive-的一些讲法"><a href="#关于-Reactive-的一些讲法" class="headerlink" title="关于 Reactive 的一些讲法"></a>关于 Reactive 的一些讲法</h3><p>其中笔者挑选了以下三种出镜率最高的讲法：</p>
<ul>
<li>Reactive 是异步非阻塞编程</li>
<li>Reactive 能够提升程序性能</li>
<li>Reactive 解决传统编程模型遇到的困境</li>
</ul>
<p>第一种说法描述了功能特性，第二种说法表达了性能收效，第三种说法说明了终极目地。下面的讨论将围绕着这三种讲法而展开，深入地探讨 Reactive Programming 的实质，并且理解为什么说 Reactive Programming 是”一种技术，各自表述“。</p>
<p>同时，讨论的方式也一反常态，并不会直奔主题地解释什么 Reactive Programming，而是从问题的角度出发，从 Reactive 规范和框架的论点，了解传统编程模型中所遇到的困境，逐步地揭开 Reactive 神秘的面纱。其中 Reactive 规范是 JVM Reactive 扩展规范 <a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams JVM</a>，而 Reactive 实现框架则是最典型的实现：</p>
<ul>
<li>Java 9 Flow API </li>
<li>RxJava </li>
<li>Reactor </li>
</ul>
<h3 id="传统编程模型中的某些困境"><a href="#传统编程模型中的某些困境" class="headerlink" title="传统编程模型中的某些困境"></a>传统编程模型中的某些困境</h3><h4 id="Reactor-认为阻塞可能是浪费的"><a href="#Reactor-认为阻塞可能是浪费的" class="headerlink" title="Reactor 认为阻塞可能是浪费的"></a><a href="http://projectreactor.io/docs/core/release/reference/#_blocking_can_be_wasteful" target="_blank" rel="noopener">Reactor</a> 认为阻塞可能是浪费的</h4><blockquote>
<h3 id="3-1-Blocking-Can-Be-Wasteful"><a href="#3-1-Blocking-Can-Be-Wasteful" class="headerlink" title="3.1. Blocking Can Be Wasteful"></a>3.1. Blocking Can Be Wasteful</h3><p>Modern applications can reach huge numbers of concurrent users, and, even though the capabilities of modern hardware have continued to improve, performance of modern software is still a key concern.</p>
<p>There are broadly two ways one can improve a program’s performance:</p>
<ol>
<li><strong>parallelize</strong>: use more threads and more hardware resources.</li>
<li><strong>seek more efficiency</strong> in how current resources are used.</li>
</ol>
<p>Usually, Java developers write programs using blocking code. This practice is fine until there is a performance bottleneck, at which point the time comes to introduce additional threads, running similar blocking code. But this scaling in resource utilization can quickly introduce contention and concurrency problems. </p>
<p>Worse still, blocking wastes resources. </p>
<p>So the parallelization approach is not a silver bullet. </p>
</blockquote>
<p>将以上 Reactor 观点归纳如下，它认为：</p>
<ol>
<li>阻塞导致性能瓶颈和浪费资源</li>
<li>增加线程可能会引起资源竞争和并发问题</li>
<li>并行的方式不是银弹（不能解决所有问题）</li>
</ol>
<p>第三点基本上是废话，前面两点则较为容易理解，为了减少理解的偏差，以下讨论将结合示例说明。</p>
<h5 id="理解阻塞的弊端"><a href="#理解阻塞的弊端" class="headerlink" title="理解阻塞的弊端"></a>理解阻塞的弊端</h5><p>假设有一个数据加载器，分别加载配置、用户信息以及订单信息，如下图所示：</p>
<ul>
<li>图示</li>
</ul>
<p><img src="/img/assets/DataLoader.png" alt="image-20180722175037967"></p>
<ul>
<li>Java 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis(); <span class="comment">// 开始时间</span></span><br><span class="line">        doLoad(); <span class="comment">// 具体执行</span></span><br><span class="line">        <span class="keyword">long</span> costTime = System.currentTimeMillis() - startTime; <span class="comment">// 消耗时间</span></span><br><span class="line">        System.out.println(<span class="string">"load() 总耗时："</span> + costTime + <span class="string">" 毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoad</span><span class="params">()</span> </span>&#123; <span class="comment">// 串行计算</span></span><br><span class="line">        loadConfigurations();    <span class="comment">//  耗时 1s</span></span><br><span class="line">        loadUsers();                  <span class="comment">//  耗时 2s</span></span><br><span class="line">        loadOrders();                <span class="comment">// 耗时 3s</span></span><br><span class="line">    &#125; <span class="comment">// 总耗时 1s + 2s  + 3s  = 6s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loadConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadMock(<span class="string">"loadConfigurations()"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadMock(<span class="string">"loadUsers()"</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loadOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadMock(<span class="string">"loadOrders()"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadMock</span><span class="params">(String source, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> milliseconds = TimeUnit.SECONDS.toMillis(seconds);</span><br><span class="line">            Thread.sleep(milliseconds);</span><br><span class="line">            <span class="keyword">long</span> costTime = System.currentTimeMillis() - startTime;</span><br><span class="line">            System.out.printf(<span class="string">"[线程 : %s] %s 耗时 :  %d 毫秒\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(), source, costTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DataLoader().load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[线程 : main] loadConfigurations() 耗时 :  1005 毫秒</span><br><span class="line">[线程 : main] loadUsers() 耗时 :  2002 毫秒</span><br><span class="line">[线程 : main] loadOrders() 耗时 :  3001 毫秒</span><br><span class="line">load() 总耗时：6031 毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>结论</li>
</ul>
<p>由于加载过程串行执行的关系，导致消耗实现线性累加。Blocking 模式即串行执行 。</p>
<p>不过 Reactor 也提到，以上问题可通过并行的方式来解决，不过编写并行程序较为复杂，那么其中难点在何处呢？</p>
<h5 id="理解并行的复杂"><a href="#理解并行的复杂" class="headerlink" title="理解并行的复杂"></a>理解并行的复杂</h5><p>再将以上示例由串行调整为并行，如下图所示：</p>
<ul>
<li>图示</li>
</ul>
<p><img src="/img/assets/ParallelDataLoader.png" alt="image-20180722175519583"></p>
<ul>
<li>Java 代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelDataLoader</span> <span class="keyword">extends</span> <span class="title">DataLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoad</span><span class="params">()</span> </span>&#123;  <span class="comment">// 并行计算</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 创建线程池</span></span><br><span class="line">        CompletionService completionService = <span class="keyword">new</span> ExecutorCompletionService(executorService);</span><br><span class="line">        completionService.submit(<span class="keyword">super</span>::loadConfigurations, <span class="keyword">null</span>);      <span class="comment">//  耗时 &gt;= 1s</span></span><br><span class="line">        completionService.submit(<span class="keyword">super</span>::loadUsers, <span class="keyword">null</span>);               <span class="comment">//  耗时 &gt;= 2s</span></span><br><span class="line">        completionService.submit(<span class="keyword">super</span>::loadOrders, <span class="keyword">null</span>);              <span class="comment">//  耗时 &gt;= 3s</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; <span class="comment">// 等待三个任务完成</span></span><br><span class="line">            <span class="keyword">if</span> (completionService.poll() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;  <span class="comment">// 总耗时 max(1s, 2s, 3s)  &gt;= 3s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ParallelDataLoader().load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[线程 : pool-1-thread-1] loadConfigurations() 耗时 :  1003 毫秒</span><br><span class="line">[线程 : pool-1-thread-2] loadUsers() 耗时 :  2005 毫秒</span><br><span class="line">[线程 : pool-1-thread-3] loadOrders() 耗时 :  3005 毫秒</span><br><span class="line">load() 总耗时：3068 毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>结论</li>
</ul>
<p>明显地，程序改造为并行加载后，性能和资源利用率得到提升，消耗时间取最大者，即三秒，由于线程池操作的消耗，整体时间将略增一点。不过，以上实现为什么不直接使用 <code>Future#get()</code>  方法强制所有任务执行完毕，然后再统计总耗时？</p>
<p>Reactor 这方面的看法并没有向读者清晰地表达全秒，不过这还不是全部，听听它接下来的说法。</p>
<h4 id="Reactor-认为异步不一定能够救赎"><a href="#Reactor-认为异步不一定能够救赎" class="headerlink" title="Reactor 认为异步不一定能够救赎"></a><a href="http://projectreactor.io/docs/core/release/reference/#_asynchronicity_to_the_rescue" target="_blank" rel="noopener">Reactor</a> 认为异步不一定能够救赎</h4><blockquote>
<h3 id="3-2-Asynchronicity-to-the-Rescue"><a href="#3-2-Asynchronicity-to-the-Rescue" class="headerlink" title="3.2. Asynchronicity to the Rescue?"></a>3.2. Asynchronicity to the Rescue?</h3><p>The second approach (mentioned earlier), seeking more efficiency, can be a solution to the resource wasting problem. By writing <em>asynchronous</em>, <em>non-blocking</em> code, you let the execution switch to another active task <strong>using the same underlying resources</strong> and later come back to the current process when the asynchronous processing has finished.</p>
<p>Java offers two models of asynchronous programming:</p>
<ul>
<li><strong>Callbacks</strong>: Asynchronous methods do not have a return value but take an extra <code>callback</code> parameter (a lambda or anonymous class) that gets called when the result is available. A well known example is Swing’s <code>EventListener</code>hierarchy.</li>
<li><strong>Futures</strong>: Asynchronous methods return a <code>Future&lt;T&gt;</code> <strong>immediately</strong>. The asynchronous process computes a <code>T</code> value, but the <code>Future</code> object wraps access to it. The value is not immediately available, and the object can be polled until the value is available. For instance, <code>ExecutorService</code> running <code>Callable&lt;T&gt;</code> tasks use <code>Future</code> objects.</li>
</ul>
<p>Are these techniques good enough? Not for every use case, and both approaches have limitations.</p>
<p>Callbacks are hard to compose together, quickly leading to code that is difficult to read and maintain (known as “Callback Hell”).</p>
<p>Futures are a bit better than callbacks, but they still do not do well at composition, despite the improvements brought in Java 8 by <code>CompletableFuture</code>. </p>
</blockquote>
<p>再次将以上观点归纳，它认为：</p>
<ul>
<li>Callbacks 是解决非阻塞的方案，然而他们之间很难组合，并且快速地将代码引导至 “Callback Hell” 的不归路</li>
<li>Futures  相对于 Callbacks 好一点，不过还是无法组合，不过  <code>CompletableFuture</code> 能够提升这方面的不足</li>
</ul>
<p>以上 Reactor 的观点仅给出了结论，没有解释现象，其中场景设定也不再简单直白，从某种程度上，这也侧面地说明，Reactive Programming 实际上是”高端玩家“的游戏。接下来，本文仍通过示例的方式，试图解释”Callback Hell” 问题以及 <code>Future</code> 的限制。</p>
<h5 id="理解-“Callback-Hell”"><a href="#理解-“Callback-Hell”" class="headerlink" title="理解 “Callback Hell”"></a>理解 “Callback Hell”</h5><ul>
<li>Java GUI 示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaGUI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">"GUI 示例"</span>);</span><br><span class="line">        jFrame.setBounds(<span class="number">500</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        LayoutManager layoutManager = <span class="keyword">new</span> BorderLayout(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        jFrame.setLayout(layoutManager);</span><br><span class="line">        jFrame.addMouseListener(<span class="keyword">new</span> MouseAdapter() &#123; <span class="comment">// callback 1</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程 : %s] 鼠标点击，坐标(X : %d, Y : %d)\n"</span>,</span><br><span class="line">                        currentThreadName(), e.getX(), e.getY());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jFrame.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;  <span class="comment">// callback 2</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程 : %s] 清除 jFrame... \n"</span>, currentThreadName());</span><br><span class="line">                jFrame.dispose(); <span class="comment">// 清除 jFrame</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程 : %s] 退出程序... \n"</span>, currentThreadName());</span><br><span class="line">                System.exit(<span class="number">0</span>); <span class="comment">// 退出程序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"当前线程："</span> + currentThreadName());</span><br><span class="line">        jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">currentThreadName</span><span class="params">()</span> </span>&#123; <span class="comment">// 当前线程名称</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p>点击窗体并关闭窗口，控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前线程：main</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 180, Y : 121)</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 180, Y : 122)</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 180, Y : 122)</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 180, Y : 122)</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 180, Y : 122)</span><br><span class="line">[线程 : AWT-EventQueue-0] 鼠标点击，坐标(X : 201, Y : 102)</span><br><span class="line">[线程 : AWT-EventQueue-0] 清除 jFrame... </span><br><span class="line">[线程 : AWT-EventQueue-0] 退出程序...</span><br></pre></td></tr></table></figure>
<ul>
<li>结论</li>
</ul>
<p>Java GUI 以及事件/监听模式基本采用匿名内置类实现，即回调实现。从本例可以得出，鼠标的点击确实没有被其他线程给阻塞。不过当监听的维度增多时，Callback 实现也随之增多。Java Swing 事件/监听是一种典型的既符合异步非阻塞，又属于 Callback 实现的场景，其并发模型可为同步或异步。不过，在 Java 8 之前，由于接口无法支持 <code>default</code> 方法，当接口方法过多时，通常采用 <code>Adapter</code> 模式作为缓冲方案，达到按需实现的目的。尤其在 Java GUI 场景中。即使将应用的 Java 版本升级到 8 ，由于这些 Adapter ”遗老遗少“实现的存在，使得开发人员仍不得不面对大量而繁琐的 Callback 折中方案。既然 Reactor 提出了这个问题，那么它或者 Reactive 能否解决这个问题呢？暂时存疑，下一步是如何理解 <code>Future</code> 的限制。</p>
<h5 id="理解-Future-的限制"><a href="#理解-Future-的限制" class="headerlink" title="理解 Future 的限制"></a>理解 <code>Future</code> 的限制</h5><p>Reactor 的观点仅罗列 <code>Future</code> 的一些限制，并没有将它们解释清楚，接下来用两个例子来说明其中原委。</p>
<h6 id="限制一：Future-的阻塞性"><a href="#限制一：Future-的阻塞性" class="headerlink" title="限制一：Future 的阻塞性"></a>限制一：<code>Future</code> 的阻塞性</h6><p>在前文示例中，<code>ParallelDataLoader</code> 利用 <code>CompletionService</code> API 实现 <code>load*()</code> 方法的并行加载，如果将其调整为 <code>Future</code> 的实现，可能的实现如下：</p>
<ul>
<li>Java <code>Future</code> 阻塞式加载示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureBlockingDataLoader</span> <span class="keyword">extends</span> <span class="title">DataLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">// 创建线程池</span></span><br><span class="line">        runCompletely(executorService.submit(<span class="keyword">super</span>::loadConfigurations));  <span class="comment">//  耗时 &gt;= 1s</span></span><br><span class="line">        runCompletely(executorService.submit(<span class="keyword">super</span>::loadUsers));           <span class="comment">//  耗时 &gt;= 2s</span></span><br><span class="line">        runCompletely(executorService.submit(<span class="keyword">super</span>::loadOrders));          <span class="comment">//  耗时 &gt;= 3s</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125; <span class="comment">// 总耗时 sum(&gt;= 1s, &gt;= 2s, &gt;= 3s)  &gt;= 6s</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runCompletely</span><span class="params">(Future&lt;?&gt; future)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get(); <span class="comment">// 阻塞等待结果执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FutureBlockingDataLoader().load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[线程 : pool-1-thread-1] loadConfigurations() 耗时 :  1003 毫秒</span><br><span class="line">[线程 : pool-1-thread-2] loadUsers() 耗时 :  2004 毫秒</span><br><span class="line">[线程 : pool-1-thread-3] loadOrders() 耗时 :  3002 毫秒</span><br><span class="line">load() 总耗时：6100 毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>结论</li>
</ul>
<p><code>ParallelDataLoader</code> 加载耗时为”3068 毫秒“，调整后的 <code>FutureBlockingDataLoader</code> 则比串行的 <code>DataLoader</code>  加载耗时（“6031 毫秒”）还要长。说明<code>Future#get()</code> 方法不得不等待任务执行完成，换言之，如果多个任务提交后，返回的多个 Future 逐一调用 <code>get()</code> 方法时，将会依次 blocking，任务的执行从并行变为串行。这也是之前为什么 <code>ParallelDataLoader</code> 不采取 <code>Future</code> 的解决方案的原因。</p>
<h6 id="限制二：Future-不支持链式操作"><a href="#限制二：Future-不支持链式操作" class="headerlink" title="限制二：Future  不支持链式操作"></a>限制二：<code>Future</code>  不支持链式操作</h6><p>由于 <code>Future</code>  无法实现异步执行结果链式处理，尽管 <code>FutureBlockingDataLoader</code> 能够解决方法数据依赖以及顺序执行的问题，不过它将并行执行带回了阻塞（串行）执行。所以，它不是一个理想实现。不过  <code>CompletableFuture</code>  可以帮助提升 <code>Future</code>  的限制：</p>
<ul>
<li>Java <code>CompletableFuture</code> 重构 <code>Future</code> 链式实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureChainDataLoader</span> <span class="keyword">extends</span> <span class="title">DataLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture</span><br><span class="line">                .runAsync(<span class="keyword">super</span>::loadConfigurations)</span><br><span class="line">                .thenRun(<span class="keyword">super</span>::loadUsers)</span><br><span class="line">                .thenRun(<span class="keyword">super</span>::loadOrders)</span><br><span class="line">                .whenComplete((result, throwable) -&gt; &#123; <span class="comment">// 完成时回调</span></span><br><span class="line">                    System.out.println(<span class="string">"加载完成"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .join(); <span class="comment">// 等待完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChainDataLoader().load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[线程 : ForkJoinPool.commonPool-worker-1] loadConfigurations() 耗时 :  1000 毫秒</span><br><span class="line">[线程 : ForkJoinPool.commonPool-worker-1] loadUsers() 耗时 :  2005 毫秒</span><br><span class="line">[线程 : ForkJoinPool.commonPool-worker-1] loadOrders() 耗时 :  3001 毫秒</span><br><span class="line">加载完成</span><br><span class="line">load() 总耗时：6093 毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>结论</li>
</ul>
<p>通过输出日志分析，  <code>FutureChainDataLoader</code> 并没有像 <code>FutureBlockingDataLoader</code> 那样使用三个线程分别执行加载任务，仅使用了一个线程，换言之，这三次加载同一线程完成，并且异步于 main 线程，如下所示：</p>
<p><img src="/img/assets/FutureChainDataLoader_Sequences.png" alt="FutureChainDataLoader"></p>
<p>尽管 <code>CompletableFuture</code>  不仅是异步非阻塞操作，而且还能将 Callback 组合执行，也不存在所谓的 ”Callback Hell“ 等问题。如果强制等待结束的话，又回到了阻塞编程的方式。同时，相对于  <code>FutureBlockingDataLoader</code>  实现，重构后的 <code>FutureChainDataLoader</code> 不存在明显性能提升。</p>
<blockquote>
<p>稍作解释，<code>CompletableFuture</code>  不仅可以支持 <code>Future</code> 链式操作，而且提供三种生命周期回调，即执行回调（Action）、完成时回调（Complete）、和异常回调（Exception），类似于 Spring 4 <code>ListenableFuture</code> 以及 Guava <code>ListenableFuture</code>。</p>
</blockquote>
<p>至此，Reactor 的官方参考文档再没有出现其他有关”传统编程模型中的某些困境“的描述，或许读者老爷和我一样，对 Reactive 充满疑惑，它真能解决以上问题吗？当然，监听则明，偏听则暗，下面我们再来参考 <a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams JVM</a> 的观点。</p>
<h4 id="Reactive-Streams-JVM-认为异步系统和资源消费需要特殊处理"><a href="#Reactive-Streams-JVM-认为异步系统和资源消费需要特殊处理" class="headerlink" title="Reactive Streams JVM 认为异步系统和资源消费需要特殊处理"></a><a href="https://github.com/reactive-streams/reactive-streams-jvm#goals-design-and-scope" target="_blank" rel="noopener">Reactive Streams JVM</a> 认为异步系统和资源消费需要特殊处理</h4><blockquote>
<p>Handling streams of data—especially “live” data whose volume is not predetermined—requires special care in an asynchronous system. The most prominent issue is that resource consumption needs to be carefully controlled such that a fast data source does not overwhelm the stream destination. Asynchrony is needed in order to enable the parallel use of computing resources, on collaborating network hosts or multiple CPU cores within a single machine. </p>
</blockquote>
<p>观点归纳：</p>
<ul>
<li>流式数据容量难以预判</li>
<li>异步编程复杂</li>
<li>数据源和消费端之间资源消费难以平衡</li>
</ul>
<p>此观点与 Reactor 相同的部分是，两者均认为异步编程复杂，而前者还提出了数据结构（流式数据）以及数据消费问题。</p>
<p>无论两者的观点孰优谁劣，至少说明一个现象，业界对于 Reactive 所解决的问题并非达到一致，几乎各说各话。那么，到底怎样才算 Reactive Programming 呢？</p>
<h3 id="什么是-Reactive-Programming"><a href="#什么是-Reactive-Programming" class="headerlink" title="什么是 Reactive Programming"></a>什么是 Reactive Programming</h3><p>关于什么是 Reactive Programming，下面给出六种渠道的定义，尝试从不同的角度，了解 Reactive Programming 的意涵。首先了解的是 “<a href="https://www.reactivemanifesto.org/" target="_blank" rel="noopener">The Reactive Manifesto</a>” 中的定义</p>
<h4 id="The-Reactive-Manifesto-中的定义"><a href="#The-Reactive-Manifesto-中的定义" class="headerlink" title="The Reactive Manifesto 中的定义"></a><a href="https://www.reactivemanifesto.org/" target="_blank" rel="noopener">The Reactive Manifesto</a> 中的定义</h4><p>Reactive Systems are: Responsive, Resilient, Elastic and Message Driven.  </p>
<blockquote>
<p><a href="https://www.reactivemanifesto.org/" target="_blank" rel="noopener">https://www.reactivemanifesto.org/</a></p>
</blockquote>
<p>该组织对 Reactive 的定义非常简单，其特点体现在以下关键字：</p>
<ul>
<li>响应的（Responsive）</li>
<li>适应性强的（Resilient）</li>
<li>弹性的（Elastic）</li>
<li>消息驱动的（Message Driven）</li>
</ul>
<p>不过这样的定义侧重于 Reactive 系统，或者说是设计 Reactive 系统的原则。</p>
<h4 id="维基百科中的定义"><a href="#维基百科中的定义" class="headerlink" title="维基百科中的定义"></a><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">维基百科</a>中的定义</h4><p>维基百科作为全世界的权威知识库，其定义的公允性能够得到保证：</p>
<blockquote>
<p>Reactive programming is a declarative programming paradigm concerned with <strong>data streams</strong> and the <strong>propagation of change</strong>. With this paradigm it is possible to express static (e.g. arrays) or dynamic (e.g. event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow. </p>
<blockquote>
<p>参考地址：<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reactive_programming</a></p>
</blockquote>
</blockquote>
<p>维基百科认为 Reactive programming 是一种声明式的编程范式，其核心要素是<strong>数据流（data streams ）</strong>与<strong>其传播变化（ propagation of change）</strong>，前者是关于数据结构的描述，包括静态的数组（arrays）和动态的事件发射器（event emitters）。由此描述，在笔者脑海中浮现出以下技术视图：</p>
<ul>
<li>数据流：Java 8 <code>Stream</code> </li>
<li>传播变化：Java <code>Observable</code>/<code>Observer</code></li>
<li>事件/监听：Java <code>EventObject</code>/<code>EventListener</code></li>
</ul>
<p>这些技术能够很好地满足维基百科对于 Reactive 的定义，那么， Reactive 框架和规范的存在意义又在何方？或许以上定义过于抽象，还无法诠释 Reactive 的全貌。于是乎，笔者想到了去 Spring 官方找寻答案，正如所愿，在 Spring Framework 5 官方参考文档中找到其中定义。</p>
<h4 id="Spring-5-中的定义"><a href="#Spring-5-中的定义" class="headerlink" title="Spring 5 中的定义"></a><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive" target="_blank" rel="noopener">Spring</a> 5 中的定义</h4><blockquote>
<p>The term “reactive” refers to programming models that are built around <strong>reacting to change</strong> — network component reacting to I/O events, UI controller reacting to mouse events, etc. In that sense <strong>non-blocking</strong> is reactive because instead of being blocked we are now in the mode of reacting to notifications as operations complete or data becomes available. </p>
<blockquote>
<p>参考地址：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-why-reactive</a></p>
</blockquote>
</blockquote>
<p>相对于维基百科的定义，Spring 5 WebFlux 章节同样也提到了变化响应（reacting to change ） ，并且还说明非阻塞（non-blocking）就是 Reactive。同时，其定义的侧重点在响应通知方面，包括操作完成（operations complete）和数据可用（data becomes available）。Spring WebFlux 作为 Reactive Web 框架，天然支持非阻塞，不过早在 Servlet 3.1 规范时代皆以实现以上需求，其中包括 Servlet 3.1 非阻塞 API <code>ReadListener</code> 和<code>WriteListener</code>，以及 Servlet 3.0 所提供的异步上下文 <code>AsyncContext</code> 和事件监听 <code>AsyncListener</code>。这些 Servlet 特性正是为 Spring WebFlux 提供适配的以及，所以 Spring WebFlux 能完全兼容 Servlet 3.1 容器。笔者不禁要怀疑，难道 Reactive 仅是新包装的概念吗？或许就此下结论还为时尚早，不妨在了解一下 ReactiveX 的定义。</p>
<h4 id="ReactiveX-中的定义"><a href="#ReactiveX-中的定义" class="headerlink" title="ReactiveX 中的定义"></a><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a> 中的定义</h4><p>广泛使用的 RxJava 作为 ReactiveX 的 Java 实现，对于 Reactive 的定义，ReactiveX 具备相当的权威性：</p>
<blockquote>
<p>ReactiveX extends the observer pattern to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</p>
<blockquote>
<p>参考地址：<a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">http://reactivex.io/intro.html</a></p>
</blockquote>
</blockquote>
<p>不过，ReactiveX 并没有直接给 Reactive 下定义，而是通过技术实现手段说明如何实现 Reactive。ReactiveX 作为观察者模式的扩展，通过操作符（Opeators）对数据/事件序列（Sequences of data and/or events )进行操作，并且屏蔽并发细节（abstracting away…），如线程 API（<code>Exectuor</code> 、<code>Future</code>、<code>Runnable</code>）、同步、线程安全、并发数据结构以及非阻塞 I/O。该定义的侧重点主要关注于实现，包括设计模式、数据结构、数据操作以及并发模型。除设计模式之外，Java 8 <code>Stream</code> API 具备不少的操作符，包括迭代操作 for-each、map/reduce 以及集合操作 <code>Collector</code>等，同时，通过 <code>parallel()</code> 和 <code>sequential()</code> 方法实现并行和串行操作间的切换，同样屏蔽并发的细节。至于数据结构，<code>Stream</code> 和数据流或集合序列可以画上等号。唯独在设计模式上，<code>Stream</code> 是迭代器（Iterator）模式实现，而 ReactiveX 则属于观察者（Observer）模式的实现。 对此，Reactor 做了进一步地解释。</p>
<h4 id="Reactor-中的定义"><a href="#Reactor-中的定义" class="headerlink" title="Reactor 中的定义"></a><a href="http://projectreactor.io/docs/core/release/reference/#intro-reactive" target="_blank" rel="noopener">Reactor</a> 中的定义</h4><blockquote>
<p>The reactive programming paradigm is often presented in object-oriented languages as an extension of the Observer design pattern. One can also compare the main reactive streams pattern with the familiar Iterator design pattern, as there is a duality to the Iterable-Iterator pair in all of these libraries. One major difference is that, while an Iterator is pull-based, reactive streams are push-based. </p>
<blockquote>
<p><a href="http://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">http</a><a href="http://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">://projectreactor.io/docs/core/release/reference/#</a><a href="http://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">intro-reactive</a></p>
</blockquote>
</blockquote>
<p>同样地，Reactor 也提到了观察者模式（Observer pattern ）和迭代器模式（Iterator pattern）。不过它将 Reactive 定义为响应流模式（Reactive streams pattern ），并解释了该模式和迭代器模式在数据读取上的差异，即前者属于推模式（push-based），后者属于拉模式（pull-based）。难道就因为这因素，就要使用 Reactive 吗？这或许有些牵强。个人认为，以上组织均没有坦诚或者简单地向用户表达，都采用一种模糊的描述，多少难免让人觉得故弄玄虚。幸运地是，我从 ReactiveX 官方找到一位前端牛人 <a href="https://gist.github.com/staltz" target="_blank" rel="noopener">André Staltz</a>，他在学习 Reactive 过程中与笔者一样，吃了不少的苦头，在他博文<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">《The introduction to Reactive Programming you’ve been missing》</a>中，他给出了中肯的解释。</p>
<h4 id="Andre-Staltz-给出的定义"><a href="#Andre-Staltz-给出的定义" class="headerlink" title="André Staltz 给出的定义"></a><a href="https://gist.github.com/staltz" target="_blank" rel="noopener">André Staltz</a> 给出的定义</h4><blockquote>
<p><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams" target="_blank" rel="noopener">Reactive programming is programming with <strong>asynchronous data streams</strong>.</a></p>
<p>In a way, <strong>this isn’t anything new</strong>. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. Reactive is that <strong>idea on steroids</strong>. You are able to create data streams of anything, not just from click and hover events. Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc. </p>
<blockquote>
<p><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#what-is-reactive-programming" target="_blank" rel="noopener">“What is Reactive Programming?”</a></p>
</blockquote>
</blockquote>
<p>他在文章指出，Reactive Programming 并不是新东西，而是司空见惯的混合物，比如事件总监、鼠标点击事件等。同时，文中也提到异步（asynchronous ）以及数据流（data streams）等关键字。如果说因为 Java 8 Stream  是迭代器模式的缘故，它不属于Reactive Programming 范式的话，那么，Java GUI 事件/监听则就是 Reactive。那么，Java 开发人员学习 RxJava、Reactor、或者 Java 9 Flow API 的必要性又在哪里呢？因此，非常有必要深入探讨 Reactive Programming 的使用场景。</p>
<h3 id="Reactive-Programming-使用场景"><a href="#Reactive-Programming-使用场景" class="headerlink" title="Reactive Programming 使用场景"></a>Reactive Programming 使用场景</h3><p>正如同 Reactive Programming 的定义那样，各个组织各执一词，下面仍采用多方引证的方式，寻求 Reactive Programming 使用场景的“最大公约数”。</p>
<h4 id="Reactive-Streams-JVM-认为的使用场景"><a href="#Reactive-Streams-JVM-认为的使用场景" class="headerlink" title="Reactive Streams JVM 认为的使用场景"></a><a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams JVM</a> 认为的使用场景</h4><blockquote>
<p>The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary. </p>
<blockquote>
<p><a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">https://github.com/reactive-streams/reactive-streams-jvm</a></p>
</blockquote>
</blockquote>
<p><a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams JVM</a> 认为 Reactive Streams 用于在异步边界（asynchronous boundary）管理流式数据交换（ govern the exchange of stream data）。异步说明其并发模型，流式数据则体现数据结构，管理则强调它们的它们之间的协调。</p>
<h4 id="Spring-5-认为的使用场景"><a href="#Spring-5-认为的使用场景" class="headerlink" title="Spring 5 认为的使用场景"></a><a href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web-reactive.html#webflux-performance" target="_blank" rel="noopener">Spring 5</a> 认为的使用场景</h4><blockquote>
<p>Reactive and non-blocking generally do not make applications run faster. They can, in some cases, for example if using the <code>WebClient</code> to execute remote calls in parallel. On the whole it requires more work to do things the non-blocking way and that can increase slightly the required processing time. </p>
<p>The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load because they scale in a more predictable way. </p>
</blockquote>
<p>Spring 认为 Reactive 和非阻塞通常并非让应用运行更快速（generally do not make applications run faster），甚至会增加少量的处理时间，因此，它的使用场景则利用较少的资源，提升应用的伸缩性（scale with a small, fixed number of threads and less memory）。</p>
<h4 id="ReactiveX-认为的使用场景"><a href="#ReactiveX-认为的使用场景" class="headerlink" title="ReactiveX 认为的使用场景"></a><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX</a> 认为的使用场景</h4><blockquote>
<p>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs. </p>
</blockquote>
<p>ReactiveX 所描述的使用场景与 Spring 的不同，它没有从性能入手，而是代码可读性和减少 Bugs 的角度出发，解释了 Reactive Programming 的价值。同时，强调其框架的核心特性：异步（asynchronous）、同顺序（same sort）和组合操作（composable operations）。它也间接地说明了，Java 8 <code>Stream</code> 在组合操作的限制，以及操作符的不足。</p>
<h4 id="Reactor-认为的使用场景"><a href="#Reactor-认为的使用场景" class="headerlink" title="Reactor 认为的使用场景"></a><a href="http://projectreactor.io/docs/core/release/reference/#intro-reactive" target="_blank" rel="noopener">Reactor</a> 认为的使用场景</h4><blockquote>
<p>Composability and readability</p>
<p>Data as a flow manipulated with a rich vocabulary of operators</p>
<p>Nothing happens until you subscribe</p>
<p>Backpressure or the ability for the consumer to signal the producer that the rate of emission is too high</p>
<p>High level but high value abstraction that is concurrency-agnostic</p>
</blockquote>
<p>Reactor 同样强调结构性和可读性（Composability and readability）和高层次并发抽象（High level abstraction），并明确地表示它提供丰富的数据操作符（ rich vocabulary of operators）弥补 <code>Stream</code> API 的短板，还支持背压（Backpressure）操作，提供数据生产者和消费者的消息机制，协调它们之间的产销失衡的情况。同时，Reactor 采用订阅式数据消费（Nothing happens until you subscribe）的机制，实现 <code>Stream</code> 所不具备的数据推送机制。</p>
<p>至此，讨论接近尾声，最后的部分将 Reactive Programming 内容加以总结。</p>
<h2 id="总结-Reactive-Programming"><a href="#总结-Reactive-Programming" class="headerlink" title="总结 Reactive Programming"></a>总结 Reactive Programming</h2><p>Reactive Programming 作为观察者模式（<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noopener">Observer</a>） 的延伸，不同于传统的命令编程方式（ <a href="https://en.wikipedia.org/wiki/Imperative_programming" target="_blank" rel="noopener">Imperative programming</a>）同步拉取数据的方式，如迭代器模式（<a href="https://en.wikipedia.org/wiki/Iterator_pattern" target="_blank" rel="noopener">Iterator</a>） 。而是采用数据发布者同步或异步地推送到数据流（Data Streams）的方案。当该数据流（Data Steams）订阅者监听到传播变化时，立即作出响应动作。在实现层面上，Reactive Programming 可结合函数式编程简化面向对象语言语法的臃肿性，屏蔽并发实现的复杂细节，提供数据流的有序操作，从而达到提升代码的可读性，以及减少 Bugs 出现的目的。同时，Reactive Programming  结合背压（Backpressure）的技术解决发布端生成数据的速率高于订阅端消费的问题。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2005年，李敖大师曾在上海复旦大学做过一次演讲，他在讲到“放弃自由主义，注重务实”的部分时，引述一段故事：</p>
<blockquote>
<p>美国有一个报纸，办报的人叫ABBOTT，他晚年的时候写回忆录，他爸爸是一个写儿童书的作家，他爸爸临死前告诉他说，感觉到人间所有的教会的争执90％都是名词之争。这个小ABBOTT老了以后，他回忆这段话，他说我回忆我爸爸告诉我所有人间宗教的争执90％都是名词之争，他说我发现我爸爸数学不好，原来最后那10％也是名词之争。</p>
</blockquote>
<p>实际上，名词之争的战场不限于宗教教会，技术领域不也是如此吗？Reactive Programming 实际是一种技术，却被各自表达。有些定义含糊不清，有些定义则空洞无实，还有一些则是夸大其词，只有少数保持客观中立。不免让然唏嘘技术领域的非理性营销。当了解了 Reactive Programming 的本质后，您的热情还能像如初般地高涨吗？</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/12/19/2018-01-18-Dubbo 外部化配置/" data-toggle="tooltip" data-placement="top" title="Dubbo 外部化配置（Externalized Configuration）">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/12/19/2018-06-28-Dubbo Cloud Native 实践与思考/" data-toggle="tooltip" data-placement="top" title="Dubbo Cloud Native 实践与思考">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Reactive-Programming-一种技术，各自表述"><span class="toc-text">Reactive Programming 一种技术，各自表述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初识-Reactive"><span class="toc-text">初识 Reactive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解-Reactive"><span class="toc-text">理解 Reactive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-Reactive-的一些讲法"><span class="toc-text">关于 Reactive 的一些讲法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传统编程模型中的某些困境"><span class="toc-text">传统编程模型中的某些困境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-认为阻塞可能是浪费的"><span class="toc-text">Reactor 认为阻塞可能是浪费的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Blocking-Can-Be-Wasteful"><span class="toc-text">3.1. Blocking Can Be Wasteful</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#理解阻塞的弊端"><span class="toc-text">理解阻塞的弊端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#理解并行的复杂"><span class="toc-text">理解并行的复杂</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-认为异步不一定能够救赎"><span class="toc-text">Reactor 认为异步不一定能够救赎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Asynchronicity-to-the-Rescue"><span class="toc-text">3.2. Asynchronicity to the Rescue?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#理解-“Callback-Hell”"><span class="toc-text">理解 “Callback Hell”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#理解-Future-的限制"><span class="toc-text">理解 Future 的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#限制一：Future-的阻塞性"><span class="toc-text">限制一：Future 的阻塞性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#限制二：Future-不支持链式操作"><span class="toc-text">限制二：Future  不支持链式操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactive-Streams-JVM-认为异步系统和资源消费需要特殊处理"><span class="toc-text">Reactive Streams JVM 认为异步系统和资源消费需要特殊处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-Reactive-Programming"><span class="toc-text">什么是 Reactive Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Reactive-Manifesto-中的定义"><span class="toc-text">The Reactive Manifesto 中的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#维基百科中的定义"><span class="toc-text">维基百科中的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-5-中的定义"><span class="toc-text">Spring 5 中的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReactiveX-中的定义"><span class="toc-text">ReactiveX 中的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-中的定义"><span class="toc-text">Reactor 中的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Andre-Staltz-给出的定义"><span class="toc-text">André Staltz 给出的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactive-Programming-使用场景"><span class="toc-text">Reactive Programming 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactive-Streams-JVM-认为的使用场景"><span class="toc-text">Reactive Streams JVM 认为的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-5-认为的使用场景"><span class="toc-text">Spring 5 认为的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReactiveX-认为的使用场景"><span class="toc-text">ReactiveX 认为的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-认为的使用场景"><span class="toc-text">Reactor 认为的使用场景</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-Reactive-Programming"><span class="toc-text">总结 Reactive Programming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-text">后记</span></a></li>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 会飞的鱼 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
