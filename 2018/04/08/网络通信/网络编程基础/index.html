<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      网络编程基础 | 会飞的鱼
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>会飞的鱼</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>网络编程基础</h2>
  <p class="post-date">2018-04-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>##网络编程基础</p>
<ul>
<li><p>一、网络硬件</p>
<ul>
<li>关于计算机网络，没有一种被普遍接受的分类方法，但有两个因素非常重要：传输技术和距离尺度</li>
<li><p>目前普遍使用的传输技术有两种：</p>
<ul>
<li>（1）广播式连接</li>
<li><p>（2）点到点连接</p>
</li>
<li><p>广播式网络(broadcast networks)只有一个通信信道，网络上所有的机器都共享该信道。机器间传递的是短消息（分组或包），任何一台机器发送的短消息可以被其他所有机器接收到。分组中有一个地址域，指明了该分组的目标接收者。一台机器接收到一个分组后，它检查地址域。如果该分组是发送给他的，那么它就处理，否则，忽略。此外，可以通过地址域实现让所有机器都就收处理，或者让一组机器接受处理。</p>
</li>
<li>点到点网络是由许多连接构成，每一个连接对应一对机器。将一个分组传递到目的地可能要经过多台机器，所以最优路径对点到点网络很重要。</li>
<li>一般原则：越小的，地理位置局部化的网络倾向于广播传播模式，而大的网络倾向于点到点传播模式。</li>
<li>分类网络的另一个准则是网络的距离尺度。相应的可以划分为<ul>
<li>个人区域网（personal area network):例如一个无线网络将一台计算机与它的鼠标，键盘，打印机连接起来，这就是一个个人区域网。</li>
<li>局域网络</li>
<li>城域网络</li>
<li>广域网络</li>
</ul>
</li>
</ul>
</li>
<li><p>局域网(local area network,LAN)</p>
<ul>
<li>范围：一个建筑内到几千米的范围。</li>
<li>通常将公司办公室或工厂中的个人计算机和工作站连接器来，以便共享资源和交换信息。</li>
<li>不同于其他类型网络的特征：范围，传输技术，拓扑结构。</li>
<li>可能的传输技术：所有机器连接到同一根电缆上，传输速度一般可达10Gbps。 Mbps(每秒百兆位，1Mbps=1000 000位/每秒)，Gbps(1000 000 000位/每秒)。</li>
<li>广播式LAN也可能有不同的拓扑结构。<ul>
<li>总线型网络中，任何一个时刻，至多有一台机器是主机器，并且只有它才可以传送数据。其他的机器都被禁止发送数据。如何解决冲突：需要一种仲裁机制解决冲突。例如，以太网（Ethernet,IEEE 802.3)中发生冲突时，每台计算机只是等待一段随机时间，然后再次尝试发送数据。</li>
<li>环形网络。在环中，每一位都沿着自己的路径独立向前传播，而不需要等待它所属分组的其他位。例如IEEE802.5(IBM令牌环)</li>
</ul>
</li>
</ul>
</li>
<li><p>城域网（metropolitan area network,MAN）</p>
<ul>
<li>范围：覆盖一个城市</li>
<li>例如，有线电视网</li>
</ul>
</li>
<li><p>广域网（wide area network,WAN）</p>
<ul>
<li>范围：通常是一个国家或一个洲。</li>
<li>广域网包括主机（用户所有。例如，个人计算机）及通信子网（简称子网，由电话公司或Internet服务提供商所有）</li>
<li>子网由两个独立的部分组成：传输线和交换单元</li>
<li>传输线用于在机器之间传送数据位，可以由铜线，光纤，无线电链路构成。</li>
<li>交换单元：一种特殊的计算机，它们连接了三条或者更多条传输线。当数据在一条进线上到达的时候，交换单元必须选择一条出线，以便将数据转发出去。这些交换计算机过去被称为“路由器”</li>
<li>每一台主机往往连接到一个LAN上，在LAN上会有一个路由器，某些情况下，主机也可以直接连到一个路由器上。通信线和路由器（不包括主机）的集合构成了子网。</li>
<li>分组交换WAN的原则：“存储-转发”或“分组交换”。</li>
</ul>
</li>
<li><p>无线网络</p>
<ul>
<li>分为（1）系统互连（例如，蓝牙）；（2）无线LAN（3）无线WAN</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>二、网络软件</p>
<ul>
<li><p>为了降低网络设计的复杂性，绝大多数网络都组织成一队相互叠加的层，每一层都建立在其下一层的基础之上。</p>
</li>
<li><p>数据不是从一台机器的第n层直接传递到另一台机器的第n层。相反，每一层都将数据和控制信息传递给它的下一层，这样一直传递到最低下的层。第一层最下面是物理介质。</p>
</li>
<li><p>层和协议的集合称为网络体系结构。一个特定的系统所使用的的一组协议（每层一个协议）称为协议栈。</p>
</li>
<li><p>各层的实际问题</p>
<ul>
<li>每一层，都需要一种机制来标识出发送方和接收方。一般网络上有好多计算机，计算机上又有许多进程，所以需要一种编址机制来指定一个特定的目标。</li>
<li>协议需要确定每个连接对应多少逻辑信道，且确定他们的优先级别。许多网络至少提供两个逻辑信道，一个用于普通数据，一个用于紧急数据。</li>
<li>错误控制。</li>
<li>发送方发送速度很快时，如何避免接收方被数据淹没。有些是利用一种反馈机制，有些方案则限制发送方以商定的速率发送（流量控制）。</li>
<li>为每一对通信进程建立一个单独的连接，很不方便，且代价高昂。因此，可以是多对进程使用同一连接。多路复用，多路解复用。</li>
<li>路由选择。当源端和目标端之间存在多条路径的时候，必须进行路由选择。</li>
</ul>
</li>
<li><p>面向连接与无连接的服务</p>
<ul>
<li>面向连接的服务是基于电话系统模型的。</li>
<li>无连接的服务是基于邮政系统模型的。</li>
</ul>
</li>
<li><p>服务原语：一个服务通常是由一组原语（primitive）操作来描述的，用户进程通过这些原语操作可以访问服务。</p>
<ul>
<li>例子：为了实现一个可靠的字节流，可以考虑原语如下<ul>
<li>LISTEN：阻塞操作，等待一个进入的连接</li>
<li>CONNECT:与一个正在等待的对等体建立连接</li>
<li>RECEIVE：阻塞操作，等待一个进入的报文</li>
<li>SEND：给对等体发送一个报文</li>
<li>DISCONNECT:终止一个连接</li>
</ul>
</li>
<li>服务和协议的区别：服务好像是面向对象语言中的抽象数据类型或对象，它定义了在对象上可以执行的操作，但并没有具体实现。协议涉及到服务的具体实现。</li>
</ul>
</li>
<li><p>OSI参考模型</p>
<ul>
<li><p>OSI（Open System Interconnection）</p>
</li>
<li><p>物理层（physical layer）：涉及到在通信信道上传输的原始数据位。</p>
</li>
<li><p>数据链路层（data link layer）：主要将一个原始的传输设施转变成一条逻辑的传输线路，在这条传输线路上，所有检测出来的传输错误也会反应到网络层。数据链路层的做法是：让发送方将输入的数据拆分，分装到数据帧（data fram,通常几百或几千个字节），然后顺序的传送这些数据帧。如果是可靠的服务，接收方接收到后，给发送方送回一个确认帧（acknowledgement frame）。问题：快速发送方“淹没”掉慢速的接收方。解决：流量调节机制。</p>
</li>
<li><p>网络层（network layer）:控制子网的运行过程。网络层应当确定如何将分组从源端路由到目标端。问题：两个网络的编址方案不同，连接的问题。分组太大，另一个网络无法接受。</p>
</li>
<li><p>传输层（transport layer）：基本功能是接收来自上一层的数据，并且在必要的时候把这些数据分割成很小的单元，然后把数据单元传递给网络层，并确保这些数据片段都能够的到达另一端。</p>
</li>
<li><p>会话层（session layer）：允许不同机器上的用户之间建立回话。</p>
<ul>
<li>所谓会话，通常指各种服务，包括：<ul>
<li>对话控制（dialog control）：记录下该谁来传递数据了</li>
<li>令牌管理（token management）：禁止双方同时执行同一个关键操作</li>
<li>同步功能（synchronization）：在一个长的传输过程中设置一些检查点，以便在系统奔溃之后还能够在奔溃前的点上继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>表示层（presentation layer）：表示层下面各层中，关注的是如何传递数据位，而表示层关注的是所传递的信息的语法和语义。不同计算机可能会使用不同的数据表示法，为了让这些计算机能够进行通信，它们所交换的数据结构必须以一种抽象的方式来定义，同时，表示层还应该定义一种标准的编码方式，用来表达网络线路上所传递的数据。</p>
</li>
<li><p>应用层（application layer）：包含了各种各同样的协议，这些协议往往直接针对用户的需要，一个广泛使用的应用协议是HTTP（HyperText Transfer Protocol），它也是WWW（万维网）的基础。</p>
</li>
</ul>
</li>
<li><p>TCP/IP参考模型</p>
<ul>
<li><p>包括四层：应用层，传输层，互联网层，主机至网络。</p>
</li>
<li><p>互联网层（Internet layer）：互联网层定义了正式的分组格式和协议，该协议称为IP（Internet Protocol)。互联网层的任务是将IP分组投递到它们该去的地方。分组路由和避免拥塞是最主要的问题。</p>
</li>
<li><p>传输层：它的设计目标是容许源和目标主机上的对等体之间可以进行对话。包括TCP（Transport Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）。</p>
</li>
<li><p>应用层：包括</p>
<ul>
<li>虚拟终端协议（TELNET）：允许一台机器上的用户登录到远程的机器上，并且在远程的机器上进行工作。</li>
<li>文件传输协议（FTP）：提供了一种在两台机器之间高效地移动数据的途径。</li>
<li>电子邮件协议（SMPT）</li>
<li>DNS（Domain Name System，域名系统）：将主机名字映射到它们的网络地址。</li>
<li>HTTP用于获取www上的页面；等等。</li>
</ul>
</li>
<li><p>主机至网络层：TCP/IP参考模型并没有明确规定这里应该有哪些内容，它只是指出，主机必须通过某个协议连接到网络上，以便可以将分组发送到网络上。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三、物理层（简单介绍）</p>
<ul>
<li><p>数据通信理论的基础：傅立叶分析</p>
<ul>
<li>任何一个正常的周期为T的函数，都可以展开成多个（可能无线个）正弦和余弦函数的和。</li>
<li>正弦函数和余弦函数正交归一的关系</li>
<li>有限带宽的信号。带宽：传输过程中振幅不会明显减弱的这一段频率范围称为带宽（bandwidth）</li>
<li>信道的最大数据传输率。尼奎斯特采样定理和香农定理</li>
</ul>
</li>
<li><p>有导向的传输介质</p>
<ul>
<li>磁介质</li>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
</ul>
</li>
<li><p>无线传输</p>
<ul>
<li>电波传输</li>
<li>红外线和毫米波</li>
<li><p>光波传输</p>
</li>
<li><p>各类通信卫星</p>
</li>
</ul>
</li>
<li><p>移动通信系统及有线电视</p>
</li>
</ul>
</li>
<li><p>四、数据链路层</p>
<ul>
<li><p>数据链路层的设计要点</p>
<ul>
<li><p>数据链路层要完成的特点的功能</p>
<ul>
<li>1.向网络层提供一个定义良好的服务接口；</li>
<li>2.处理传输错误</li>
<li>3.调节数据流，确保慢速的接收方不会被快速的发送方淹没</li>
</ul>
</li>
<li><p>为了实现这些目标，数据链路层从网络层获取到分组，然后将这些分组封装到帧中以便传输。每一帧包括一个帧头、一个有效载荷域（用于存放分组），以及一个帧尾。帧管理构成了数据链路层的工作核心。</p>
</li>
</ul>
</li>
<li><p>数据链路层的功能是为网络层提供服务。最主要的服务是将数据从源机器的网络层传输到目标机器的网络层。</p>
</li>
<li><p>一般情况下，提供三种服务：</p>
<ul>
<li>无确认的无连接服务：源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认。</li>
<li>有确认的无连接服务：虽然没有使用逻辑连接，但所发的每一帧都需要单独的确认。超时后，会重发该帧。</li>
<li>有确认的面向连接服务：源机器和目标机器首先建立一个连接。该连接上发送的每一帧都被编号，数据链路层保证每一帧都会真正的被接收到。可以保证每一帧只被接收一次，且按照正确的顺序被接收。</li>
</ul>
</li>
<li><p>成帧：物理层的任务是接收一个原始的位流，并试图将它递交给目标机器，这个位流容易产生错误（位的数量改变，值发生变化等），检测错误和纠正错误的工作是由数据链路层来完成。</p>
</li>
<li><p>由于依靠时间来标识每一帧的起始和结束位置风险太大，所以要设计其他方法。</p>
<ul>
<li>1.字符计数法：每利用头部中的一个域来指定该帧中的字符数。问题，计数值有可能因为传输错误而被弄乱。</li>
<li>2.含字节填充的分界符法：它的做法是让每一帧都用一些特殊的字节做为开始和结束。缺点：它紧紧依赖8位字符的模式。</li>
<li>3.含位填充的分界标志法：</li>
<li>4.物理层编码违例法：</li>
</ul>
</li>
<li><p>错误控制：接收方送回一些特殊的控制帧用以确认信息。帧丢失的情况，可以采用定时器来解决（例如，超过定时器限制时间，则重发帧）。</p>
</li>
<li><p>流控制：如果发送方发送的帧的速度超过了接收方能够接受的这些帧的速度，则发送方该如何处理呢？解决办法：</p>
<ul>
<li>1.基于反馈的流量控制（feedback-based flow control）,接收方给发送方送回信息，允许它发送更多的数据，或者至少告诉发送它的情况怎么样。</li>
<li>2.基于速率的流量控制（rate-based flow control），使用这种方法的协议有一种内置机制，它限制了发送方传输数据的速率，而无需利用接收方的反馈信息（数据链路层不使用）。</li>
</ul>
</li>
<li><p>错误检测和纠正</p>
<ul>
<li>纠错码（error-correcting code）:在每一个被发送的数据块中包含足够的冗余信息，以便接收方可以推断出被发送的数据中肯定有哪些内容。<ul>
<li>包含m个数据位（报文）和r个冗余位（校验位）。我们把包含数据和校验位的n(n=m+r)位单元通常也称为n位码字（codeword）。</li>
<li>两个码字中不相同的位的个数称为海明距离（Hamming distance）。意义：如果两个码字的海明距离为d，则需要d个1位错误才能将一个码字变成另一个码字。例子，奇偶校验。<br>-检错码（error-detecting code）:也包含一些冗余信息，但这些信息只能让接收者推断出发生了错误，但推断不出发生了哪个错误，然后接受方可以请求重传。</li>
</ul>
</li>
</ul>
</li>
<li><p>基本的数据链路协议</p>
<ul>
<li><p>基本假设：1.多数情况下，物理层和数据链路层进程会在一个特殊的网络I/O电路中的一个处理器上运行；而网络层代码则在主CPU上运行（其他情况也是可能的）。2.机器A希望用一个可靠地、面向连接的服务，向机器B发送一个长的数据流。</p>
</li>
<li><p>一个无限制的单工协议：该协议中，数据只能单向传输，传输方和接收方的网络层总是处于准备就绪的状态。处理的时间可以被忽略。假设缓存空间无限大。数据链路层之间的通信信道永远不会损坏或者丢失帧。</p>
</li>
<li><p>一个单工的停-等协议：需要处理的问题是如何避免发送方用超过接收能力的大量数据来淹没接收方。一般解决方案为，让接收方提供反馈信息给发送方。发送方送出一帧，然后先等待一个确认，再继续发送，这样的协议称为停-等协议（stop-and-wait）。</p>
</li>
<li><p>有噪声信道的单工协议：可能的情况就是有噪声的情况会导致帧信息损坏。确认帧完全丢失就会导致数据源机器不断地向目标机器发送相同的帧数据。解决办法：可以通过在每一帧的头部放上一个序列号用于判断是新帧还是重复帧。</p>
</li>
<li><p>滑动窗口协议（sliding window protocol）：</p>
<ul>
<li><p>上面的协议中，数据帧只在一个方向上传输。而大多数情况数据传输是双向的。解决办法：全双工数据传输（例如，使用两条独立的通信信道）。但这样会导致逆向信道带宽的浪费。</p>
</li>
<li><p>更好的办法：使用一条线路来传输两个方向上的数据。该模型中，从机器A到机器B的数据帧可以与从机器A到机器B的确认帧混合在一起。接收方只要检查证的头部的kind域，就可以区别该帧是数据还是确认。</p>
</li>
<li><p>更好的改进：当一个数据帧到达的时候，接收方并不是立即发送一个单独的控制帧，而是等待一会，直到网络层传递给它下一个分组，将确认信息（控制帧）和外发数据帧一起发送。这种将确认暂时延迟以便钩到下一个外发数据帧的技术称为捎带确认（piggybacking）。问题：数据链路层应该等待下一个分组多长时间？</p>
</li>
<li><p>滑动窗口协议的本质是：在任何时刻，发送方总是维持着一组序列号，分别对应于允许它发送的帧。我们称这些帧落在发送窗口（sending window）之内。类似的，接收方也维持着一个接收窗口（receiving window），对应于一组允许它接收的帧。发送方的窗口和接收方的窗口不必有同样的上下界，甚至比必有同样的大小。有些协议中，窗口有固定的大小，另一些协议中窗口的大小变化。</p>
<ul>
<li>发送方必须在内存中保存好所有这些帧，以便可能进行重传。如果最大窗口尺寸为n，则发送方需要n个缓冲区来存放未被确认的帧。</li>
<li><p>接收方数据链路层窗口对应于它可以接受的帧。任何落在窗口外面的帧都被丢弃，无需任何提示。</p>
</li>
<li><p>1位滑动窗口协议：一个最大窗口尺寸为1的滑动窗口协议。由于发送方在送出一帧以后，在发送下一帧之前要等待前一帧的确认。因此这样的1位滑动窗口协议使用了停-等的办法。</p>
</li>
<li><p>使用回退n帧技术的协议：目前为止，我们默认的假设是，一帧到达接收方所需要的传输时间加上确认帧回来的传输时间可以忽略不计。有时候这种假设是不正确的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>协议的验证(了解)</p>
<ul>
<li>有限状态机模型（finite state machine）</li>
<li>Petri网模型</li>
</ul>
</li>
<li><p>数据链路层协议示例</p>
<ul>
<li><p>SDLC（Synchronous Data Link Control,同步数据链路控制）协议（IBM提出））</p>
<ul>
<li>ADCCP（Advanced Data Communication Control Procedure,高级数据通信控制规程）（ANSI在SDLC基础上修改得到）</li>
<li>HDLP（High-level Data Link Control,高级数据链路控制）。（ISO在SDLC基础上修改）</li>
<li>这些协议基于相同的原理。所有协议是面向位的，并且为了确保数据的透明性，它们都使用了位填充</li>
<li>面向位填充协议帧的基本结构。<ul>
<li>帧的分界，标志序列（01111110）。</li>
<li>地址（address）域：对多个终端的线路显得很重要，因为在这样的环境中，该域被用于标识一个终端。</li>
<li>控制（Control）域：被用作序列号、确认，以及其他用途。</li>
<li>数据（Data）域：可以包含任何信息。它可以任意长，不过随着帧长度的增加，校验和的效率会降低，因为突发性错误的概率会加大。</li>
<li>校验和域（Checksum）：该域是一个循环冗余码。</li>
</ul>
</li>
</ul>
</li>
<li><p>Internet中的数据链路层</p>
<ul>
<li>在单个建筑物内，通常使用LAN来实现互连，但绝大多数的广域设施则通过点到点的租用线路构建起来的。</li>
<li>Internet中使用的数据链路协议称为PPP。PPP（Point-to-Point Protocol,点到点协议），它有多种用途，其中包括传送从路由器到路由器之间的流量，以及家庭用户到ISP之间的流量。PPP提供了三类功能：<br>  -（1）一种成帧方法。它可以毫无歧义地分隔出一帧的结束和下一帧的开始。并且帧的格式支持错误检测。<ul>
<li>（2）一个链路控制协议，可用于启动线路、测试线路、协商参数，以及当线路不在需要的时候可以温和的关闭线路。该协议称为LCP（Link Control Protocol，链路控制协议）。</li>
<li>（3）一种协商网络层选项的方法，并且协商方法与所使用的网络层协议独立。所选择的方法对于每一种支持的网络层都有一个不同的NCP（Network Control Protocol，网络控制协议）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：数据链路层的任务是将物理层提供的原始位流转换成可供网络层使用的帧流。用到的成帧方法包括：字符计数法、字节填充法和位填充法。为了避免快速发送方淹没一个慢速的接收方，数据链路协议需要提供流量控制功能。滑动窗口机制，两个窗口大小都为1，滑动窗口机制变成了停-等协议，当发送窗口大于1，接收方可以除了下一个顺序帧外丢弃其他帧，或将所有乱序的帧缓存起来，一直到需要这些帧的时候。 </p>
</li>
</ul>
</li>
<li><p>五、网络层</p>
</li>
<li><p>六、传输层</p>
</li>
<li><p>七、应用层</p>
</li>
<li><p>八、网络安全</p>
</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#网络编程">
    <span class="tag-code">网络编程</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/04/08/Linux/Linux学习笔记（Shell）/">
        <span class="nav-arrow">← </span>
        
          Linux学习笔记（Shell）
        
      </a>
    
    
      <a class="nav-right" href="/2018/04/08/Linux/Linux学习笔记（基础）/">
        
          Linux学习笔记（基础）
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="nav">none</ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/04/08/网络通信/网络编程基础/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "网络编程基础",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2018/04/08/网络通信/网络编程基础/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>